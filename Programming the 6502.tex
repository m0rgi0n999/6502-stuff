\documentclass{book}
\usepackage{caption}

\captionsetup[table]{
    labelformat=empty, % Removes the default "Table 1:"
    labelsep=none % Removes the colon
}


\begin{document}
PROGRAMMING
THE 6502
RODNAY ZAKS
FOURTH EDITION
Incorporating Answers to the Exercises
SYBEX
BERKELEY • PARIS • DUSSELDORF

====

Cover art: Daniel Le Noury
Every effort has been made to supply complete and accurate information. However, Sybex assumes no responsibility for its use, nor for any infringements of patents or other rights of third parties which would result. No license is granted by the equipment manufacturers under any patent or patent right. Manufacturers reserve the right to change circuitry at any time without notice.

Copyright © 1983 SYBEX Inc. 2344 Sixth Street, Berkeley, CA 94710. World rights reserved. No part of this publication may be stored in a retrieval system, copied, transmitted, or reproduced in any way, including, but not limited to photocopy, photography, magnetic or other recording, without the prior agreement and written permission of the publisher.

ISBN 0-89588-135-7
Library of Congress Card Number: 83-61686
First Edition published 1978. Fourth Edition 1983
Printed in the United States of America
10 98765432

====

CONTENTS

PREFACE vii

I. BASIC CONCEPTS ... 7
Introduction. What is Programming? Flowcharting. Information Representation.

II. 6502 HARDWARE ORGANIZATION ... 38
Introduction. System Architecture. Internal Organization of the 6502. The Instruction Execution Cycle. The Stack. The Paging Concept. The 6502 Chip. Hardware Summary.

III. BASIC PROGRAMMING TECHNIQUES ... 53
Introduction. Arithmetic Programs. BCD Arithmetic. Important Self-Test. Logical Operations. Subroutines. Summary.

IV. THE 6502 INSTRUCTION SET ... 99
PART 1-OVERALL DESCRIPTION
Introduction. Classes of Instructions. Instructions Available on the 6502.
PART 2-THE INSTRUCTIONS
Abbreviations. Description ofEach Instruction.

V. ADDRESSING TECHNIQUES ... 188
Introduction. Addressing Modes. 6502 Addressing Modes. Using the 6502 Addressing Modes. Summary.

VI. INPUT/OUTPUT TECHNIQUES ... 211
Introduction. Input/Output. Parallel Word Transfer. Bit Serial Transfer. Basic I/O Summary. Communicating with Input/Output Devices. Peripheral Summary. Input/Output Scheduling. Summary. Exercises.

VII. INPUT/OUTPUT DEVICES ... 254
Introduction. The Standard PIO (6520). The Internal Control Register. The 6530. Programming a PIO. The 6522. The 6532. Summary.

VIII. APPLICATION EXAMPLES ... 262
Introduction. Clear a Section of Memory. Polling I/O Devices. Getting Characters In. Testing a Character. Bracket Testing. Parity Generation. Code Conversion: ASCII to BCD. Find the Largest Element of a Table. Sum of N Elements. A Checksum Computation. Count the Zeroes. A String Search. Summary.

IX. DATA STRUCTURES ... 275
PART J-DESIGN CONCEPTS
Introduction. Pointers. Lists. Searching and Sorting. Summary. Data Structures.
PART2-DESIGN EXAMPLES
Introduction. Data Representation for the List. A Simple List. Alphabetic List. Binary Tree. A Hashing Algorithm. Bubble-Sort. A Merge Algorithm.
Summary.

X. PROGRAM DEVELOPMENT ... 343
Introduction. Basic Programming Choices. Software Support. The Pro gram Development Sequence. The Hardware Alternatives. Summary of Hardware Alternatives. Summary of Hardware Resources. The Assembler. Macros. Conditional Assembly. Summary.

XI. CONCLUSION ... 368
Technological Development. The Next Step.

APPENDICES ... 371
A. Hexadecimal Conversion Table
B. 6502 Instruction-Set: Alphabetic
C. 6502 Instruction-Set: Binary
D. 6502 Instruction-Set: Hexadecimal and Timing
E. ASCII Table
F. Relative Branch Table
G. Hex Opcode Listing
H. Decimal to BCD Conversion
I. Answers to the Exercises

INDEX ... 402

\section{PREFACE}

This book has been designed as a complete self-contained text to learn programming, using the 6502. It can be used by a person who has never programmed before, and should also be of value to anyone using the 6502.
For the person who has already programmed, this book will teach specific programming techniques using (or working around) the specific characteristics of the 6502. This text covers the elementary to intermediate techniques required to start pro gramming effectively.
This text aims at providing a true level of competence to the person who wishes to program using this microprocessor. Naturally, no book will teach effectively how to program, unless one actually practices. However, it is hoped that this book will take the reader to the point where he feels that he can start program ming by himself and solve simple or even moderately complex problems using a microcomputer.
This book is based on the author's experience in teaching more than 1000 persons how to program microcomputers. As a result, it is strongly structured. Chapters normally go from the simple to the complex. For readers who have already learned elementary programming, the introductory chapter may be skipped. For others who have never programmed, the final sections of some chapters may require a second reading. The book has been designed to take the reader systematically through all the basic concepts and techniques required to build increasingly complex programs. It is, therefore, strongly suggested that the ordering of the chapters be followed. In addition, for effective results, it is important that the reader attempt to solve as many exercises as possible. The difficulty within the exercises has been carefully graduated. They are designed to verify that the material which has been presented is really understood. Without doing the programming exercises, it will not be possible to realize the full value of this book as an educational medium. Several of the exercises may require time, such as the multiplication exercise for example. However, by doing these, you will actually program and \textit{learn by doing}. This is indispensable.
For those who will have acquired a taste for programming when reaching the end of this volume, companion volumes are available:

—"6502 Applications" covers input/output.
—"Advanced 6502 Programming" covers complex algorithms.

Other books in this series cover programming for other popular microprocessors.
For those who wish to develop their hardware knowledge, it is suggested that the reference books "From Chips to Systems" (ref. C201A) and "Microprocessor Interfacing Techniques" (ref. C207) be consulted.
The author would like to thank Rockwell International, who pro vided access to one of the first ASM65 development systems.
The contents of this book have been checked carefully and are believed to be reliable. However, inevitably, some typographical or other errors will be found. The author will be grateful for any comments by alert readers so that future editions may benefit from their experience. Any other suggestions for improvements, such as other programs desired, developed, or found of value by readers, will be appreciated.

\section*{PREFACE TO THE FOURTH EDITION}

In the five years since this book was originally published, the audience of 6502 microprocessor users has grown exponentially, and it continues
to grow. This book has expanded with its audience.
The Second Edition increased in size by almost 100 pages, with most of the new material being added to Chapters 1 and 9. Additional improvements have been made continually throughout the book. In this Fourth Edition, answers to the exercises have been included as an appendix (Appendix I). These answers appear in response to the request of many readers, who wanted to make sure that their knowledge of 6502 programming was thorough.
I would like to thank the many readers of the previous editions who have contributed valuable suggestions for improvement. Special acknowledgements are due to Eric Novikoff and Chris Williams for their contributions to the answers to the exercises, as well as to the complex programming examples in Chapter 9. Special thanks also go to Daniel J. David, for his many suggested improvements. A number of changes and enhancements are also due to the valuable analysis and comments proposed by Philip K. Hooper, John Smith, Ronald Long, Charles Curlay, N. Harris, John McClenon, Douglas Trusty, Fletcher Carson, and Professor Myron Calhoun.

====

Acknowledgements
The author would like to express his appreciation to Rockwell International and, in particular, to Scotty Maxwell, who made available to him one of the very first system 65 development systems. The availability of this powerful development tool, at the time the first version of this book was being written, was a major help for the accurate and efficient checkout of all the programs. I would also like to thank Professor Myron Calhoun for his contributions.


\chapter{BASIC CONCEPTS}

\section*{INTRODUCTION}

This chapter will introduce the basic concepts and definitions relating to computer programming. The reader already familiar with these concepts may want to glance quickly at the contents of this chapter and then move on to Chapter 2. It is suggested, however, that even the experienced reader look at the contents of this introductory chapter. Many significant concepts are presented here including, for example, two's complement, BCD, and other representations. Some of these concepts may be new to the reader; others may improve the knowledge and skills of experienced programmers.

\section*{WHAT IS PROGRAMMING?}

Given a problem, one must first devise a solution. This solution,
expressed as a step-by-step procedure, is called an \textit{algorithm}. An
algorithm is a step-by-step specification of the solution to a given
problem. It must terminate in a finite number of steps. This
algorithm may be expressed in any language or symbolism. A simple example of an algorithm is:

\begin{itemize}
\item{insert key in the keyhole}
\item{turn key one full turn to the left}
\item{seize doorknob}
\item{turn doorknob left and push the door}
\end{itemize}

At this point, if the algorithm is correct for the type of lock involved, the door will open. This four-step procedure qualifies as an algorithm for door opening.
Once a solution to a problem has been expressed in the form of an algorithm, the algorithm must be executed by the computer.
Unfortunately, it is now a well-established fact that computers cannot understand or execute ordinary spoken English (or any other human language). The reason lies in the \textit{syntactic ambiguity} of all common human languages. Only a well-defined subset of natural language can be "understood" by the computer. This is called a \textit{programming language}.
Converting an algorithm into a sequence of instructions in a programming language is called \textit{programming}. To be more specific, the actual translation phase of the algorithm into the programming language is called \textit{coding}. Programming really refers not just to the coding but also to the overall design of the programs and "data structures" which will implement the algorithm.
Effective programming requires not only understanding the possible implementation techniques for standard algorithms, but also the skillful use of all the computer hardware resources, such as internal registers, memory, and peripheral devices, plus a creative use of appropriate data structures. These techniques will be covered in the next chapters.
Programming also requires a strict documentation discipline, so that the programs are understandable to others, as well as to the author. Documentation must be both internal and external to the program.
Internal program documentation refers to the comments placed in the body of a program, which explain its operation.
External documentation refers to the design documents which are separate from the program: written explanations, manuals, and flowcharts.

\section*{FLOWCHARTING}

One intermediate step is almost always used between the
\textit{algorithm} and the \textit{program}. It is called a \textit{flowchart}. A flowchart is
simply a symbolic representation of the algorithm expressed as a
sequence of rectangles and diamonds containing the steps of the
algorithm. Rectangles are used for \textit{commands}, or "executable
statements." Diamonds are used for \textit{tests} such as: If information
X is true, then take action A, else B. Instead of presenting a formal
definition of flowcharts at this point, we will introduce and discuss
flowcharts later on in the book when we present programs.
Flowcharting is a highly recommended intermediate step between the algorithm specification and the actual coding of the solution. Remarkably, it has been observed that perhaps 10\% of the
programming population can write a program successfully without having to flowchart. Unfortunately, it has also been observed
that 90\% of the population believes it belongs to this 10\%! The
result: 80\% of these programs, on the average, will fail the first
time they are run on a computer. (These percentages are naturally
not meant to be accurate.) In short, most novice programmers seldom see the necessity of drawing a flowchart. This usually results
in "unclean" or erroneous programs. They must then spend a long
time testing and correcting their program (this is called the
\textit{debugging} phase). The discipline of flowcharting is therefore
highly recommended in all cases. It will require a small amount of
additional time prior to the coding, but will usually result in a clear
program which executes correctly and quickly. Once flowcharting
is well understood, a small percentage of programmers will be able
to perform this step mentally without having to do it on paper. Un
fortunately, in such cases the programs that they write will usually be hard to understand for anybody else without the documentation provided by flowcharts. As a result, it is universally recommended that flowcharting be used as a strict discipline for any
significant program. Many examples will be provided throughout
the book.

\section*{INFORMATION REPRESENTATION}

All computers manipulate information in the form of numbers or
in the form of characters. Let us examine here the external and
internal representations of information in a computer.

\textit{INTERNAL REPRESENTATION OF INFORMATION}

All information in a computer is stored as groups of bits. A \textit{bit}
stands for a \textit{binary digit} ("0" or "1"). Because of the limitations
of conventional electronics, the only practical representation of information uses two-state logic (the representation of the state "0" and
"1"). The two states of the circuits used in digital electronics
are generally "on" or "off, and these are represented logically by the symbols "0" or "1". Because these circuits are
used to implement "logical" functions, they are called "binary
logic." As a result, virtually all information-processing today is
performed in binary format. In the case of microprocessors in
general, and of the 6502 in particular, these bits are structured in
groups of eight. A group of eight bits is called a byte. A group of
four bits is called a \textit{nibble}.
Let us now examine how information is represented internally in
this binary format. Two entities must be represented inside the
computer. The first one is the program, which is a sequence of
instructions. The second one is the data on which the program will
operate, which may include numbers or alphanumeric text. We will
discuss below three representations: program, numbers, and alphanumerics.

\subsection*{Program Representation}
All instructions are represented internally as single or multiple
bytes. A so-called "short instruction" is represented by a single
byte. A longer instruction will be represented by two or more
bytes. Because the 6502 is an eight-bit microprocessor, it fetches
bytes successively from its memory. Therefore, a single-byte
instruction always has a potential for executing faster than a two-or
three-byte instruction. It will be seen later that this is an important feature of the instruction set of any microprocessor and in
particular the 6502, where a special effort has been made to provide as many single-byte instructions as possible in order to im
prove the efficiency of the program execution. However, the limitation to 8 bits in length has resulted in important restrictions which
will be outlined. This is a classic example of "the compromise between speed and flexibility in programming. The binary code used
to represent instructions is dictated by the manufacturer. The
6502, like any other microprocessor, comes equipped with a fixed
instruction set. These instructions are defined by the manufacturer and are listed at the end of this book, with their code. Any
program will be expressed as a sequence of these binary instructions. The 6502 instructions are presented in Chapter 4.

\subsection*{Representing Numeric Data}

Representing numbers is not quite straightforward, and several
cases must be distinguished. We must first represent integers, then
signed numbers, i.e., positive and negative numbers, and finally we
must be able to represent decimal numbers. Let us now address
these requirements and possible solutions.
Representing integers may be performed by using a \textit{direct
binary} representation. The direct binary representation is simply
the representation of the decimal value of a number in the binary
system. In the binary system, the right-most bit represents 2 to
the power 0. The next one to the left represents 2 to the power 1,
the next represents 2 to the power 2, and the left-most bit
represents 2 to the power 7 = 128.

b\textsubscript{7}b\textsubscript{6}b\textsubscript{5}b\textsubscript{4}b\textsubscript{3}b\textsubscript{2}b\textsubscript{1}b\textsubscript{0}
represents
b\textsubscript{7}2\textsuperscript{7} + b\textsubscript{6}2\textsuperscript{6} + b\textsubscript{5}2\textsuperscript{5} + b\textsubscript{4}2\textsuperscript{4} + b\textsubscript{3}2\textsuperscript{3} + b\textsubscript{2}2\textsuperscript{2} + b\textsubscript{1}2\textsuperscript{1} + b\textsubscript{0}2\textsuperscript{0}

The powers of 2 are:
2\textsuperscript{7} = 128, 2\textsuperscript{6} = 64, 2\textsuperscript{5} = 32, 2\textsuperscript{4} = 16, 2\textsuperscript{3} = 8, 2\textsuperscript{2} = 4, 2\textsuperscript{1} = 2, 2\textsuperscript{0} = 1
The binary representation is analogous to the decimal representa
tion of numbers, where "123" represents:
1 \times 100 = 100
+ 2 \times 10 = 20
+ 3 \times 1 = 3
= 123
Note that 100 = 10\textsuperscript{2}, 10 = 10\textsuperscript{1}, 1 = 10\textsuperscript{0}.
In this "positional notation," each digit represents a power of 10.
In the binary system, each binary digit or "bit" represents a power
of 2, instead of a power of 10 in the decimal system.
Example: "00001001" in binary represents:
1 \times 1 = 1 (2\textsuperscript{0})
0 \times 2 = 0 (2\textsuperscript{1})
0 \times 4 = 0 (2\textsuperscript{2})
1 \times 8 = 8 (2\textsuperscript{3})
0 \times 16 = 0 (2\textsuperscript{4})
0 \times 32 = 0 (2\textsuperscript{5})
0 \times 64 = 0 (2\textsuperscript{6})
0 \times 128 = 0 (2\textsuperscript{7})
in decimal: = 9
Let us examine some more examples:
"10000001" represents:
1 \times 1 = 1 (2\textsuperscript{0})
0 \times 2 = 0 (2\textsuperscript{1})
0 \times 4 = 0 (2\textsuperscript{2})
0 \times 8 = 0 (2\textsuperscript{3})
0 \times 16 = 0 (2\textsuperscript{4})
0 \times 32 = 0 (2\textsuperscript{5})
0 \times 64 = 0 (2\textsuperscript{6})
1 \times 128 = 128 (2\textsuperscript{7})
in decimal: = 129
"10000001" represents, therefore, the decimal number 129.

By examining the binary representation of numbers, you will
understand why bits are numbered from 0 to 7, going from right to
left. Bit 0 is "b\textsubscript{0}" and corresponds to 2\textsuperscript{0}. Bit 1 is "b\textsubscript{1}; and corresponds to 2\textsuperscript{1} and so on.
\begin{tabular}
    \begin{table}{rlrl}
        Decimal & Binary & Decimal & Binary \\
        0 & 00000000 & 32 & 00100000 \\
        1 & 00000001 & 33 & 00100001 \\
        2 & 00000010 & • &  \\
        3 & 00000011 & • &  \\
        4 & 00000100 & • &  \\
        5 & 00000101 & 63 & 00111111 \\
        6 & 00000110 & 64 & 01000000 \\
        7 & 00000111 & 65 & 01000001 \\
        8 & 00001000 & • &  \\
        9 & 00001001 & • &  \\
        10 & 00001010 & 127 & 01111111 \\
        11 & 00001011 & 128 & 10000000 \\
        12 & 00001100 & 129 & 10000001 \\
        13 & 00001101 &  &  \\
        14 & 00001110 & • &  \\
        15 & 00001111 &  &  \\
        16 & 00010000 & • &  \\
        17 & 00010001 &  &  \\
        • &  & • &  \\
        • &  &  &  \\
        • &  & 254 & 11111110 \\
        31 & 00011111 & 255 & 11111111
    \end{table}
    \caption{Fig 1-2: Decimal-Binary Table}
\end{tabular}

The binary equivalents of the numbers from 0 to 255 are shown
in Fig. 1-2.
Exercise 1.1: What is the decimal value of "11111100"?

Decimal to Binary
Conversely, let us compute the binary equivalent of "11" decimal:
11-5-2=5 remains 1 —♦I (LSB)
5-^-2=2 remains 1—^1
2-^2=1 remains 0—^0
1-^-2=0 remains 1 —^ 1 (MSB)
The binary equivalent is 1011 (read right-most column from bottom
to top).
The binary equivalent of a decimal number may be obtained by dividing
successively by 2 until a quotient of 0 is obtained.
Exercise 1.2: What is the binary for 257?
Exercise 1.3: Convert 19 to binary, then back to decimal.
Operating on Binary Data
The arithmetic rules for binary numbers are straightforward. The rules
for addition are:
0+0= 0
0+1= 1
1+0= 1
where (1) denotes a "carry" of 1 (note that "10" is the binary equivalent
of "2" decimal). Binary subtraction will be performed by "adding the
complement" and will be explained once we learn how to represent
negative numbers.
Example:
(2) 10
+(1) +01
=(3) 11
Addition is performed just like in decimal, by adding columns, from
right to left:
Adding the right-most column:
10
+01
(0 + 1 = 1. No carry.)
14
BASIC CONCEPTS
Adding the next column:
10
11 (1+0 =1. No carry.)
Exercise 1.4: Compute 5 + 10 in binary. Verify that the result is 15.
Some additional examples of binary addition:
0010 (2) 0011 (3)
+0001 (1) +0001 (1)
=0011 (3) =0100 (4)
This last example illustrates the role of the carry.
Looking at the right-most bits: 1 + 1 = (1) 0
A carry of 1 is generated, which must be added to the next bits:
001 — column 0 has just been added
+000 -
+ 1 (carry)
= (1)0 — where (1) indicates a new
carry into column 2.
The final result is: 0100
Another example:
0111 (7)
+0011 + (3)
1010 =(10)
In this example, a carry is again generated, up to the left-most co
lumn.
Exercise 1.5: Compute the result of:
1111
+0001
15
PROGRAMMING THE 6502
Does the result hold in four bits?
With eight bits, it is therefore possible to represent directly the
numbers "00000000" to "11111111," i.e., "0" to "255". Two
obstacles should be visible immediately. First, we are only
representing positive numbers. Second, the magnitude of these
numbers is limited to 255 if we use only eight bits. Let us address
each of these problems in turn.
Signed Binary
In a signed binary representation, the left-most bit is used to in
dicate the sign of the number. Traditionally, "0" is used to denote
a positive number while "1" is used to denote a negative number.
Now "11111111" will represent -127, while "01111111" will
represent +127. We can now represent positive and negative
numbers, but we have reduced the maximum magnitude of these
numbers to 127.
Example: "0000 0001" represents +1 (the leading "0" is " + ",
followed by "000 0001" = 1).
"1000 0001" is -1 (the leading "1" is "-").
Exercise 1.6: What is the representation of "—5" in signed binary?
Let us now address the magnitude problem: in order to represent
larger numbers, it will be necessary to use a larger number of bits.
For example, if we use sixteen bits (two bytes) to represent
numbers, we will be able to represent numbers from — 32K to
+32K in signed binary (IK in computer jargon represents 1,024).
Bit 15 is used for the sign, and the remaining 15 bits (bit 14 to bit
0) are used for the magnitude: 215 = 32K. If this magnitude is still
too small, we will use 3 bytes or more. If we wish to represent large
integers, it will be necessary to use a larger number of bytes inter
nally to represent them. This is why most simple BASICs, and
other languages, provide only a limited precision for integers. This
way, they can use a shorter internal format for the numbers which
they manipulate. Better versions of BASIC, or of these other
languages, provide a larger number of significant decimal digits at
the expense of a large number of bytes for each number.
Now let us solve another problem, the one of speed efficiency.
We are going to attempt performing an addition in the signed
16
BASIC CONCEPTS
binary representation which we have introduced. Let us add " — 5"
and"+7".
+7 is represented by 00000 111
-5 is represented by 10000101
The binary sum is: 10001100, or —12
This is not the correct result. The correct result should be +2. In
order to use this representation, special actions must be taken, de
pending on the sign. This results in increased complexity and re
duced performance. In other words, the binary addition of signed
numbers does not "work correctly." This is annoying. Clearly, the
computer must not only represent information, but also perform
arithmetic on it.
The solution to this problem is called the two's complement
representation, which will be used instead of the signed binary
representation. In order to introduce two's complement let us first
introduce an intermediate step: one's complement.
One's Complement
In the one's complement representation, all positive integers are
represented in their correct binary format. For example "+3" is
represented as usual by 00000011. However, its complement "—3"
is obtained by complementing every bit in the original representa
tion. Each 0 is transformed into a 1 and each 1 is transformed into
a 0. In our example, the one's complement representation of "—3"
will be 11111100.
Another example:
+2 is 00000010
-2 is 11111101
Note that, in this representation, positive numbers start with a
"0" on the left, and negative ones with a "1" on the left.
Exercise 1.7: The representation of "+6" is "00000110". What is
the representation of "—6" in one's complement?
As a test, let us add minus 4 and plus 6:
17
PROGRAAAAAING THE 6502
-4 is 11111011
+6 is 00000110
the sum is: (1) 00000001 where (1) indicates a
carry
The "correct result" should be "2", or "00000010".
Let us try again:
-3is 11111100
-2is 11111101
(1) 00000001
The sum is:
or "1," plus a carry. The correct result should be "-5." The repre
sentation of "-5" is 11111010. It did not work.
This representation does represent positive and negative
numbers. However the result of an ordinary addition does not
always come out "correctly." We will use still another representa
tion. It is evolved from the one's complement and is called the
two's complement representation.
Two's Complement Representation
In the two's complement representation, positive numbers are
still represented, as usual, in signed binary, just like in one's com
plement. The difference lies in the representation of negative
numbers. A negative number represented in two's complement is
obtained by first computing the one's complement, and then ad
ding one. Let us examine this in an example:
+3 is represented in signed binary by 00000011. Its one's com
plement representation is 11111100. The two's complement is ob
tained by adding one. It is 11111101.
Let us try an addition:
(3) 00000011
+(5) +00000101
=(8) =00001000
The result is correct.
18
BASIC CONCEPTS
Let us try a subtraction:
(3) 00000011
(-5) +11111011
=11111110
Let us identify the result by computing the two's complement:
the one's complement of 11111110 is 00000001
Adding 1 + 1
therefore the two's complement is 00000010 or +2
Our result above, "11111110" represents "—2". It is correct.
We have now tried addition and subtraction, and the results were correct
(ignoring the carry). It seems that two's complement works!
Exercise 1.8: What is the two's complement representation of "+127"?
Exercise 1.9: What is the two's complement representation of "-128"?
Let us now add +4 and —3 (the subtraction is performed by add
ing the two's complement):
+4 is 00000100
-3 is 11111101
The result is: (1) 00000001
If we ignore the carry, the result is 00000001, i.e., "V' in decimal. This
is the correct result. Without giving the complete mathematical proof,
let us simply state that this representation does work. In two's comple
ment, it is possible to add or subtract signed numbers regardless of the
sign. Using the usual rules of binary addition, the result comes out
correctly, including the sign. The carry is ignored. This is a very signifi
cant advantage. If it were not the case, one would have to correct the
result for sign every time, causing a much slower addition or subtraction
time.
For the sake of completeness, let us state that two's complement is
simply the most convenient representation to use for simpler processors
such as microprocessors. On complex processors, other representations
may be used. For example, one's complement may be used, but it requires
special circuitry to "correct the result."
19
PROGRAMMING THE 6502
From this point on, all signed integers will implicitly be represented
internally in two's complement notation. See Fig. 1-3 for a table of
two's complement numbers.
Exercise 1.10: What are the smallest and the largest numbers which one
may represent in two's complement notation, using only one byte?
Exercise 1.11: Compute the two's complement of 20. Then compute the
two's complement ofyour result. Do you find 20 again?
The following examples will serve to demonstrate the rules of two's
complement. In particular, C denotes a possible carry (or borrow)
condition. (It is bit 8 of the result.)
V denotes a two's complement overflow, i.e., when the sign of the
result is changed "accidentally" because the numbers are too
large. It is an essentially internal carry from bit 6 into bit 7 (the
sign bit). This will be clarified below.
Let us now demonstrate the role of the carry "C" and the overflow
"V".
The Carry C
Here is an example of a carry:
(128)
+(129)
10000000
+10000001
(257) = (1) 00000001
where (1) indicates a carry.
The result requires a ninth bit (bit "8", since the right-most bit is
"0"). It is the carry bit.
If we assume that the carry is the ninth bit of the result, we
recognize the result as being 100000001 = 257.
However, the carry must be recognized and handled with care.
Inside the microprocessor, the registers used to hold information
are generally only eight-bit wide.When storing the result, only bits 0 to
7 will be preserved.
A carry, therefore, always requires special action: it must be
detected by special instructions, then processed. Processing the
carry means either storing it somewhere (with a special instruc
tion), or ignoring it, or deciding that it is an error (if the largest
authorized result is "11111111").
20
BASIC CONCEPTS
+
+ 127
+ 126
+ 125
+ 65
+ 64
+ 63
+ 33
+ 32
+ 31
+ 17
+ 16
+ 15
+ 14
+ 13
+ 12
+ 11
+ 10
+ 9
+ 8
+ 7
+ 6
+ 5
+ 4
+ 3
+ 2
+ 1
+ 0
2's complement
code
01111111
01111110
01111101
01000001
01000000
00111111
00100001
00100000
00011111
00010001
00010000
00001111
00001110
00001101
00001100
00001011
00001010
00001001
00001000
00000111
00000110
00000101
00000100
00000011
00000010
00000001
00000000
-128
-127
-126
-125
-65
-64
-63
-33
-32
-31
-17
-16
-15
-14
-13
-12
-11
-10
-9
-8
-7
-6
-5
-4
-3
-2
-1
2's complement
code
10000000
10000001
10000010
10000011
10111111
11000000
11000001
11011111
11100000
11100001
11101111
11110000
11110001
11110010
11110011
11110100
11110101
11110110
11110111
11111000
11111001
11111010
11111011
11111100
11111101
11111110
11111111
Fig. 1-3:2's Complement Table
21
PROGRAMMING THE 6502
Overflow V
Here is an example of overflow:
bit 6
bit 7
01000000 (64)
+01000001 +(65)
= 10000001 =(-127)
An internal carry has been generated from bit 6 into bit 7. This is
called an overflow.
The result is now negative, "by accident." This situation must
be detected, so that it can be corrected.
Let us examine another situation:
11111111 (-1)
+ 11111111 +(-1)
=(1) 11111110 =(-2)
Y
carry
In this case, an internal carry has been generated from bit 6 into
bit 7, and also from bit 7 into bit 8 (the formal "Carry" C we have
examined in the preceding section). The rules of two's complement
arithmetic specify that this carry should be ignored. The result is
then correct.
This is because the carry from bit 6 into bit 7 did not change the
sign bit.
This is not an overflow condition. When operating on negative
numbers, the overflow is not simply a carry from bit 6 into bit 7.
Let us examine one more example.
11000000 (-64)
+ 10111111 (-65)
=(1) 01111111 (+127)
carry
This time, there has been no internal carry from bit 6 into bit 7, but
there has been an external carry. The result is incorrect, as bit 7
has been changed. An overflow condition should be indicated.
22
BASIC CONCEPTS
Overflow will occur in four situations:
1—adding large positive numbers
2—adding large negative numbers
3—subtracting a large positive number from a large negative
number
4—subtracting a large negative number from a large positive
number.
Let us now improve our definition of the overflow:
Technically, the overflow indicator, a special bit reserved for this
purpose, and called a "flag," will be set when there is a carry from
bit 6 into bit 7 and no external carry, or else when there is no carry
from bit 6 into bit 7 but there is an external carry. This indicates
that bit 7, i.e., the sign of the result, has been accidentally
changed. For the technically-minded reader, the overflow flag is
set by Exclusive ORing the carry-in and carry-out of bit 7 (the sign
bit). Practically every microprocessor is supplied with a special
overflow flag to automatically detect this condition, which re
quires corrective action.
Overflow indicates that the result of an addition or a subtraction
requires more bits than are available in the standard eight-bit
register used to contain the result.
The Carry and the Overflow
The carry and the overflow bits are called "flags." They are pro
vided in every microprocessor, and in the next chapter we will
learn to use them for effective programming. These two indicators
are located in a special register called the flags or " status"
register. This register also contains additional indicators whose
function will be clarified in Chapter 4.
Examples
Let us now illustrate the operation of the carry and the overflow
in actual examples. In each example, the symbol V denotes the
overflow, and C the carry.
If there has been no overflow, V = 0. If there has been an
overflow, V = 1 (same for the carry C). Remember that the rules of
two's complement specify that the carry be ignored. (The
mathematical proof is not supplied here.)
23
PROGRAMMING THE 6502
Positive-Positive
00000110 (+6)
+ 00001000 (+8)
= 00001110 ( + 14) V:0 C:0
(CORRECT)
Positive-Positive with Overflow
01111111 ( + 127)
+ 00000001 (+1)
= 10000000 (-128) V:l C:0
The above is invalid because an overflow has occurred.
(ERROR)
Positive-Negative (result positive)
00000100 (+4)
+ 11111110 (-2)
=(1)00000010 (+2) V:0 C:l (disregard)
(CORRECT)
Positive-Negative (result negative)
00000010 (+2)
+ 11111100 (-4)
= 11111110 (-2) V:0 C:0
(CORRECT)
Negative-Negative
11111110 (-2)
+ 11111010 (-4)
=(1)11111010 (-6) V:0 C:l (disregard)
(CORRECT)
Negative-Negative with Overflow
10000001 (-127)
+ 11000010 (-62)
=(1)01000011 (67) V:l C:l
(ERROR)
24
BASIC CONCEPTS
This time an "underflow" has occurred, by adding two large
negative numbers. The result would be -189, which is too large to
reside in eight bits.
Exercise 1.12: Complete the following additions. Indicate the
result, the carry C, the overflow V, and whether the result is correct
or not:
10111111 ( ) 11111010 ( )
-hi 1000001 ( ) +11111001 ( )
= V: C: = V: C:
□ CORRECT [_] ERROR □ CORRECT D ERROR
00010000 ( ) 01111110 ( )
+01000000 ( ) +00101010 ( )
= V: C: = V: C:
D CORRECT I ]ERROR □ CORRECT G ERROR
Exercise 1.13: Can you show an example of overflow when adding a
positive and a negative number? Why?
Fixed Format Representation
Now we know how to represent signed integers. However, we
have not yet resolved the problem of magnitude. If we want to
represent larger integers, we will need several bytes. In order to
perform arithmetic operations efficiently, it is necessary to use a
fixed number of bytes rather than a variable one. Therefore, once
the number of bytes is chosen, the maximum magnitude of the
number which can be represented is fixed.
Exercise 1.14: What are the largest and the smallest numbers
which may be represented in two bytes using two's complement?
The Magnitude Problem
When adding numbers we have restricted ourselves to eight bits
because the processor we will use operates internally on eight bits
at a time. However, this restricts us to the numbers in the range
—128 to +127. Clearly, this is not sufficient for many applications.
Multiple precision will be used to increase the number of digits
which can be represented. A two-, three-, or N-byte format may
25
PROGRAMMING THE 6502
then be used. For example, let us examine a 16-bit, "double-pre
cision" format:
00000000 00000000 is "0"
00000000 00000001 is "1"
01111111
11111111
11111111
11111111
11111111
11111110
is
is
is
"32767
"—2"
Exercise 1.15: What is the largest negative integer which can be
represented in a two's complement triple-precision format?
However, this method will result in disadvantages. When adding
two numbers, for example, we will generally have to add them
eight bits at a time. This will be explained in Chapter 4 (Basic Pro
gramming Techniques). It results in slower processing. Also, this
representation uses 16 bits for any number, even if it could be
represented with only eight bits. It is, therefore, common to use 16
or perhaps 32 bits, but seldom more.
Let us consider the following important point: whatever the
number of bits N chosen for the two's complement representation,
it is fixed. If any result or intermediate computation should
generate a number requiring more than N bits, some bits will be
lost. The program normally retains the N left-most bits (the most
significant) and drops the low-order ones. This is called truncating
the result.
Here is an example in the decimal system, using a six digit
representation:
123456
X 1.2
246912
123456
= 148147.2
The result requires 7 digits! The "2" after the decimal point will be
dropped and the final result will be 148147. It has been truncated.
Usually, as long as the position of the decimal point is not lost, this
method is used to extend the range of the operations which may be
performed, at the expense of precision.
The problem is the same in binary. The details of a binary multi-
26
BASIC CONCEPTS
plication will be shown in Chapter 4.
This fixed-format representation may cause a loss of precision,
but it may be sufficient for usual computations or mathematical
operations.
Unfortunately, in the case of accounting, no loss of precision is
tolerable. For example, if a customer rings up a large total on a
cash register, it would not be acceptable to have a five figure
amount to pay, which would be approximated to the dollar.
Another representation must be used wherever precision in the
result is essential. The solution normally used is BCD, or
binary-coded decimal.
BCD Representation
The principle used in representing numbers in BCD is to encode
each decimal digit separately, and to use as many bits as necessary
to represent the complete number exactly. In order to encode each
of the digits from 0 through 9, four bits are necessary. Three bits
would only supply eight combinations, and can therefore not en
code the ten digits. Four bits allow sixteen combinations and are
therefore sufficient to encode the digits "0" through "9". It can
also be noted that six of the possible codes will not be used in the
BCD representation (see Fig. 1-3). This will result later on in a po
tential problem during additions and subtractions, which we will
have to solve. Since only four bits are needed to encode a BCD
CODE
0000
0001
0010
0011
0100
0101
0110
0111
BCD
SYMBOL
0
1
2
3
4
5
6
7
CODE
1000
1001
1010
1011
1100
1101
1110
nil
BCD
SYMBOL
8
9
unused
unused
unused
unused
unused
unused
Fig. 1-4: BCD Table
27
PROGRAMMING THE 6502
digit, two BCD digits may be encoded in every byte. This is called
"packed BCD."
As an example, "00000000" will be "00" in BCD. "10011001"
will be "99".
A BCD code is read as follows:
001
BCD digit "2" **-*
BCD digit "1" *+—
BCD number "21"
Exercise 1.16: What is the BCD representation for "29"? "91"?
Exercise 1.17: Is "10100000" a valid BCD representation? Why?
As many bytes as necessary will be used to represent all BCD
digits. Typically, one or more nibbles will be used at the beginning
of the representation to indicate the total number of nibbles, i.e.,
the total number of BCD digits used. Another nibble or byte will
be used to denote the position of the decimal point. However, con
ventions may vary.
Here is an example of a representation for multibyte BCD in
tegers:
Obytes) 3 +
number
3f digits
2 2 1
number "221"
(up to 255) sign
This represents +221
(The sign may be represented by 0000 for +, and 0001 for -, for
example.)
Exercise 1.18: Using the same convention, represent "-23123". Show
it in BCDformat, as above, then in binary.
Exercise 1.19: Show the BCD for "222" and "111", then for the result
of 222 x 111. (Compute the result by hand, then show it in the above
representation.)
The BCD representation can easily accommodate decimal
numbers.
28
BASIC CONCEPTS
For example, +2.21 may be represented by:
J~\ I 221
3 digits "."is on the +
left of digit 2
The advantage of BCD is that it yields absolutely correct
results. Its disadvantage is that it uses a large amount of memory
and results in slow arithmetic operations. This is acceptable only
in an accounting environment and is normally not used in other
cases.
Exercise 1.20: How many bits are required to encode '9999" in BCD?
And in Two's complement?
We have now solved the problems associated with the represen
tation of integers, signed integers and even large integers. We
have even already presented one possible method of representing
decimal numbers, with BCD representation. Let us now examine
the problem of representing decimal numbers in a fixed length for
mat.
Floating-Point Representation
The basic principle is that decimal numbers must be represented
with a fixed format. In order not to waste bits, the representation
will normalize all the numbers.
For example, "0.000123" wastes three zeros on the left of the
number, which have no meaning except to indicate the position of
the decimal point. Normalizing this number results in .123 X 103.
".123" is called a normalized mantissa, "—3" is called the expo
nent. We have normalized this number by eliminating all the meaning
less zeros on the left of it and adjusting the exponent.
Let us consider another example:
22.1 is normalized as .221 x 102
or M X 10E where M is the mantissa, and E is the exponent.
29
PROGRAMMING THE 6502
It can be readily seen that a normalized number is characterized
by a mantissa less than 1 and greater or equal to .1 in all cases
where the number is not zero. In other words, this can be repre
sented mathematically by:
.1 < M < 1 or 10-1 < M < 10°
Similarly, in the binary representation:
21<M<2° (or .
Where M is the absolute value of the mantissa (disregarding the
sign).
For example:
111.01 is normalized as: .11101 X 23.
The mantissa is 11101.
*The exponent is 3.
Now that we have defined the principle of the representation,
let us examine the actual format. Atypical floating-point represen
tation appears below.
31 24 23 16 15
1 1 T
S EXP
I
MANTISSA
Fig. 1-5: Typical Floating-Point Representation
In the representation used in this example, four bytes are used
for a total of 32 bits. The first byte on the left of the illustration is
used to represent the exponent. Both the exponent and the man
tissa will be represented in two's complement. As a result, the
maximum exponent will be -128. "S" in Fig. 1-5 denotes the sign
bit.
Three bytes are used to represent the mantissa. Since the first
bit in the two's complement representation indicates the sign, this
leaves 23 bits for the representation of the magnitude of the man
tissa.
30
BASIC CONCEPTS
Exercise 1.21: How many decimal digits can the mantissa repre
sent with the 23 bits?
This is only one example of a floating point representation. It is
possible to use only three bytes, or it is possible to use more. The
four-byte representation proposed above is just a common one
which represents a reasonable compromise in terms of accuracy,
magnitude of numbers, storage utilization, and efficiency in
arithmetic operation.
We have now explored the problems associated with the rep
resentation of numbers and we know how to represent them in in
teger form, with a sign, or in decimal form. Let us now examine
how to represent alphanumeric data internally.
Representing Alphanumeric Data
The representation of alphanumeric data, i.e. characters, is com
pletely straightforward: all characters are encoded in an eight-bit
code. Only two codes are in general use in the computer world, the
ASCII Code, and the EBCDIC Code. ASCII stands for *'American
Standard Code for Information Interchange," and is universally
used in the world of microprocessors. EBCDIC is a variation of
ASCII used by IBM, and therefore not used in the microcomputer
world unless one interfaces to an IBM terminal.
Let us briefly examine the ASCII encoding. We must encode 26
letters of the alphabet for both upper and lower case, plus 10
numeric symbols, plus perhaps 20 additional special symbols. This
can be easily accomplished with 7 bits, which allow 128 possible
codes. (See Fig. 1-6.) All characters are therefore encoded in 7 bits.
The eighth bit, when it is used, is the parity bit Parity is a tech
nique for verifying that the contents of a byte have not been ac
cidentally changed. The number of l's in the byte is counted and
the eighth bit is set to one if the count was odd, thus making the
total even. This is called even parity. One can also use odd parity,
i.e. writing the eighth bit (the left-most) so that the total number of
l's in the byte is odd.
Example: let us compute the parity bit for "0010011" using even
parity. The number of l's is 3. The parity bit must therefore be a 1
so that the total number of bits is 4, i.e. even. The result is
10010011, where the leading 1 is the parity bit and 0010011 iden
tifies the character.
31
PROGRAMMING THE 6502
The table of 7-bit ASCII codes is shown in Fig. 1-6. In practice, it
is used "as is," i.e. without parity, by adding a 0 in the left-most
position, or else with parity, by adding the appropriate extra bit on
the left.
Exercise 1.22: Compute the 8-bit representation of the digits "0"
through "0", using even parity. (This code will be used in applica
tion examples of Chapter 8.)
Exercise 1.23: Same for the letters "A " through 44F".
Exercise 1.24: Using a non-parity ASCII code (where the left-most
bit is "0'7, indicate the binary contents of the 4 bytes below:
BIT NUMBERS
\
br
\
\
b.
\
♦
b.
\ J
0
0
0
0
0
0
0
0
1
1
1
1
1
1
1
1
b>
\
0
0
0
0
1
1
1
1
0
0
0
0
1
1
1
1
b,
\
0
0
1
1
0
0
1
1
0
0
1
J
0
0
1
1
b.
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
\HEX1
HEXOS.
0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
0
0
0
0
NUL
SOH
STX
ETX
EOT
ENQ
ACK
BEL
BS
HT
LF
VT
FF
CR
SO
SI
0
0
1
1
DLE
DC1
DC2
DC3
DC4
NAK
SYN
ETB
CAN
EAA
SUB
ESC
FS
GS
RS
US
0
1
0
2
SP
1
#
\$
\%
\&
(
)
•
+
-
/
0
3
0
1
2
3
4
5
6
7
8
9
<
-
>
?
1
0
0
4
m
A
B
C
D
E
F
G
H
1
J
K
L
M
N
0
1
0
1
5
P
Q
R
S
T
U
V
W
X
Y
Z
[
V
]
A
_
1
1
0
6
a
b
c
d
e
f
9
h
•
i
k
1
m
n
0
1
1
1
7
P
q
r
s
t
u
V
w
X
y
z
{
1
}
<^
DEL
Fig. 1-6: ASCII Conversion Table
In specialized situations such as telecommunications, other
codings may be used such as error-correcting codes. However they
are beyond the scope of this book.
32
BASIC CONCEPTS
We have examined the usual representations for both program
and data inside the computer. Let us now examine the possible ex
ternal representations.
EXTERNAL REPRESENTATION OF INFORMATION
The external representation refers to the way information is pre
sented to the user, i.e. generally to the programmer. Information
may be presented externally in essentially three formats: binary,
octal or hexdecimal, and symbolic.
1. Binary
It has been seen that information is stored internally in bytes,
which are sequences of eight bits (O's or l's). It is sometimes
desirable to display this internal information directly in its binary
format and this is called binary representation. One simple exam
ple is provided by Light Emitting Diodes (LEDs) which are essen
tially miniature lights, on the front panel of the microcomputer. In
the case of an eight-bit microprocessor, a front panel will typically
be equipped with eight LEDs to display the contents of any inter
nal register. (A register is used to hold eight bits of information
and will be described in Chapter 2). A lighted LED indicates a one.
A zero is indicated by an LED which is not lighted. Such a binary
representation may be used for the fine debugging of a complex
program, especially if it involves input/output, but is naturally
impractical at the human level. This is because in most cases, one
likes to look at information in symbolic form. Thus "9" is much
easier to understand or remember than "1001". More convenient
representations have been devised, which improve the personmachine
interface.
2. Octal and Hexadecimal
"Octal" and "hexadecimal" encode respectively three and four
binary bits into a unique symbol. In the octal system, any
combination of three binary bits is represented by a number be
tween 0 and 7.
"Octal" is a format using three bits, where each combination of
three bits is represented by a symbol between 0 and 7:
33
PROGRAMMING THE 6502
binary
000
001
010
Oil
100
101
110
111
octal
0
1
2
3
4
5
6
7
Fig. 1-7: Octal Symbols
For example, "00 100
Y T
0 4
or "044" in octal.
Another example: 11
Y
3
or "377" in octal.
100" binary is represented by:
Y
4
111
Y
. 7
111 is:
Y
7
Conversely, the octal "211" represents:
010 001 001
or "10001001" binary.
Octal has traditionally been used on older computers which were
employing various numbers of bits ranging from 8 to perhaps 64.
More recently, with the dominance of eight-bit microprocessors,
the eight-bit format has become the standard, and another more
practical representation is used. This is hexadecimal
In the hex decimal representation, a group of four bits is en
coded as one hexadecimal digit. Hexadecimal digits are
represented by the symbols from 0 to 9, and by the letters A, B, C,
D, E, F. For example, "0000" is represented by "0", "0001" is
represented by "1" and "1111" is represented by the letter "F"
(see Fig. 1-8).
34
BASIC CONCEPTS
DECIMAL
0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
BINARY
0000
0001
0010
0011
0100
0101
0110
0111
1000
1001
1010
1011
1100
1101
1110
1111
HEX
0
1
2
3
4
5
6
7
8
9
A
B
C
D
E
F
OCTAL
0
1
2
3
4
5
6
7
10
11
12
13
14
15
16
17
Fig. 1-8: Hexadecimal Codes
35
PROGRAMMING THE 6502
Example: 1010 0001 in binary is represented by
A 1 in hexadecimal.
Exercise 1.25: What is the hexadecimal representation of
"10101010?"
Exercise 1.26: Conversely, what is the binary equivalent of "FA "
hexadecimal?
Exercise 1.27: What is the octal of "01000001"?
Hexadecimal offers the advantage of encoding eight bits into on
ly two digits. This is easier to visualize or memorize an# faster to
type into a computer than its binary equivalent. Therefore, on
most new microcomputers, hexadecimal is the preferred method of
representation for groups of bits.
Naturally, whenever the information present in the memory has
a meaning, such as representing text or numbers, hexadecimal is
not convenient for representing the meaning of this information
when it is brought out for use by humans.
Symbolic Representation
Symbolic representation refers to the external representation of
information in actual symbolic form. For example, decimal num
bers are represented as decimal numbers, and not as sequences of
hexadecimal symbols or bits. Similarly, text is represented as
such. Naturally, symbolic representation is most practical to the
user. It is used whenever an appropriate display device is
available, such as a CRT display or a printer. (A CRT display is a
television-type screen used to display text or graphics.) Unfortu
nately, in smaller systems such as one-board microcomputers, it is
uneconomical to provide such displays, and the user is restricted
to hexadecimal communication with the computer.
Summary of External Representations
Symbolic representation of information is the most desirable
since it is the most natural for a human user. However, it requires
an expensive interface in the form of an alphanumeric keyboard,
plus a printer or a CRT display. For this reason, it may not be
36
BASIC CONCEPTS
available on the less expensive systems. An alternative type of rep
resentation is then used, and in this case hexadecimal is the domi
nant representation. Only in rare cases relating to fine de-bugging
at the hardware or the software level is the binary representation
used. Binary directly displays the contents of registers of memory
in binary format.
(The utility of a direct binary display on a front panel has always
been the subject of a heated emotional controversy, which will not
be debated here.)
We have seen how to represent information internally and exter
nally. We will now examine the actual microprocessor which will
manipulate this information.
Additional Exercises
Exercise 1,28: What is the advantage of two's complement over other
representations used to represent signed numbers?
Exercise 1.29: How would you represent "1024" in direct binary? Signed
binary? Two's complement?
Exercise 1.30: What is the V-bit? Should the programmer test it after an
addition or subtraction ?
Exercise 1.31: Compute the two's complement of "+16", "+17",
"+18", "-16", "-17", "-18".
Exercise 1.32: Show the hexadecimal representation of the following
text, which has been stored internally in ASCIIformat, with no parity:
= "MESSAGE".
37
6502 HARDWARE ORGANIZATION
INTRODUCTION
In order to program at an elementary level, it is not necessary
to understand in detail the internal structure of the processor
that one is using. However, in order to do efficient programming,
such an understanding is required. The purpose of this chapter is
to present the basic hardware concepts necessary for understan
ding the operation of the 6502 system. The complete microcompu
ter system includes not only the microprocessor unit (here the
6502), but also other components. This chapter presents the 6502
proper, while the other devices (mainly input/output) will be pre
sented in a separate chapter (Chapter 7).
We will review here the basic architecture of the microcomputer
system, then study more closely the internal organization of the
6502. We will examine, in particular, the various registers. We will
then study the program execution and sequencing mechansim.
From a hardware standpoint, this chapter is only a simplified
presentation. The reader interested in gaining detailed understanding
is referred to our book ref. C201 ("Microprocessors," by the same
author).
SYSTEM ARCHITECTURE
The architecture of the microcomputer system appears in Figure
2-1. The microprocessor unit (MPU), which will be a 6502 here,
appears on the left of the illustration. It implements the functions
38
6502 HARDWARE ORGANIZATION
of a central processing unit (CPU) within one chip: it in
cludes an arithmetic-logical-unit (ALU), plus its internal registers,
and a control-unit (CU) in charge of sequencing the system.
Its operation will be explained in this chapter.
8-BIT DATA BUS
ir
ROM
(PRO
GRAM)
RAM
(DATA)
16-BIT ADDRESS BUS
CONTROL LINES
Fig. 2-1: Architecture of a Standard Microprocessor System
The MPU creates three buses: an 8-bit bi-directional data-bus,
which appears at the top of the illustration, a 16-bit monodirectional
address-bus and a control-bus which appears at the
bottom of the illustration. Let us describe the function of each of
the buses.
The data-bus carries data being exchanged by the various
elements of the system. Typically, it will carry data from the
memory to the MPU, from the MPU to the memory, or from
the MPU to an input/ouput chip. (An input/output chip is a com
ponent in charge of communicating with an external device.)
The address-bus carries an address generated by the MPU,
which will select one internal register within one of the chips
attached to the system. This address specifies the source, or the
destination, of the data which will transit along the data-bus.
The control-bus carries the various synchronization signals re
quired by the system.
39
PROGRAMMING THE 6502
Having described the purpose of the busses, let us now connect the ad
ditional components required by a complete system.
Every MPU requires a precise timing reference, which is supplied by a
clock and a crystal. In most * 'older' ' microprocessors, the clock-oscilla
tor is external to the MPU and requires an extra chip. In most recent mi
croprocessors, the clock oscillator is usually incorporated within the
MPU. The quartz crystal, however, because of its bulk is always external
to the system. The crystal and the clock appear on the left of the MPU
box in the illustration.
Let us now turn our attention to the other elements of the system. Go
ing from left to right on the illustration, we distinguish:
The ROM is the read-only-memory and contains the program for the
system. The advantage of the ROM is that its contents are permanent
and do not disappear whenever the system is turned off. The ROM,
therefore, always contains a bootstrap or a monitor program (their func
tion will be explained later) to permit initial system operation. In a pro
cess-control environment, nearly all the programs will reside in ROM as
they will probably never be changed. In such case, the industrial user has
to protect the system against power failures: programs may not be vola
tile. They must be in ROM.
However, in a hobbyist environment, or in a program-development
environment (when the programmer tests the program), most of the pro
grams will reside in RAM so that they can easily be changed. Later, they
may remain in RAM, or be transferred into ROM, if desired. RAM,
however, is volatile. Its contents are lost when power is turned off.
The RAM (random-access-memory) is the read/write memory for the
system. In the case of a control system, the amount of RAM will typi
cally be small (for data only). On the other hand, in a program-develop
ment environment, the amount of RAM will be large, as it will contain
programs plus development software. All RAM contents must be loaded
prior to use from an external device.
Finally, the system will contain one or more interface chips so that it
may communicate with the external world. The most frequently used in
terface chip is the "PIO" or parallel-input-output chip. It is the one
shown in the illustration. This PIO, like all other chips in the system,
connects to all three busses and provides at least two 16-bit ports for
communication with the outside world. For more details on how an ac
tual PIO works, refer to book C201 or else, for specifics of the 6502 sys
tem, refer to Chapter 7 (Input/Output devices).
40
6502 HARDWARE ORGANIZATION
All these chips are connected to all three busses, including the
control bus. However, to clarify the illustration, the connections be
tween the control bus and these various chips are not shown on the
diagram.
The functional modules which have been described need not
necessarily reside on a single LSI chip. In fact, we will use combina
tion chips which include both a PIO and a limited amount of ROM
or RAM. For more details refer to Chapter 7.
Still more components will be required to build a real system. In
particular, the busses usually need to be buffered Also decoding
logic may be used for the memory RAM chips, and finally some
signals may need to be amplified by drivers. These auxiliary circuits
will not be described here as they are not relevant to programming.
The reader interested in specific assembly and interfacing tech
niques is referred to book C207 ''Microprocessor Interfacing Tech
niques. "
INTERNAL ORGANIZATION OF THE 6502
A simplified diagram of the internal organization of the 6502 ap
pears in Figure 2-2.
The arithmetic logical unit (ALU) appears on the right of the il
lustration. It can easily be recognized by its characteristic "V"
shape. The function of the ALU is to perform arithmetic and logical
operations on the data which is fed to it via its two input ports. The
two input ports of the ALU are respectively the "left input" and the
"right input." They correspond to the top extremities of the "V"
shape. After performing an arithmetic operation such as an addition
or subtraction, the ALU outputs its contents at the bottom of the il
lustration.
The ALU is equipped with a special register, the accumulator (A).
The accumulator is on the left input. The ALU will automatically
reference this accumulator as one of the inputs. (However, a bypass
also exists.) This is a classic accumulator-based design. In
arithmetic and logical operations, one of the operands will be the ac
cumulator, and the other will typically be a memory location.
The result will be deposited in the accumulator. Referencing the ac
cumulator as both the source and the destination for data is the
reason for its name: it accumulates results. The advantage of this
accumulator-based approach is the possibility of using very short
instructions-just a single byte (8 bits) to specify the "opcode" i.e.
41
PROGRAMMING THE 6502
P = PROCESSOR
STATUS
MUX = MULTIPLEXER
ALU = ARITHMETICLOGIC
UNIT
Fig. 2-2: Internal Organization of the 65O2
the nature of the operation performed. If the operand had to be
fetched from one of the other registers (other than an accumulator),
it would be necessary to use a number of extra bits to designate this
register within the instruction. The accumulator architecture there
fore, results in improved execution speed. The disadvantage is that
the accumulator must always be loaded with the desired data prior
to its use. This may result in some inefficiency.
Let us go back to the illustration. By the side of the ALU, to its
left, appears a special 8-bit register, the processor status-flags (P).
This register contains 8 status bits. Each of these bits, physically
implemented by a flip-flop inside the register is used to denote a
special condition. The function of the various status bits will be ex
plained progressively during the programming examples presented
in the next chapter, and will be described completely in Chapter
4, which presents the complete instruction set. As an example,
three such status flags are the N, Z, and C bits.
42
6502 HARDWARE ORGANIZATION
N stands for "negative." It is bit 7 (i.e., the left-most) of regis
ter P. Whenever this bit is one it indicates that the result of the
operation through the ALU is negative.
Bit Z stands for zero. Whenever this bit (bit position 1) is a one,
it denotes that a zero result was obtained.
Bit C, in the right-most position (position 0), is a carry bit.
Whenever two 8-bit numbers are added and the result cannot be
contained in 8 bits, bit C is the ninth bit of the result. The carry is
used extensively during arithmetic operations.
These status bits are automatically set by the various instruc
tions. A complete list of the instructions and the way in which
they affect the status bits of the system appears in Appendix A, as
well as in Chapter 4. These bits will be used by the programmer to
test various special or exceptional conditions, or else to test
quickly for some erroneous result. As an example, testing bit Z
may be accomplished with special instructions and will im
mediately tell whether the result of a previous operation was 0
or not. All decisions in an assembly language program, i.e. in all
the programs that will be developed in this book, will be based on
the testing of bits. These bits will be either bits that will be read
from the outside world, or else the status bits of the ALU. It is
therefore very important to understand the function and use of all
status bits in the system. The ALU here is equipped with a status
register containing these bits. All other input/output chips in the
system will also be equipped with status bits. These will be
studied in Chapter 7.
Let us now move leftwards of the ALU on illustration 2-2. The
horizontal rectangles represent the internal registers of the 6502.
PC is the program counter. It is a 16-bit register and is physi
cally implemented as two 8-bit registers: PCL and PCH. PCL
stands for the low half of the program counter, i.e., bits 0 through
7. PCH stands for the high part of the program counter, i.e., bits 8
through 15. The program counter is a 16-bit register which con
tains the address of the next instruction to be executed. Every
computer is equipped with a program counter so that it knows
which instruction to execute next. Let us review briefly the mem
ory access mechanism in order to illustrate the role of the pro
gram counter.
43
PROGRAMMING THE 6502
ROM
PC:
Fig. 2-3: Fetching an Instruction from the Memory
THE INSTRUCTION EXECUTION CYCLE
Let us refer now to Figure 2-3. The microprocessor unit appears
on the left, and the memory appears on the right. The memory
chip may be a ROM or a RAM, or any other chip which happens to
contain memory. The memory is used to store instructions and
data. Here, we will fetch one instruction from the memory to
illustrate the role of the program counter. We assume that the
program counter has valid contents. It now holds a 16-bit address
which is the address of the next instruction to fetch in the mem
ory. Every processor proceeds in three cycles:
1 — Fetch the next instruction
2 — Decode the instruction
3 — Execute the instruction
Fetch
Let us now follow the sequence. In the first cycle, the contents of
the program counter are deposited on the address bus and gated
to the memory (on the address bus). Simultaneously, a read signal
may be issued on the control bus of the system, if required. The
memory will receive the address. This address is used to specify
one location within the memory. Upon receiving the read signal,
44
6502 HARDWARE ORGANIZATION
the memory will decode the address it has received, through
internal decoders, and will select the location specified by the
address. A few hundred nanoseconds later, the memory will de
posit the 8-bit data corresponding to the specified address on its
data-bus. This 8-bit word is the instruction that we want to fetch.
In our illustration, this instruction will be deposited on top of the
data bus.
Let us briefly summarize the sequencing. The contents of the
program counter are output on the address bus. A read signal is
generated. The memory cycles. Perhaps 300 nanoseconds later,
the instruction at the specified address is deposited on the databus.
The microprocessor then reads the data-bus and deposits its
contents into a specialized internal register, the IR register. The
IR register is the instruction-register. It is 8 bits wide and is used
to contain the instruction just fetched from the memory. The fetch
cycle is now completed. The 8 bits of the instruction are now physi
cally in the special internal register of the 6502, the IR register.
This IR register appears on the left of Figure 2-4.
Decoding and Execution
Once the instruction is contained in IR, the control-unit of the
microprocessor will decode the contents and will be able to gen
erate the correct sequence of internal and external signals for the
execution of the specified instruction. There is, therefore, a short
decoding delay followed by an execution phase, the length of
which depends on the nature of the instruction specified. Some
instructions will execute entirely within the MPU. Other instruc
tions will fetch or deposit data from or into the memory. This is
why the various instructions of the 6502 require various lengths
of time to execute. This duration is expressed as a number of
(clock) cycles. Refer to the Appendix for the number of cycles re
quired by each instruction. A typical 6502 uses one-megahertz
clock. The length of each cycle is therefore 1 microsecond. Since
various clock rates may be used with different components, speed
of execution is normally expressed in number of cycles rather
than in number of nanoseconds.
In the case of the 6502, its clock is internal, represented by the in
ternal oscillator (see Fig. 2-1).
45
PROGRAMMING THE 6502
Fetching the Next Instruction
We have now described how, using the program counter, an
instruction can be fetched from the memory. During the execution
of a program, instructions are fetched in sequence from the mem
ory. An automatic mechanism must therefore be provided to fetch
instructions in sequence. This task is performed by a simple incrementor
attached to the program counter. This is illustrated in
Figure 2-4. Every time that the contents of the program counter
(at the bottom of the illustration) are placed on the address-bus,
its contents will be incremented and written back into the pro
gram counter. As an example, if the program counter did contain
the value 0, the value 0 would be output in the address bus. Then
the contents of the program counter would be incremented and
the value 1 would be written back into the program counter. In
this way, the next time that the program counter is used, it is the
instruction at address 1 that will be fetched. We have just imple
mented an automatic mechanism for sequencing instructions.
Fig. 2-4: Automatic Sequencing
46
6502 HARDWARE ORGANIZATION
It must be stressed that the above descriptions are simplified.
In reality, some instructions may be 2- or even 3-bytes long so that
successive bytes will be fetched in this manner from the memory.
However, the mechanism is identical. The program counter is
used to fetch successive bytes of an instruction, as well as to fetch
successive instructions themselves. The program counter, to
gether with its incrementer, provides an automatic mechanism
for pointing to successive memory locations.
Other 6502 Registers
One last area on Figure 2-2 has not yet been explained. It is the
set of three registers labeled X, Y and S. Registers X and Y are
called index registers. They are 8 bits wide. They may be used to
contain data on which the program will operate. However, they
normally are used as index registers.
The role of index registers will be described in Chapter 5 on
addressing techniques. Briefly, the contents of these two index
registers may be added in several ways to any specified address
within the system to provide an automatic offset. This is an im
portant facility for retrieving data efficiently when it is stored in
tables. These two registers are not completely symmetrical, and
their roles will be differentiated in the chapter on addressing
techniques.
The stack register S is used to contain a pointer to the top of the
stack area within the memory.
Let us now introduce the formal concept of a stack.
THE STACK
A stack is formally called an LIFO structure (last-in, first-out). A
stack is a set of registers, or memory locations, allocated to this
data structure. The essential characteristic of this structure is
that it is a chronological structure. The first element introduced
into the stack is always at the bottom of the stack. The element
most recently deposited in the stack is on the top of the stack. The
analogy can be drawn to a stack of plates on a restaurant
counter. There is a hole in the counter with a spring in the bottom.
Plates are piled up in the hole. With this organization, it is
guaranteed that the plate which has been put first in the stack
(the oldest) is always at the bottom. The one that has been placed
47
PROGRAMMING THE 6502
most recently on the stack is the one which is on top of it. This
example also illustrates another characteristic of the stack. In
normal use, a stack is only accessible via two instructions: "push"
and "pop" (or "pull"). The push operation results in depositing one
element on top of the stack. The pull operation consists of remov
ing one element from the stack. In practice, in the case of a mic
roprocessor, it is the accumulator that will be deposited on top of
the stack. The pop will result in a transfer of the top element of
the stack into the accumulator. Other specialized instructions
may exist to transfer the top of the stack between other spe
cialized registers, such as the status register.
The availability of a stack is required to implement three pro
gramming facilities within the computer system: subroutines, in
terrupts, and temporary data storage. The role of the stack during
subroutines will be explained in Chapter 3 (Basic Programming
Techniques). The role of the stack during interrupts will be ex
plained in Chapter 6 (Input/Output Techniques). Finally, the role
of the stack to save data at high speed will be explained during
specific application programs.
We will simply assume at this point that the stack is a required
facility in every computer system. A stack may be implemented
in two ways:
1. A fixed number of registers may be provided within the mi
croprocessor itself. This is a "hardware stack." It has the advan
tage of high speed. However, it has the disadvantage of a limited
number of registers.
2. Most general-purpose microprocessors choose another ap
proach, the software stack, in order not to restrict the stack to
a very small number of registers. This is the approach chosen in
the 6502. In the software approach, a dedicated register within
the microprocessor, here register S, stores the stack pointer, i.e.,
the address of the top element of the stack (or more precisely, the
address of the top element of the stack plus one). The stack is then
implemented as an area of memory. The stack pointer will therefore
require 16 bits to point anywhere in the memory.
However, in the case of the 6502, the stack pointer is restricted
to 8 bits. It includes a 9th bit, in the left-most position, always set
to 1. In other words, the area allocated to the stack in the case of
the 6502 ranges from address 256 to address 511. In binary, this is
"100000000" to "111111111." The stack always starts at address
111111111 and may have up to 255 words. This may be viewed
48
6502 HARDWARE ORGANIZATION
as a limitation of the 6502 and will be discussed later in this book.
In the 6502, the stack is at the high address, and grows
"backwards"; the stack pointer is decremented by a PUSH.
In order to use the stack, the programmer will simply initialize
the S register. The rest is automatic.
The stack is said to reside in page 1 of the memory. Let us now
introduce the paging concept.
^MICROPROCESSOR
r REGISTER
7 MEMORY 0
| PUSH
81 ADDRESS"!0
SP I—
I POP_
i r
i
BASE
Fig. 2-5: The 2 Stack Manipulation Instructions
THE PAGING CONCEPT
The 6502 microprocessor is equipped with a 16-bit address-bus.
16 binary bits may be used to create up to 216 = 64K combinations
(IK equals 1,024). Because of addressing features of the 6502
which will be presented in Chapter 5, it is convenient to partition
the memory into logical pages. A page is simply a block of 256
words. Thus, memory locations 0 to 255 are page 0 of the memory.
It will be used for "page zero" addressing.Page 1 of the memory
includes memory locations 256 through 511. We have just estab
lished that page 1 is normally reserved for the stack area. All
other pages in the system are unconstrained by the design and
may be used in any way. In the case of the 6502, it is important to
keep in mind the page organization of the memory. Whenever a
page boundary has to be crossed, it will often introduce an extra
cycle delay in the execution of an instruction.
PROGRAMMING THE 6502
15
ADDRESS
8 7
PAGE*
0
LOCATION
0
255
256
511
512
LOCATION 1
WITHIN
PAGE Jf
MEMORY
PAGEO
PAGE1
WORD
Fig. 2-6: The Paging Concept
THE 6502 CHIP
To complete our description of the diagram, the data bus at the up
per part of Figure 2-2 represents the external data bus. It will be used to
communicate with the external devices, and the memory in particular.
AO-7 and A8-15 represent respectively the low-order and the high-order
part of the address-bus created by the 6502.
For completeness, we present here the actual pin-out of the
6502 microprocessor. You need not read it to understand the rest
of this book. However, if you intend to connect devices to a system,
this description will be valuable.
The actual pin-out of the 6502 appears in Figure 2-7. The data
bus is labeled DB0-7 and is easily recognizable on the right of the
illustration. The address bus is labeled A0-11 and A12-15. It comes
50
6502 HARDWARE ORGANIZATION
[Power Ground)
(Ready)
(Clock)
(Interrupt Request)
(Non-Maskable
Interrupt)
(Synchronize)
(Power: +5V)
(Memory Bus ^uy
Lines 0 to 11)
vss
RDY •»
01 —
IRQ ■»
—
RMI »-
SYNC •■
VCC
■<=
i
2
3
4
5
6
7
8
9-20
40
39
38
37
36
35
34
26-33
22-25
21
- RES
r-
-*— 00
-
^ R/W
^ *^-
— VSS
(Reset)
(Clock)
(Clock)
(Read/Write)
DB0-7 (Data Bus)
(Memory Bus
A12-'5 Lines 12 to 15)
(Power Ground)
Flg.2-7:65O2Pinout
from pins 9 to 20 on the left of the chip, and pins 22 to 25 on its
right.
The rest of the signals are power and control signals.
The control signals
—R/W: the READ/WRITE line controls the direction of data
transfers on the data-bus.
—IRQ and NMI are "Interrupt Request" and "Non-Maskable
Interrupt". They are two interrupt lines and will be used in
Chapter 7.
—SYNC is a signal which indicates an opcode fetch to the exter
nal world.
—RDY is normally used to synchronize with a slow memory: it
will stop the processor.
—SO sets the overflow flag. It is normally not used.
—0o, 0i and 02 are clock signals.
—RES is RESET, used to initialize.
—Vgg and Vcc are for power (5V).
51
PROGRAMMING THE 6502
HARDWARE SUMMARY
This completes our hardware description of the internal organi
zation of the 6502. The exact internal bussing structure of the
6502 is not important at this point. However, the exact role of
each of the registers is important and should be fully understood
before the reader proceeds. If you are familiar with the concepts
that have been presented, read on. If you do not feel sure about
some of them, it is suggested that you read again the relevant
sections of this chapter, as they will be needed in the next chap
ters. It is suggested that you look again at Figure 2-2 and make
sure that you understand the function of every register in the
illustration.
52
3
BASIC PROGRAMMING
TECHNIQUES
INTRODUCTION
The purpose of this chapter is to present all the basic tech
niques necessary to write a program using the 6502. This chapter
will introduce additional concepts such as register management,
loops, and subroutines. It will focus on programming techniques
using only the internal 6502 resources, i.e., the registers. Actual
programs will be developed such as arithmetic programs. These
programs will serve to illustrate the various concepts presented
so far and will use actual instructions. Thus, it will be seen how
instructions may be used to manipulate the information between
the memory and the MPU, as well as manipulate information
within the MPU itself. The next chapter will then discuss in com
plete detail the instructions available on the 6502. Chapter 6 will
present the techniques available to manipulate information out
side the 6502: the input/output techniques.
In this chapter, we will essentially learn by "doing." By examining
programs of increasing complexity, we will learn the role of the
various instructions and of the registers and will apply the concepts
developed so far. However, one important concept will not be
presented here; it is the concept of addressing techniques. Because of
its apparent complexity, it will be presented separately in chapter 5.
Let us immediately start writing some programs for the 6502.
We will start with arithmetic programs.
53
PROGRAMMING THE 6502
ARITHMETIC PROGRAMS
Arithmetic programs cover addition, subtraction, multiplication,
and divisioa The programs that will be presented here will operate on
integers. These integers may be positive binary integers or may be ex
pressed in two's complement notation, in which case the left-most bit
is the sign bit (See Chapter 1 for a reminder of the two's complement
notation.)
8-Bit Addition
We will add two 8-bit operands called OP1 and OP2, re
spectively stored at memory address ADR1 and ADR2. The sum
will be called RES and will be stored at memory address ADR3.
This is illustrated in Figure 3-1. The program which will perform
this addition is the following:
LDA
ADC
STA
ADRl
ADR2
ADR3
ADRl
ADR2
ADR3
ADDRESSES
LOAD OP1 IN A
ADD OP2 TO OP1
SAVE RES AT ADR3
MEMORY
OP1
OP2
RES
(FIRST OPERAND)
(SECOND OPERAND)
(RESULT)
Fig. 3-1:8-Bit Addition Res=OPl + OP2
54
BASIC PROGRAMMING TECHNIQUES
This is a three-instruction program. Each line is one instruc
tion, in symbolic form. Each such instruction will be translated by
the assembler program into 1, 2, or 3 binary bytes. We will not
concern ourselves with the translation here and only look at the
symbolic representation. The first line specifies an LDA instruc
tion. LDA means "load the accumulator A from the address which
follows."
The address specified on the first line is ADR1. ADR1 is a sym
bolic representation for an actual 16-bit address. Somewhere else
in the program, the ADR1 symbol will be defined. It could be, for
example, address 100.
The instruction LDA specifies "load accumulator A" (inside the
6502) from memory location 100. This will result in a read opera
tion from address 100, the contents of which will be transmitted
along the data-bus and deposited inside the accumulator. You
will recall that arithmetic and logical operations operate on the ac
cumulator as one of the source operands. (Refer to the previous
chapter for more details.) Since we wish to add the two values
OP1 and OP2 together, we first load OP1 into the accumulator.
Then we will be able to add the contents of the accumulator (OP1)
to OP2.
The right-most field of this instruction is called a comment field.
It is ignored by the processor, but it is provided for program
readability. In order to understand what the program does, it is of
paramount importance to use good comments.
This is called documenting a program. Here the comment is self
explanatory: the value of OP1, which is located at address ADR1,
is being loaded in accumulator A.
The result of this first instruction is illustrated by Figure 3-2.
(—OP1)
(ADR1)
Fig. 3-2: LDA ADR1: OP1 is Loaded from Memory
55
PROGRAMMING THE 6502
The second instruction of our program is:
ADC ADR2
It specifies "add the contents of memory location ADR2 to the
accumulator." Referring to Figure 3-1, the contents of memory
location ADR2 are OP2, our second operand. The actual contents of
the accumulator now OP1, our first operand. As a result of the
execution of the second instruction, OP2 will be fetched from the
memory and added to OP1. The sum will be deposited in the
accumulator. The reader will remember that the results of an
arithmetical operation, in the case of the 6502, are deposited back
into the accumulator. In other microprocessors, it may be possible
to deposit these results in other registers or back into the memory.
The sum of OP1 and OP2 is now in the accumulator. We have
just to transfer the contents of the accumulator into memory loca
tion ADR3 in order to store the results at the specified location.
Again, the right-most field of the second instruction is simply a
comment field which explains the role of the instruction (add OP2
to A).'
Fig.3-3:ADCADR2
The effect of the second instruction is illustrated by Figure 3-3.
It can be verified in Figure 3-3 that, initially the accumulator
contained OP1. After the addition, a new result has been written
into the accumulator. It is OP1 + OP2. The contents of any regis
ter within the system, as well as any memory location, remain the
same when a read operation is performed. In other words, reading
the contents of a register or a memory location does not change its
contents. It is only, and exclusively, a write operation that will
56
BASIC PROGRAMMING TECHNIQUES
change the contents of a register. In this example, the contents of
memory locations ADR1 and ADR2 are unchanged. However,
after the second instruction of this program, the contents of the
accumulator have been modified because the output of the ALU
has been written into the accumulator. Its previous contents are
then lost.
Let us now save this result at address ADR3 and we will have
completed our simple addition.
The third instruction specifies: STA ADR3. This means "Store
the contents of accumulator A at the address ADR3." This is selfexplanatory
and is illustrated in Figure 3-4.
6502
DATA BUS ^
ADR3:
(ADR3) K
ADDRESS BUS K
/MEMORY
Fig. 3-4: STA ADR3 (Save Accumulator in Memory)
6502 Peculiarities
The above three-instruction program would indeed by the com
plete program for most microprocessors. However, two
peculiarities of the 6502 exist, which will normally require two
additional instructions.
First, the ADC instruction really means "add with carry'9
rather than "add." The difference is that a regular add instruction
adds two numbers together. An add-with-carry adds two numbers
together plus the value of the carry bit. Since we are adding here
8-bit numbers, no carry should be used, and at the time we start
the addition we do not necessarily know the condition of the carry
bit (it may have been set by a previous instruction), so we must clear
it, i.e., set it to zero. This will be accomplished by the CLC instruc
tion: *'clear carry."
57
PROGRAMMING THE 6502
Unfortunately, the 6502 does not have both types of addition
operations. It has only an ADC operation. As a result, for single
8-bit additions, a necessary precaution is to always clear the carry
bit. This is no significant disadvantage but should not be forgot
ten.
The second peculiarity of the 6502 lies with the fact that it is
equipped with powerful decimal instructions, which will be used
in the next section on BCD arithmetic. The 6502 always operates
in one of two modes: binary or decimal. The state it is in is con
ditioned by a status bit, the WD" bit (of register P). Since we are
operating in binary mode in this example, it is necessary to make
sure that the D bit is correctly set. This will be done by a CLD
instruction, which will clear the D bit. Naturally, if all arithmetic
within the system is done in binary, the D bit will be cleared once
and for all at the beginning of the program, and it will not be
necessary to set it every time. Therefore, this instruction may, in
fact, be omitted in most programs. However, the reader, who will
practice these exercises on a computer, may go back and forth
between BCD and binary exercises, and this extra instruction has
been included here as it must appear at least once before any
binary addition is performed.
To summarize: our complete, and safe, 8-bit program is now:
CLC
CLD
LDA
ADC
STA
ADR1
ADR2
ADR3
CLEAR CARRY BIT
CLEAR DECIMAL BIT
LOAD OP1 IN A
ADD OP2 TO OP1
SAVE RES AT ADR3
Actual physical addresses may be used instead of ADR1, ADR2,
and ADR3. If one wishes to keep symbolic addresses, it will be
necessary to use so-called "pseudo-instructions" which specify the
value of these symbolic addresses so that the assembly program
may, during translation, substitute the actual physical addresses.
Such pseudo-instructions would be, for example:
ADR1 = \$100
ADR2 = \$120
ADR3 = \$200
Exercise 3.1: Now close this book. Refer only to the list of instruc
tions at the end of the book. Write a program which will add two
58
BASIC PROGRAMMING TECHNIQUES
numbers stored at memory locations LOCI and LOC2. Deposit the
results at memory location LOC3. Then, compare your program to
the one above.
16-Bit Addition
An 8-bit addition will only allow the addition of 8-bit numbers, i.e.,
numbers between 0 and 255, if absolute binary is used. For most prac
tical applications it is necessary to use multiplepreoision and to add
numbers having 16 bits or more. We will present here examples of
arithmetic on 16-bit numbers. They can be readily extended to 24,
32 bits,or more. (One always uses multiples of 8 bits.) We will assume
that the first operand is stored at memory locations ADR1 and
ADR1 -1. Since OP1 is a 16-bit number this time, it will require two
8-bit memory locations. Similarly, OP2 will be stored at ADR2 and
ADR2-1. The result is to be deposited at memory addresses ADR3
and ADR3 -1. This is illustrated in Figure 3-5.
ADR1-1
ADR1
ADR2-1
ADR2
ADR3-1
ADR3
MEMORY
(OPl)H
(OP1)L
(OPR2)H
(OPR2)L
(RES)H
(RES)L
Fig. 3-5:16 Bit Addition: The Operands
59
CLC
CLD
LDA
ADC
STA
LDA
ADC
STA
ADR1
ADR2
ADR3
ADR1-1
ADR2-1
ADR3-1
PROGRAMMING THE 6502
The logic of this program is exactly analogous to the previous
one. First, the lower half of the two operands will be added, since
the microprocessor can only add on 8 bits at a time. Any carry
generated by the addition of these low order bytes will be au
tomatically stored in the internal carry bit ("C"). Then, the high
order half of the two operands will be added together along with
any carry, and the result will be saved in the memory. The pro
gram appears below:
LOW HALF OF OP1
(OP1 + OP2) LOW
SAVE LOW HALF OF RES
HIGH HALF OF OP1
(OP1 + OP2) HIGH + CARRY
SAVE HIGH HALF OF RES
The first two instructions of this program are used to be safe: CLC,
CLD. Their roles have been explained in the previous section. Let us
examine the program. The next three instructions are essentially iden
tical to the ones for the 8-bit addition. They result in adding the least
significant half (bits 0 through 7) of OP1 and OP2. The sum, called
RES, is stored at memory location ADR3.
Automatically, whenever an addition is performed, any result
ing carry is saved in the carry bit of the flags register (register P).
If the two 8-bit numbers do not generate any carry, the value of
the carry bit will be zero. If the two numbers do generate a carry,
then the C bit will be equal to 1.
The next three instructions of the program are also essentially
identical to the previous 8-bit addition program. They add to
gether the most significant half (bits 8 through 15) of OP1 and
OP2, plus any carry, and store the results at address ADR3-1.
After this program has been executed, the 16-bit result is stored
at memory locations ADR3 and ADR3-1.
It is assumed here that no carry will result from this 16-bit
addition. It is assumed that the result is, indeed, a 16-bit number.
If the programmer suspects for any reason that the result might
have 17 bits, then additional instructions should be inserted that
would test the carry bit after this addition.
60
BASIC PROGRAMMING TECHNIQUES
The location of the operands in the memory is illustrated in Fig
ure 3-5.
Note that we have assumed here that the high part of the operand
is stored "on top of the lower part, i.e., at the lower memory ad
dress. This need not necessarily be the case. In fact, addresses
are stored by the 6502 in the reverse manner: the low part is first
saved in the memory and the high part is saved in the next
memory location. In order to use a common convention for both
addresses and data, it is recommended that data also be kept with
the low part on top of the high part. This is illustrated in Figure
3-6A.
EMORY
ADR1
ADR1 ♦ 1
ADR2
ADR2 + 1
ADR3
ADR3+1
(O 1)1
(OPRI)H
(0PR2)L
|OPR2)H
(RES)l
Fig. 3-6A: Storing Operands in Reverse Order
Exercise 3.2: Rewrite the 16-bit addition program above with the mem
ory layout indicated in Figure 3-6A.
Exercise 3.3: Assume now that ADR1 does notpoint to the lower halfof
OPR1 (see Figure 3-6A), but points to the higher part ofOPRl. This is
illustrated in Figure 3-6B. Again, write the corresponding program.
61
PROGRAMMING THE 6502
ADR1-I
ADR1
ADR2-1
ADR2
ADR3 1
ADR3
MEMORY
lOPRI)L
(OPRI)H
(OPR2)l
(OPR2)H
(RES)L
(RES)H
Fig. 3-6B: Pointing to the High Byte
It is the programmer, i.e., you, who must decide how to store 16-bit
numbers (low part or high part first) and also whether your address
references point to the lower or to the higher half of such numbers.
This is the first of many choices which you will learn to make when
designing algorithms or data structures.
We have now learned to perform a binary addition. Let us turn
to the subtraction.
Subtracting 16-Bit Numbers
Doing an 8-bit subtract would be too simple. Let us keep it as an ex
ercise and directly perform a 16-bit subtract. As usual, our two
numbers, OPR1 and OPR2, are stored at addresses ADR1 and ADR2.
The memory layout will be assumed to be that of Figure 3-6A. In order
to subtract, we will use a subtact operation (SBC) instead of an add
operation (ADC). The only other change, when comparing it to the
addition, is that we will use an SEC instruction at the beginning of the
62
CLD
SEC
LDA
SBC
STA
LDA
SBC
ADR1
ADR2
ADR3
ADR1 + 1
ADR2 + 1
BASIC PROGRAMMING TECHNIQUES
program instead of a CLC. SEC means "set carry to 1." This in
dicates a "no-borrow" condition. The rest of the program is identical
to the one for addition. The program appears below:
SET CARRY TO 1
(OPR1) L INTO A
(OPR1) L -(OPR2)L
STORE (RESULT)L
(OPR1) H INTO A
(OPR1) H -(0PR2)H
STA ADR3 + 1 STORE (RESULT)H
Exercise 3.4: Write the subtraction program for 8-bit operands.
It must be remembered that in the case of two's complement
arithmetic, the final value of the carry flag has no meaning. If an
overflow condition has occurred as a result of the subtraction,
then the overflow bit (bit V) of the flags register will have been
set. It can then be tested.
The examples just presented are simple binary additions. How
ever, another type of addition may be necessary; it is the BCD
addition.
BCD Arithmetic
8-Bit BCD Addition
The concept of BCD arithmetic has been presented in Chapter 1.
It is used essentially for business applications where it is impera
tive to retain every significant digit in a result. In the BCD nota
tion, a 4-bit nibble is used to store one decimal digit (0 through 9).
As a result, every 8-bit byte may store two BCD digits. (This is
called packed BCD.) Let us now add two bytes containing two
BCD digits each.
In order to identify the problems, let us try some numeric
examples first.
Let us add "01" and "02":
"01" is represented by 0000 0001.
63
PROGRAMMING THE 6502
"02" is represented by 0000 0010.
The result is 0000 0011.
This is the BCD representation for "03". (If you feel unsure of the
BCD equivalent, refer to the conversion table at the end of the
book.) Everything worked very simply in this case. Let us now try
another example.
"08" is represented by 0000 1000.
"03" is represented by 0000 0011.
Exercise 3.5: Compute the sum of the two numbers above in the
BCD representation. What do you obtain? (answer follows)
If you obtain 0000 1011, you have computed the binary sum of
"8" and "3". You have indeed obtained "11" in binary. Unfortu
nately, "1011" is an illegal code in BCD. You should obtain the
BCD representation of "11", i.e., "0001 0001"!
The problem stems from the fact that the BCD representation
uses only the first ten combinations of 4 digits in order to encode
the decimal symbols "0" through "9". The remaining six possible
combinations of 4 digits are unused, and illegal "1011" is one such
combination. In other words, whenever the sum of two binary
digits is greater than "9", then one must add "6" to the result in
order to skip over the unused 6 codes. Add the binary representa
tion for "6" to "1011":
1011 (illegal binary result)
+ 0110 (+6)
The result is: 0001 0001.
This is, indeed, "11" in the BCD notation! We now have the
correct result.
This example illustrates one of the basic difficulties of the BCD
mode. One must compensate for the six missing codes. On most
microprocessors, a special instruction, called "decimal adjust,"
must be used to adjust the result of the binary addition (add 6 if
result greater than 9). In the case of the 6502, the ADC instruc
tion does it automatically. This is a clear advantage of the 6502
when doing BCD arithmetic.
The next problem is illustrated by the same example. In our
example, the carry will be generated from the lower BCD digit
64
BASIC PROGRAMMING TECHNIQUES
(the right-most one) into the left-most one. This internal carry
must be taken into account and added to the second BCD digit.
The addition instruction for the 6502 takes care of this automati
cally. However, it is often convenient to detect this internal carry
from bit 3 to bit 4 (the "half-carry"). No flag is provided in the
6502.
Finally, just as in the case of the binary addition, the usual
SED and CLC instructions must be used prior to executing the
BCD addition proper. As an example, a program to add the BCD
numbers "11" and "22" appears below:
CLC
SED
LDA
ADC
STA
#\$11
#\$22
ADR
CLEAR CARRY
SET DECIMAL MODE
LITERAL BCD "11"
LITERAL BCD "22"
In this program, we are using two new symbols: "#" and "\$".
The "#" symbol denotes that a "literal" (or constant) follows. The
"\$" sign within the operand field of the instruction specifies that
f
\
1 ».
1
2
LDA
1
I
ADC
1
(RESULT)
1
2
Fig. 3-7: Storing BCD Digits
65
PROGRAMMING THE 6502
the data which follows is expressed in hexadecimal notation. The
hexadecimal and the BCD representations for digits "0" through
"9" are identical. Here we wish to add the literals (or constants)
"11" and "22". The result is stored at the address ADR. When the
operand is specified as part of the instruction, as it is in the above
example, this is called immediate addressing. (The various ad
dressing modes will be discussed in detail in Chapter 5.) Storing
the result at a specified address, such as STA ADR, is called abso
lute addressing when ADR represents a regular 16-bit address.
Exercise 3.6: Could we move the CLC instruction in the program
below the instruction LDA ?
BCD Subtraction
BCD subtraction appears to be complex. In order to perform a
BCD subtraction, one must add the 10's complement of the num
ber, just like one adds the 2's complement of a number to perform
a binary subtract. The 10's complement is obtained by comput
ing the complement to 9, then adding 1. This typically requires
three to four operations on a standard microprocessor. However,
the 6502 is equipped with a special BCD subtraction instruction
which performs this in a single instruction! Naturally, and just as
in the binary example, the program will be preceded by the in
structions SED, which sets the decimal mode, unless it has been
previously set, and SEC, which sets the carry to 1. Thus, the pro
gram to subtract BCD "25" from BCD "26" is the following:
SED
SEC
LDA
SBC
STA
#\$26
#\$25
ADR
SET DECIMAL MODE
SET CARRY
LOAD BCD 26
MINUS BCD 25
STORE RESULT
16-Bit BCD Addition
16-bit addition is performed just as simply as in the binary
case. The program for such an addition appears below:
CLC
SED
LDA ADR1
66
BASIC PROGRAMMING TECHNIQUES
ADC
STA
LDA
ADC
STA
ADR2
ADR3
ADR1-1
ADR2-1
ADR3-1
Exercise 3.7: Compare the program above to the one for the 16-bit
binary addition. What is the difference?
Exercise 3.8: Write the subtraction program for a 16-bit BCD. (Do
not use CLC and ADC!)
BCD Flags
In BCD mode, the carry flag during an addition indicates the
fact that the result is larger than 99. This is not like the two's
complement situation, since BCD digits are represented in true
binary. Conversely, the absence of the carry flag during a subtrac
tion indicates a borrow.
Programming Hints for Add and Subtract
—Always clear the carry flag before performing an addition.
—Always set the carry flag to 1 before performing a subtrac
tion.
—Set the appropriate mode: binary or decimal.
Instruction Types
We have now used three types of microprocessor instructions.
We have used LDA and STA, which respectively load the ac
cumulator from the memory address and store its contents at the
specified address. These two instructions are data transfer in
structions.
Next, we have used arithmetic instructions, such as ADC and
SBC. They perform respectively an addition and a subtraction
operation. More ALU instructions will be introduced in this chap
ter soon.
Finally, we have used instructions such as CLC, SEC and others,
which manipulate the flag bits (respectively the carry and the de
cimal bits in our examples). They are status manipulation or con
trol instructions. A comprehensive description of the 6502 instruc-
67
PROGRAMMING THE 6502
tions will be presented in Chapter 4.
Still other types of instructions are available within the micro
processor which we have not yet used. They are in particular
the "branch" and "jump" instructions, which will modify the order
in which the program is being executed. This new type of instruc
tion will be introduced in our next example.
Multiplication
Let us now examine a more complex arithmetic problem: the
multiplication of binary numbers. In order to introduce the al
gorithm for a binary multiplication, let us start by examining a
usual decimal multiplication: We will multiply 12 by 23.
12 (Multiplicand) (MPD)
x23 (Multiplier) (MPR)
36 (Partial Product) (PP)
+ 24
=276 (Final Result) (RES)
The multiplication is performed by multiplying the right-most digit
of the multiplier by the multiplicand, i.e., "3" x "12". The partial
product is "36." Then one multiplies the next digit of the multi
plier, i.e., "2," by "12." "24" is then added to the partial pro
duct.
But there is one more operation: 24 is offset to the left by one
position. We will say that 24 is being shifted left by one position.
Equivalently, we could have said that the partial product (36) had
been shifted one position to the right before adding.
The two numbers, correctly shifted, are then added and the sum
is 276. This is simple. Let us now look at the binary multiplica
tion. The binary multiplication is performed in exactly the same
way.
Let us look at an example. We will multiply 5x3:
(5) 101 (MPD)
(3) xOll (MPR)
101 (PP)
101
000
(15) 01111 (RES)
68
BASIC PROGRAMMING TECHNIQUES
In order to perform the multiplication, we operate exactly as
we did above. The formal representation of this algorithm ap
pears in Figure 3-8. It is a flowchart for the algorithm, our first
flowchart. Let us examine it more closely.
LEFT SHIR (1)MPD
OR RIGHT SHIFT (1) RES
DONE
Fig. 3-8: The Basic Multiplication Algorithm: Flowchart
This flow-chart is a symbolic representation of the algorithm we
have just presented. Every rectangle represents an order to be
carried out. It will be translated into one or more program in
structions. Every diamond-shaped symbol represents a test being
performed. This will be a branching point in the program. If the
test succeeds, we will branch to a specified location. If the test
does not succeed, we will branch to another location. The concept
of branching will be explained later in the program itself. The
reader should now examine this flow-chart and ascertain that it
does indeed represent the algorithm exactly. Note that there is an
arrow coming out of the last diamond at the bottom of the flow
chart, back to the first diamond on top. This is because the same
portion of the flow-chart will be executed eight times, once for
69
PROGRAMMING THE 6502
every bit of the multiplier. Such a situation where execution will
restart at the same point is called a program loop, for obvious
reasons.
Exercise 3.9: Multiply "4" by "7" in binary using the flow chart,
and verify that you obtain "28? Ifyou do not, try again. It is only if
you obtain the correct result that you are ready to translate this flow
chart into a program.
Let us now translate this flow-chart into a program for the
6502. The complete program appears in Figure 3.9. We are now go
ing to study it in detail. As you will recall from Chapter 1, pro
gramming consists here of translating the flowchart of Figure
3-8 into the program of Figure 3-9. Each of the boxes in the flow
chart will be translated by one or more instructions.
It is assumed that MPR and MPD already have a value.
LDA
STA
STA
STA
LDX
MULT LSR
BCC
LDA
CLC
ADC
STA
LDA
ADC
STA
NOADD ASL
ROL
DEX
BNE
#0
TMP
RESAD
RESAD+1
#8
MPRAD
NOADD
RESAD
MPDAD
RESAD
RESAD+1
TMP
RESAD+1
MPDAD
TMP
MULT
ZERO ACCUMULATOR
CLEAR THIS ADDRESS
CLEAR
CLEAR
X IS COUNTER
SHIFT MPR RIGHT
TEST CARRY BIT
LOAD A WITH LOW RES
PREPARE TO ADD
ADD MPD TO RES
SAVE RESULT
ADD REST OF SHIFTED MPD
SHIFT MPD LEFT
SAVE BIT FROM MPD
DECREMENT COUNTER
DO IT AGAIN IF COUNTER #0
Fig. 3-9:8x8 Multiply
The first box of the flow-chart is an initialization box. It is neces
sary to set a number of registers or memory locations to "0," as
this program will require their use. The registers which will be
used by the multiplication program appear in Figure 3-10. On the
left of the illustration appears the relevant portion of the 6502
microprocessor. On the right of the illustration appears the rele-
70
BASIC PROGRAMMING TECHNIQUES
vant section of the memory. We will assume here that memory
addresses increase from the top to the bottom of the illustration.
Naturally, the reverse convention could be used. The X register on
the far left (one of the two index registers of the 6502) will be used
as a counter. Since we are doing an 8-bit multiplication, we will
have to test 8 bits of the multiplier. Unfortunately, there is no in
struction in the 6502 which allows us to test those bits in se
quence. The only bits that can conveniently be tested are the
flags in the status register. As a result of this limitation of most
microprocessors, in order to test successively all the bits of the
multiplier, it will be necessary to transfer the multiplier value
into the accumulator. Then, the contents of the accumulator will
be shifted right. A shift instruction moves every bit in the regis
ter by one position to the right or to the left. The bit which falls
off the register drops into the carry bit of the status register. The
effect of a shift operation is illustrated in Figure 3-11. There are
many variations possible depending upon the bit that comes into
the register, but these differences will be discussed in Chapter 4
(6502 instruction set).
'1
BUS
MTCAO,
(IMP)
MfOAO)|
(RESAD)
MPR
MPO
MS.IO
«S.H,
-D
Fig. 3-1O: Multiplication: The Registers
Let us go back to the successive testing of each of the 8 bits of
the multiplier. Since one can easily test the carry bit, the multi
plier will be shifted by one position 8 times. Every time its right
most bit will fall into the carry bit, where it will be tested.
The next problem to be solved is that the partial product which
is accumulated during the successive additions will require
16 bits. Multiplying two 8-bit numbers may yield a 16-bit re-
71
PROGRAMMING THE 6502
suit. This is because 28x28=216. We need to reserve 16 bits for this
result. Unfortunately, the 6502 has very few internal registers, so
that this partial product cannot be stored within the 6502 itself.
In fact, because of the limited number of registers, we are unable
to store the multiplier, the multiplicand, or the partial product
within the 6502. They will all be stored in the memory. This will
result in a slower execution than if it were possible to store them
all in internal registers. This is a limitation inherent in the 6502.
The memory area used for the multiplication appears on the right
of Figure 3-10. On top one can see the memory word allocated for
the multiplier. We will assume, for example, that it contains "3" in
binary. The address of this memory location is MPRAD. Below it,
we find a "temporary" whose address is TMP. The role of this
location will be clarified below. We will shift the multiplicand left
into this location prior to adding it to the partial product. The
multiplicand is next and will be assumed to contain the value "5"
in binary. Its address is MPDAD.
Finally, at the bottom of the memory, we find the two words
allocated for the partial product or the result. Their address is
RESAD.
SHIFT LEFT
r\
CARRY
ROTATE LEFT
r\r r\ r\
Fig. 3-ll:Shiff and Rotate
72
BASIC PROGRAMMING TECHNIQUES
These memory locations will be our "working registers/' and
the word "register" may be used interchangeably with "location"
in this context.
The arrow which appears on the top right of the illustration
coming out of MPR into bit C is a symbolic way of showing how
the multiplier will be shifted in the carry bit. Naturally, this carry
bit is physically contained within the 6502 and not within the
memory.
Let us now go back to the program of Figure 3-9. The first five
instructions are initialization instructions:
The first four instructions will clear the contents of "registers"
TMP, RESAD, and RESAD+1. Let us verify this.
LDA#0
This instruction loads the accumulator with the literal value "0."
As a result of this instruction, the accumulator will contain
* '00000000."
The contents of the accumulator will now be used to clear the
three "registers" in the memory. It must be remembered that
reading a value out of a register does not empty it. It is possible to
read as many times as necessary out of a register. Its contents are
not changed by the read operation. Let us proceed:
STA TMP
This instruction stores the contents of the accumulator in mem
ory location TMP. Refer to Figure 3-10 to understand the flow of
data in the system. The accumulator contains "00000000." The
result of this instruction will be to write all zeroes in memory
location TMP. Remember that the contents of the accumulator
remain 0 after a read operation on the accumulator. It is unchanged.
We are going to use it again.
STA RESAD
This instruction operates just like the one before and clears the
contents of address RESAD. Let us do it one more time:
STA RESAD+1
We finally clear memory location RESAD+1 which has been re
served to store the high part of the result. (The high half is bits
£-15; the low part is bits 0-7.)
Finally, in order to able to stop shifting the multiplier bits
73
PROGRAMMING THE 6502
at the right time, it is necessary to count the number of shifts that
have to be performed. Eight shifts are necessary. Register X will
be used as a counter and initialized to the value "8." Every time
that the shift will have been performed, the contents of this
counter will be decremented by 1. Whenever the value of this
counter reaches "0," the multiplication is finished. Let us ini
tialize this register to "8":
LDX#8
This instruction loads the literal "8" into register X.
Referring back to the flow chart of Figure 3-8, we must test the
least significant bit of the multiplier. It has been indicated above
that this test cannot be performed in a single instruction. Two instruc
tions must be used. First the multiplier will be shifted right, then the
bit which fell out of it will be tested. It is the carry bit. Let us perform
these operations:
LSR MPRAD
This instruction is a "Logical Shift Right" of the contents of
memory location MPRAD.
Exercise 3.10: Assuming that the multiplier in our example is
"3," which bit falls off the right end of memory location MPRAD?
(In other words, which will be the value of the carry after this
shift?)
The next instruction tests the value of the carry bit:
BCC NOADD
This instruction means "Branch if Carry Clear" (i.e. equals zero)
to the address NOADD.
This is the first time we encounter a branch instruction. All the
programs we have considered so far have been strictly sequential.
Each instruction was executed after the previous one. In order to
be able to use logical tests such as testing the carry bit, one must
be able to execute instructions anywhere in the program after the
test. The branch instruction performs just such a function. It will
test the value of the carry bit. If the carry was "0," i.e., if it was
cleared, then the program will branch to address NOADD. This
means that the next instruction executed after the BCC will be
the instruction at address NOADD if the test succeeds.
74
BASIC PROGRAMMING TECHNIQUES
Otherwise, if the test fails, no branch will occur and the in
struction following BCC NOADD will be normally executed.
One more explanation is in order about NOADD: this is a sym
bolic label It represents an actual physical address within the
memory. For the convenience of the programmer, the assembler
program allows using symbolic names instead of actual addres
ses. During the assembly process, the assembler will substitute
the real physical address instead of the symbol "NOADD." This
improves the readability of the program substantially and also
allows the programmer to insert additional instructions between
the branch point and NOADD, without having to rewrite every
thing. These merits will be studied in more detail in Chaper 10 on
the assembler.
If the test fails, the next sequential instruction in the program
is executed. We will now study both alternatives:
Alternative 1: the carry was "1!'
If the carry was 1, the test specified by BCC has failed and the next
instruction after BCC is executed.
LDA RESAD
Alternative 2: the carry was "0!'
The test succeeds, and the next instruction is the one at label
"NOADD."
Referring to Figure 3-8, the flow-chart specifies that if the carry
bit was 1, the multiplicand must be added to the partial product
(here, the RES registers). Also, a shift must be performed. The
partial product must be moved by one position to the right or else
the multiplicand must be moved by one position to the left. We
will adopt here the usual convention in performing multiplica
tions by hand, and we will move the multiplicand by one position
to the left.
The multiplicand is contained in registers TMP and MPDAD.
(To simplify, we call memory locations "registers," a usual term.)
The 16 bits of the partiarpr°duct are contained in memory ad
dresses RESAD and RESAD+1.
In order to illustrate this, let us assume that the multiplicand
was "5." The various registers appear in Figure 3-10.
We simply have to add two 16-bit numbers. This is a problem
that we have learned to solve. (If you have any doubts, refer to
the section on 16-bit addition above.) We are going to add the low-
75
PROGRAMMING THE 6502
order bytes first, and then the high-order bytes. Let us proceed:
LDA RESAD
The accumulator is loaded with the low part of RES.
CLC
Prior to any addition, the 6502 requires that the carry bit be
cleared. It is important to do so here as we know that the carry bit
had been set to 1. It must be cleared.
ADC MPDAD
The multiplicand is added to the accumulator, which contains
(RES)LOW
STA RESAD
The result of the addition is saved at the appropriate memory
location, (RES)LOW The second half of the addition is then per
formed. When checking execution of this program later by hand,
do not forget that the addition will set the carry bit. The carry will
be set to either "0" or "1" depending on the results of the addition.
Any carry that might have been generated will automatically be
carried forward into the high-order part of the result.
Let us now finish the addition:
LDA RESAD+1
ADC TMP
STA RESAD+1
These three instructions complete our 16-bit add. We have now
added the multiplicand to RES. We still have to shift it by one
position to the left in anticipation of the next addition. We could
also have considered shifting the multiplicand by one position
to the left before adding, except for the first time. This is one of many
programming options which are always open to the programmer.
Let us shift the multiplicand to the left:
NOADD ASL MPDAD
This instruction is an "Arithmetic Shift Left." It will shift by one
position to the left the contents of memory location MPDAD
which happens to contain the low part of the multiplicand. This is
not enough. We cannot afford to lose the bit which falls off the left
76
BASIC PROGRAMMING TECHNIQUES
end of the multiplicand. This bit will fall into the carry bit. It
should not be stored there permanently since it can be destroyed
by any arithmetic operation. This bit should be saved in a
"permanent" register. It should be shifted into memory location
TMP. This is precisely accomplished by the next instruction:
ROL TMP
This specifies: "Rotate Left" the contents of TMP.
One interesting observation can be made here. We just used two
different kinds of shift instructions to shift a register by one posi
tion to the left. The first one is ASL. The second one is ROL.
What is the difference?
The ASL instruction shifts the contents of the register. The
ROL instruction is a rotate instruction. It does shift the contents
of the register by one position to the left, and the bit falling off the
left end goes into the carry bit, as usual. The difference is that the
previous contents of the carry bit are forced into the right-most posi
tion. This is called a circular rotation in mathematics (a 9-bit
rotation). This is exactly what we want. As a result of the ROL,
the bit which had been shifted out of MPDAD on the left and pre
served in the carry bit C will land in the right-most position of
register TMP. It works.
We are now finished with the arithmetic portion of this pro
gram. We still have to test whether we have performed the opera
tion eight times, i.e., whether we are finished. As usual in most
microprocessors, this test will require two instructions:
DEX
This instruction decrements the contents of register X. If it con
tained 8, its contents will be 7 after execution of this instruction.
BNE MULT
This is another test-and-branch instruction. It specifies "branch if
result is not equal to 0 to location MULT." As long as our counterregister
decrements to a non-zero integer, there will be an au
tomatic branch back to label MULT. This is called the multiplica
tion loop. Referring back to the multiplication flow-chart, this correponds
to the arrow coming out of the last box. This loop will be
executed 8 times.
Exercise 3.11: What happens when X decrements to 0? What is
77
PROGRAMMING THE 6502
the next instruction to be executed?
In most cases, the program that we just developed will be a
subroutine and the final instruction in the subroutine will be
RTS. The subroutine mechanism will be explained later in this
chapter.
IMPORTANT SELF-TEST
If you wish to learn how to program, it is extremely important
that you understand such a typical program in complete detail.
We have introduced many new instructions. The algorithm is rea
sonably simple, but the program is much longer than the previous
programs that we have developed so far. // is very strongly sug
gested that you do the following exercise completely and correctly
before you proceed in this chapter. If you do it correctly, you will
have really understood the mechanism by which instructions
manipulate the contents of memory and of the microprocessor
registers and how the carry flag is being used. If you do not, it is
likely that you will experience difficulties in writing programs
yourself. Learning to program does involve actually programming.
Please pause to take a piece of paper and do the following exer
cise.
Exercise 3.12: Every time that a program is written, one should
verify it by hand, in order to ascertain that its results will be correct
We are going to do just that: the purpose of this exercise is to fill in
the table of Figure 3-12.
You can write directly on it or else make a copy of it. The
purpose is to determine the contents of every relevant register
and memory location in the system after each instruction is exe
cuted by this program, from beginning to end. You will find hori
zontally on Figure 3-12 all the register locations used by the
program: X, A, MPR, C (the carry bit flag), TMP, MPD, RESADL,
RESADH. On the left part of the illustration you must fill in the
label, if applicable, and the instruction being executed. At the
right of the illustration you must write the contents of every reg
ister after execution of that instruction. Whenever the contents
of a register are indefinite, we will use dashes. Let us start filling
78
LABEL INSTRUCTION X A MPR C TEMP MPD (RESAD)L (RESAD)H
Fig. 3-12: Form To Be Filled Out For Exercise 3-12
O
T3
TO
8
O
n
z
o
PROGRAMMING THE 6502
in this table together. You will have to fill in the remainder alone.
The first line appears below:
LABEl INSTRUCTION X A MPR C TEMP MPO
00000101
Fig. 3-13: First Instruction of Multiplication
The first instruction to be executed is LDA #0.
After execution of this instruction, the contents of register X
are unknown. This is indicated by dashes. The contents of the
accumulator are all zeroes. We also assume that the multiplier
and the multiplicand had been loaded by the programmer prior to
execution of this program. (Otherwise, additional instructions
would be needed to set the contents of MPR and MPD.) We find in
MPR the binary value for «3." We find in MPD the binary value
for "5." The carry bit is undefined. Register TMP is undefined.
And both registers used for RESAD are undefined. Let us now fill
the next line. It appears below; the only difference is that the con
tents of register TMP have been set to "0." The next instruction
will set the contents of RESAD to "0" and the one after will set
the contents of RESAD +1 to "0."
INSTRUCTION
STATEMP
X A MPR C TEMP
00000000
MPO (KSAOH
—
(MIAOU
Fig. 3-14: First Two Lines of Multiplication
The fifth instruction, #8, will set the contents of X to "8." Let
us do one more instruction set (see Figure 3-15).
The LSR MPRAD instruction will shift the contents of MPRAD
right by one position. You can see that after the shift the contents
of MPR are "0000 0001." The right-most "1" of MPR has fallen
80
BASIC PROGRAMMING TECHNIQUES
IABEI
MUIT
INSTRUCTION
IDA ffO
STATEMP
STARESAD
STARESAD+1
IDX*8
ISRMPRAO
BCCNOAOO
lOARESAO
CIC
AOCMPOAO
STARESAO
LDARESAD+I
ADC TEMP
STARESAD+ 1
ASIMPOAD
ROlTEMP
DEX
BNE MUIT
ISRMPRAO
x
00001000
?nd ITERATIOI
A
00000101
)
MPR
—,
C
0
TEMP MPO
00001010
(«SAOX (OSAOIH
Fig. 3-15: Partially Completed Form For Exercise 3-12
into the carry bit. Bit C is now set to 1. Other registers are un
changed.
It is now your turn. Please fill in the rest of this table com
pletely. It is not difficult, but it does require attention. If you have
doubts about the role of some instructions, you may want to refer
to Chapter 4 where you will find each of them listed and de
scribed, or else to the Appendix section of this book where they
are listed in table form.
The final result of your multiplication should be "15" in binary
form, contained in registers RESAD low and high. RESAD high should
be set to "0000 0000." RESAD low should be "0000 1111." If you
obtained this result, you won. If you did not, try one more time.
The most frequent source of errors is a mishandling of the carry
bit. Make sure that the carry bit is changed every time you per
form an arithmetic instruction. Do not forget that the ALU will
set the carry bit after each addition operation.
Programming Alternatives
The program that we have just developed is one of many
ways in which it could have been written. Every programmer can
find ways to modify and sometimes improve a program. For
example, we have shifted the multiplicand left before adding. It
would have been mathematically equivalent to shift the result by
one position to the right before adding it to the multiplicand. The
advantage is that we would not have required register TMP, thus
saving one memory location. This would be a preferred method in
a microprocessor equipped with enough internal registers so that
81
PROGRAMMING THE 6502
MPR, MPD, and RESAD could be contained within the microproces
sor. Since we were obliged to use the memory to perform these
operations, saving one memory location is not relevant. The ques
tion is, therefore, whether the second method might result in a
somewhat faster multiplication. This is an interesting exercise:
Exercise 3.13: Now write an 8x8 multiply, using the same al
gorithm, but shifting the result by one position to the right instead of
shifting the multiplicand by one position to the left. Compare it to
the previous program and determine whether this different ap
proach would be faster or slower than the preceding one.
One more problem may come up: In order to determine the
speed of the program, you may want to refer to the tables in the
Appendix section which list the number of cycles required by
each instruction. However, the number of cy&es required by
some instructions depends on where they are located. A special
addressing mode exists for the 6502 called the Direct Addressing
Zero Page Mode, where the first page (memory location 0 to 255)
is reserved for fast execution. This will be explained in Chapter 5
on addressing techniques. Briefly, all programs that require a
fast execution time will use variables located in page 0 so that in
structions require only two bytes to address memory locations
(addressing 256 locations requires only one byte), whereas instruc
tions located anywhere else in the memory will typically require
3-byte instructions. Let us defer this analysis until after Chap
ter 5.
An Improved Multiplication Program
The program we have just developed is a straightforward
translation of the algorithm into code. However, effective pro
gramming requires close attention to detail so that the length of
the program can be reduced and so that its execution speed can be
improved. We are now going to present an improved implementa
tion of the same algorithm.
One of the tasks which consume instructions and time is the
shifting of the result and the multiplier. A standard "trick" used
in the multiply algorithm is based on the following observation:
every time that the multiplier is shifted by one bit position to the
right, a bit position becomes available on the left. Simultane
ously, we can observe that the first result (or partial product) will
82
BASIC PROGRAMMING TECHNIQUES
use, at most, 9 bits. After the next multiply shift, the size of the
partial product will be increased by one bit again. In other words,
we can just reserve, initially, one memory location for the partial
product and then use the bit positions which are being freed by
the multiplier as it is being shifted.
We are now going to shift the multiplier right. It will free one bit posi
tion to the left. We are going to enter the right-most bit of the partial
product into this bit position that has been freed. Let us now consider the
program.
Let us now also consider the optimal use of registers. The inter
nal registers of the 6502 appear in Fig. 3-16. X is best used as a
counter. We will use it to count the number of bits shifted. The
accumulator is (unfortunately) the only internal register which
can be shifted. In order to improve efficiency, we should store in
it either the multiplier or the result.
c
0
ACCUMULATOR
INDEX REGISTERS
STACK POINTER
0
I PROGRAM COUNTER
|n|v|-|b|d|i|z|c| flags
Fig. 3-16:65O2 Registers
Which one should we put in the accumulator? The result must be
added to the multiplicand every time a 1 is shifted out. Since the
6502 also always adds something to the accumulator only, it is the
result which will reside in the accumulator.
The other numbers will have to reside in the memory (see Figgure
3-17).
A and B will hold the result. A will hold the high part of the
result, and B will hold the low part of the result. A is the ac
cumulator, and B is a memory location, preferably in page 0. C
will hold the multiplier (a memory location). D holds the multipli-
83
PROGRAMMING THE 6502
1
Fig. 3-17: Register Allocation (Improved Multiply)
cand (a memory location). The program appears below:
MULT
LOOP
NOADD
IDA
STA
LDX
LSR
BCC
CLC
ADC
ROR
ROR
DEX
BNE
B
#8
C
NOADD
D
A
B
LOOP
INITIALIZE RESULT TO ZERO (HIGH)
INITIALIZE RESULT (LOW)
X IS SHIFT COUNTER
SHIFT MPR
CARRY WAS ONE. CLEAR IT
A = A + MPD
SHIFT RESULT
CATCH BIT INTO B
DECREMENT COUNTER
LAST SHIFT?
Rg. 3-18: Improved Multiply
Let us examine the program. Since A and B will hold the result,
they must be initialized to the value 0. Let us do it:
MULT LDA #0
STAB
We will then use register X as a shift counter and initialize it to
the value 8:
LDX #8
We are now ready to enter the main multiplication loop as
before. We will first shift the multiplier, then test the carry bit
which holds the right-most bit of the multiplier, which has fallen
off. Let us do it:
LOOP LSR C
BCC NOADD
84
BASIC PROGRAMMING TECHNIQUES
Here we shift the multiplier right as before. This is equivalent
to the previous algorithm because the addition operation is said
to be communicative.
Two possibilities exist: if the carry was 0, we will branch to
NOADD. Let us assume that the carry was 1. We will proceed:
CLC
ADC D
Since the carry was 1, it must be cleared, and we then add the
multiplicand to the accumulator. (The accumulator holds the re
sults, 0 so far.)
Let us now shift the partial product:
NOADD RORA
RORB
The partial product in A is shifted right by one bit. The right
most bit falls into the carry bit. The carry bit is captured and
rotated into register B, which holds the low part of the result.
We simply have to test whether we are finished:
DEX
BNE LOOP
If we now examine this new program, we see that it has been
written in about half the number of instructions of the previous
program. It will also execute much faster. This shows the value of
selecting the correct registers to contain the information.
A straightforward design will result in a program that works. It
will not result in a program that is optimized. It is, therefore, of
significant importance to use the available registers and memory
locations in the best possible way. This example illustrates a ra
tional approach to register selection for maximum efficiency.
Exercise 3.14: Compute the speed of a multiplication operation
using this last program. Assume that a branch will occur in fifty
percent of the cases. Look up the number of cycles required by every
instruction in the table at the end of the book. Assume a clock rate
of one cycle = 1 microsecond.
85
PROGRAMMING THE 6502
Binary Division
The algorithm for binary division is analogous to the one which
has been used for multiplication. The divisor is successively
subtracted from the high order bits of the dividend. After each
subtraction, the result is used instead of the initial dividend. The
value of the quotient is simultaneously increased by 1 every time.
Eventually, the result of the subtraction is negative. This is called
an overdraw. One must then restore the partial result by adding
the divisor back to it. Naturally, the quotient must be simultane
ously decremented by 1. Quotient and dividend are then shifted
by one bit position to the left and the algorithm is repeated.
The method just described is called the restoring method. A
variation of this method which yields an improved speed of execu
tion is called non-restoring method.
END (REMAINDER IS IN LEFT (DIVIDEND)]
Fig. 3-19:8 Bit Binary Division Flowchart
The 16-bit Division
The non-restoring division for a 16-bit dividend, and an 8-bit divisor
will now be described. The result will have 8 bits. The register and memory
86
BASIC PROGRAMMING TECHNIQUES
location for this program are shown in Fig. 3-22. The dividend is con
tained in the accumulator (high part) and in memory location 0, called B
here. The result is contained in Q (memory location 1). The divisor is
contained in D (memory location 2). The result will be contained in Q and
A (A will contain the remainder).
The program appears on Fig. 3-21, the corresponding flow chart is
shown in Fig. 3-20.
Exercise 3.15: Verify the correct operation of this program by
performing the division by hand and exercising the program, as
you did in Exercise 3.12. Divide 33 by 3. The result naturally
should be 11, with a remainder ofO.
LOGICAL OPERATIONS
The other class of instructions that the ALU inside the micro
processor can execute is the set of logical instructions. They in
clude: AND, OR and exclusive OR (EOR). In addition, one can also
include there the shift operations which have already been
utilized, and the comparison instruction, called CMP for the 6502.
The individual use of AND, ORA, EOR, will be described in Chap
ter 4 on the 6502 instruction set. Let us now develop a brief
program which will check whether a given memory location
called LOC contains the value "0," the value "1," or something
else. The program appears below:
NONE FOUND
ZERO
ONE
LDA
CMP
BEQ
CMP
BEQ
LOC
#\$00
ZERO
#\$01
ONE
READ CHARACTER IN LOC
COMPARE TO ZERO
IS IT A 0?
1?
The first instruction: LDA LOC reads the contents of memory
location LOC. This is the character we want to test.
CMP #\$00
87
PROGRAMMING THE 6502
OUT
Fig. 3-20: 16 by 8 Division Flowchart
BASIC PROGRAMMING TECHNIQUES
LINE
0002
0003
0004
0005
0006
0007
0008
0009
0010
0011
0012
0013
0014
0015
0016
0017
0018
0019
0020
0021
0022
0023
0024
0025
0026
ft LOC
0000
0000
0001
0002
0003
0200
0202
0203
0205
0206
0208
020A
020B
020C
020E
0210
0213
0215
0216
0218
021A
021C
021D
021F
0220
CODE
A0 08
38
E5 02
08
26 01
06 00
2A
28
9005
E5 02
4C1502
65 02
88
DO ED
BO 03
65 02
18
26 01
00
LINE
B
Q
D
DIV
LOOP
ADD
NEXT
LAST
* = \$0
* = * + 1
* = * + 1
* = * + 1
* = \$200
LDY08
SEC
SBCD
PHP
ROLQ
ASLB
ROLA
PLP
BCC ADD
SBCD
JMP NEXT
ADCD
DEY
BNE LOOP
BCS LAST
ADCD
CLC
ROLQ
BRK
END
Fig. 3-21: Program
(A) J
(ALSO REAAAINDER)
, 00
I
01
(B)
^ I
(Q)
(D)
Pig. 3-22:16 by 8 Division Registers and Memory Map (non-restoring 8-bit result)
89
PROGRAMMING THE 6502
This instruction compares the contents of the accumulator with
the literal hexadecimal value "00" (i.e., the bit pattern
"00000000"). This comparison instruction will set the Z bit in the
flags register, which will then be tested by the next instruction:
BEQ ZERO
The BEQ instruction specifies "branch if equal." The branch
instruction will determine whether the test succeeds by examin
ing the Z bit. If set, the program will branch to ZERO. If the test
fails, then the next sequential instruction will be executed:
CMP #\$01
The process will be repeated against the new pattern. If the test
succeeds, the next instruction will result in a branch to location
one. If it fails, the next sequential instruction will be executed.
Exercise 3.16: Write a program which will read the contents of
memory location "24" and branch to the address called "STAR" if
there were a "*" in memory location 24. The bit pattern for a "*" in
assembly language notation is represented by "00101010".
SUMMARY
We have now studied most of the important instructions of the
6502 by using them. We have transferred values between the
memory and the registers. We have performed arithmetic and
logical operations on such data. We have tested it, and depending
on the results of these tests, we have executed various portions of
the program. We have also introduced a structure called the loop,
in the multiplication program. An important programming struc
ture will be introduced now: the subroutine.
SUBROUTINES
In concept, a subroutine is simply a block of instructions which
has been given a name by the programmer. From a practical
standpoint, a subroutine must start with a special instruction
called the subroutine declaration, which identifies it as such for
the assembler. It is also terminated by another special instruction
called a return. Let us first illustrate the use of subroutines in the
program in order to demonstrate its value. Then, we will examine
how it is actually implemented.
90
BASIC PROGRAMMING TECHNIQUES
MAIN PROGRAM
CAll SUB
CALL SUB
8
7
—srl
cm RETURN
Fig. 3-23: Subroutine Calls
The use of a subroutine is illustrated in Figure 3-23. The main
program appears on the left of the illustration. The subroutine is
represented symbolically on the right. Let us examine the sub
routine mechanism. The lines of the main program are executed
succesively until a new instruction, CALL SUB, is met. This
special instruction is the subroutine call and results in a transfer
to the subroutine. This means that the next instruction to be
executed after the CALL SUB is the first instruction within the
subroutine. This is illustrated by arrow 1 in the illustration.
Then, the subprogram within the subroutine executes just like
any other program. We will assume that the subroutine does not
contain any other calls. The last instruction of this subroutine is a
RETURN. This is a special instruction which will cause a return
to the main program. The next instruction to be executed after
the RETURN is the one following the CALL SUB. This is illus
trated by arrow 3 in the illustration. Program execution con
tinues then as illustrated by arrow 4.
In the body of the main program a second CALL SUB appears.
A new transfer occurs, shown by arrow 5. This means that the
body of the subroutine is again executed following the CALL SUB
instruction.
Whenever the RETURN within the subroutine is encountered,
a return occurs to the instruction following the CALL SUB in
question. This is illustrated by arrow 7. Following the return to
the main program, program execution proceeds normally, as illus
trated by arrow 8.
The role of the two special instructions CALL SUB and RE-
91
PROGRAMMING THE 6502
TURN should now be clear. What is the value of the subroutine?
The essential value of the subroutine is that it can be called
from any number of points in the main program and used re
peatedly without rewriting it. A first advantage is that this ap
proach saves memory space and there is no need to rewrite the
subroutine every time. A second advantage is that the pro
grammer can design a specific subroutine only once and then use
it repeatedly. This is a significant simplification in program de
sign.
Exercise 3.17: What is the main disadvantage of a subroutine?
The disadvantage of the subroutine should be clear just from
examining the flow of execution between the main program and
the subroutine. A subroutine results in a slower execution, since
extra instructions must be executed: the CALL SUB and the RE
TURN.
Implementation of the Subroutine Mechanism
We will examine here how the two special instructions, CALL
SUB and RETURN, are implemented internally within the processor.
The effect of the CALL SUB instruction is to cause the next instruct
ion to be fetched at a new address. You will remember (or else read
Chapter 1 again) that the address of the next instruction to be ex
ecuted in a computer is contained in the program counter (PC). This
means that the effect of the CALL SUB is to substitute new contents
in register PC. Its effect is to load the start address of the subrou
tine in the program counter. Is that really enough?
To answer this question, let us consider the other instruction
which has to be implemented: the RETURN. The RETURN must
cause, as its name indicates, a return to the instruction that fol
lows the CALL SUB. This is possible only if the address of this
instruction has been preserved somewhere. This address happens
to be the value of the program counter at the time that the CALL
SUB was encountered. This is because the program counter is
automatically incremented every time it is used (read Chapter 1
again?). This is precisely the address that we want to preserve so
that we can later perform RETURN.
The next problem is: where can we save this return address?
92
BASIC PROGRAMMING TECHNIQUES
This address must be saved in a reasonable location where it is
guaranteed that it will not be erased. However, let us now consi
der the following situation, illustrated by Figure 3-24: in this
example, subroutine 1 contains a call to SUB2. Our mechanism
should work in this case as well. Naturally, there might even be
more than two subroutines, say N "nested" calls. Whenever a
new CALL is encountered, the mechanism must therefore store
the program counter again. This implies that we need at least 2N
memory locations for this mechanism. Additionally, we will need
to return from SUB2 first and SUB1 next. In other words, we need
a structure which can preserve the chronological order in which
data will have been saved.
The structure has a name. We have already introduced it. It is
the stack. Figure 3-26 shows the actual contents of the stack
during successive subroutine calls. Let us look at the main pro
gram first. At address 100, the first call is encountered: CALL
SUB1. We will assume that, in this microprocessor, the subroutine
call uses 3 bytes. The next sequential address is therefore not
CAtl SUB 1
Nl
SUBI
Oil SUB 2
RETURN K
SUB 2
RETURN
Fig. 3-24: Nested Calls
"101", but"103."The CALL instruction uses addresses "100",
"101", and "102". Because the control unit of the 6502 "knows* that it
is a 3-byte instruction, the value of the program counter when the
call has been completely decoded will be "103". The effect of the
call will be to load the value "280" in the program counter. "280"
is the starting address of SUBI.
The second effect of the CALL will be to push into the stack (to
preserve) the value "103" of the program counter. This is illus
trated at the bottom left of the illustration which shows that at
time 1, the value "103" is preserved in the stack. Let us move to
the right of the illustration. At location 300, a new call is encoun-
93
PROGRAMMING THE 6502
tered. Just as in the preceding case, the value "900" will be
loaded in the program counter. This is the starting address of
SUB2. Simultaneously, the value "303" will be pushed into the
stack. This is illustrated at the bottom left of the illustration
where the entry at time 2 is "303". Execution will then proceed
to the right of the illustration within SUB2.
We are now ready to demonstrate the effect of the RETURN
instruction and the correct operation of our stack mechanism.
Execution proceeds within SUB2 until the RETURN instruction
is encountered at time 3. The effect of the RETURN instruction is
simply to pop the top of the stack into the program counter. In
other words, the program counter is restored to its value prior to
the entry into the subroutine. The top of the stack in our example
is "303." Figure 3-26 shows that, at time 3, value "303" has been
removed from the stack and has been put back into the program
counter. As a result, instruction execution proceeds from address
"303." At time 4, the RETURN of SUB1 is encountered. The value
on top of the stack is "103." It is popped and is installed in the
program counter. As a result, the program execution will proceed
from location "103" on within the main program. This is, indeed,
(AAAIN)
(SUB1)
© 900
®\
(SUB 2)
RETURN
Fig. 3-25: The Subroutine Calls
the effect that we wanted. Figure 3-26 shows that at time 4 the
stack is again empty. The mechanism works.
94
BASIC PROGRAMMING TECHNIQUES
The subroutine call mechanism works up to the maximum di
mension of the stack. This is why early microprocessors, which
had a 4 or 8-register stack, were essentially limited to 4 or 8 levels
of subroutine calls. In theory, the 6502, which is restricted to 256
memory locations for the stack (Page 1), can therefore accommo
date up to 128 successive subroutine calls. This is true only if
there are no interrupts, if the stack is used for no other purpose,
and if no register needs be stored within the stack. In practice,
fewer subroutine levels will be used.
Note that, on illustrations 3-24 and 3-25, the subroutines
have been shown to the right of the main program. This is only for
the clarity of the diagram. In reality, the subroutines are typed by
the user as regular instructions of the program. On a sheet of
STACK: TIME (1 j
103
TIME (2)
103
303
TIME (3)
103
TIMEU]
Fig. 3-26: Stack vs. Time
paper, in a listing of the complete program, the subroutines may
be at the beginning of the text, in its middle, or at the end. This is
why they are preceded by a subroutine declaration: they must be
identified. The special instructions tell the assembler that what
follows should be treated as a subroutine. Such assembler di
rectives will be presented in Chapter 10.
6502 Subroutines
We have now described the subroutine mechanism, and how the
stack is used to implement it. The subroutine call instruction for
the 6502 is called JSR (jump to subroutine). It is, indeed, a 3-byte
instruction. Unfortunately, it is an unconditional jump: it does not
test bits. Explicit branches must be inserted prior to a JSR if a
test need be performed.
The return from subroutine is the RTS instruction (Return
from subroutine). It is a 1-byte instruction.
PROGRAMMING THE 6502
Exercise 3.1S:Why is the return from a subroutine as long as the
CALL? (Hint: if the answer is not obvious, look again at the stack
implementation of the subroutine mechanism and analyze the
internal operations that must be performed.)
Subroutine Examples
Most of the programs that we have developed and are going to
develop would usually be written as subroutines. For example,
the multiplication program is likely to be used by many areas of
the program. In order to facilitate program development and
clarify it, it is therefore convenient to define a subroutine whose
name would be, for example, MULT. At the end of this subroutine
we would simply add the instruction, RTS.
Exercise 3,19: If MULT is used as a subroutine, would it "damage"
any internal flags or registers?
Recursion
Recursion is a word used to indicate that a subroutine is calling
itself. If you have understood,the implementation mechanism,
you should now be able to answer the following question:
Exercise 3.20: Is it legal to let a subroutine call itself? (In other
words, will everything work even if a subroutine calls itself?) If
you are not sure, draw the stack and fill it with the successive ad
dresses. You will physically verify whether it works or not This
will answer the question. Then, look at the registers and memory
(see Exercise 3.19) and determine if a problem exists.
Subroutine Parameters
When calling a subroutine, one normally expects the sub
routine to work on some data. For example, in the case of the
multiplication, one wants to transmit two numbers to the sub
routine which will perform the multiplication. We saw in the case
of the multiplication routine that this subroutine expected to find
the multiplier and the multiplicand in given memory locations.This
illustrates the first method of passing parameters: through mem
ory. TWo other techniques are used, and parameters can be passed
in three ways:
1. Through registers
96
BASIC PROGRAMMING TECHNIQUES
2. Through memory
3. Through the stack
—Registers can be used to pass parameters. This is an advan
tageous solution, provided that registers are available, since
one does not need to use a fixed memory location. The sub
routine remains memory-independent. If a fixed memory loca
tion is used, any other user of the subroutine must be very
careful that he uses the same convention and that the memory
location is indeed available (look at Exercise 3-20 above). This is
why, in many cases, a block of memory locations is reserved,
simply to pass parameters between various subroutines.
—Using memory has the advantage of greater flexibility (more data),
but results in poorer performance and also in tying up the sub
routine to a given memory area.
—Depositing parameters in the stack has the same advantage as using
registers: it is memory-independent. The subroutine simply knows that
it is supposed to receive, say, two parameters which are stored on top
of the stack. Naturally, it has a disadvantage: it clutters the stack with
data and, therefore, reduces the number of possible levels of sub
routine calls.
The choice is up to the programmer. In general, one wishes to
remain independent from actual memory locations as long as pos
sible.
If registers are not available, the next best solution is usually
the stack. However, if a large quantity of information should be
passed to a subroutine, then this information will have to reside
in the memory. An elegant way around the problem of passing a
block of data is to simply transmit a pointer to the information. A
pointer is the address at the beginning of the block. A pointer can
be transmitted in a register (in the case of the 6502, this limits
the pointer to 8 bits), or else in the stack (two-stack iocations can
be used to store a 16-bit address).
Finally, if neither of the two solutions is applicable, then an
agreement may be made with the subroutine that the data will be
at some fixed memory location (the "mailbox").
Exercise 3.21: Which of the three methods above is best for recur
sion?
97
PROGRAMMING THE 6502
Subroutine Library
There is a strong advantage to structuring portions of a pro
gram into identifiable subroutines: they can be debugged inde
pendently and can have a mnemonic name. Provided that they
will be used in other areas of the program, they become shareable,
and one can thus build a library of useful subroutines. However,
there is no general panacea in computer programming. Using
subroutines systematically for any set of instructions that can be
grouped by function may also result in poor efficiency. The alert
programmer will have to weigh the advantages vs. the disadvan
tages.
SUMMARY
This chapter has presented the way information is manipulated
inside the 6502 by instructions. Increasingly complex algorithms
have been introduced, and translated into programs. The main
types of instructions have been used.
Important structures such as loops, stacks and subroutines
have been defined.
You should now have acquired a basic understanding of pro
gramming, and of the major techniques used in standard applica
tions. Let us study the instructions available.
98
THE 6502 INSTRUCTION SET
PART 1 - OVERALL DESCRIPTION
INTRODUCTION
This chapter will first analyze the various classes of instruc
tions which should be available in a general purpose computer. It
will then analyze one by one all of the instructions available for
the 6502, and explain in detail their purpose and the manner in
which they affect flags, or can be used in conjunction with the
various addressing modes. A detailed discussion of addressing
techniques will be presented in Chapter 5.
CLASSES OF INSTRUCTIONS
Instructions may be classified in many ways, and there is no
standard. We will distinguish here five main categories of instruc
tions:
1. data transfers
2. data processing
3. test and branch
4. input/output
5. control
Let us now examine in turn each of these classes of instruc
tions.
Data transfers
Data transfer instructions will transfer 8-bit data between two
99
PROGRAMMING THE 6502
registers, or between a register and memory, or between a register
and an input/output device. Specialized transfer instructions may
exist for registers which play a special role, for example, a push
and pull operation, for efficient stack implementation. They will
move a word of data between the top of the stack and the ac
cumulator in a single instruction, while automatically updating the
stack-pointer register.
Data Processing
Data processing instructions fall into four general categories:
- arithmetic operations (such as plus/minus)
- logical operations (such as AND, OR, exclusive OR)
- skew and shift operations (such as shift, rotate, swap)
- increment and decrement
It should be noted that for efficient data processing, it is desir
able to have powerful arithmetic instructions, such as multiply and
divide. Unfortunately, this is not available on most microprocessors.
It is also desirable to have powerful shift and skew instructions, such
as shift n bits, or a nibble exchange, where the right half and the
left half of the byte are exchanged. These are also unavailable on
most microprocessors.
Before examining the actual 6502 instructions, let us recall the
difference between a shift and a rotation. The shift will move the
contents of a register or a memory location by one bit-location to
the left or to the right. The bit falling out of the register will go
into the carry bit. The bit coming in on the other side will be a "0."
In the case of a rotation, the bit coming out still goes in the
carry. However, the bit coming in is the previous value which was
in the carry bit. This corresponds to a 9-bit rotation. It would often
be desirable to have a true 8-bit rotation where the bit coming in
on one side is the one falling off on the other side. This is not us
ually provided on microprocessors. Finally, when shifting a word
to the right, it is convenient to have one more type of shift called
a sign-extension or an "arithmetic shift right". When doing opera
tions on two's complement numbers, particularly when implement
ing floating-point routines, it is often necessary to shift a negative
number to the right. When shifting a two's complement number to
the right, the bit which must come in on the left side should be a 1
(the sign bit should get repeated as many times as needed by the suc-
100
6502 INSTRUCTION SET
SHIFT LEFT
CARRY
ROTATE LEFT
Fig. 4-1: Shift and Rotate
cessive shifts). Unfortunately, this type of shift does not exist in the
6502. It exists in other microprocessors.
Test and Branch
The test instructions will test all bits of the flags register of "0"
or "1," or combinations. It is, therefore, desirable to have as many
flags as possible in this register. In addition, it is convenient to be
able to test for combinations of such bits with a single instruction.
Finally, it is desirable to be able to test any bit position in any
register, and to test the value of a register compared to the value of
any other register (greater than, less than, equal). Microprocessor
test instructions are usually limited to testing single bits of the
flags register.
The jump instructions that may be available generally fall into
three categories:
- the jump proper, which specifies a full 16-bit address,
- the branch, which often is restricted to an 8-bit displacement
field,
- the call, which is used with subroutines.
101
PROGRAMMING THE 6502
It is convenient to have two- or even three-way branches, de
pending, for example, on whether the result of a comparison is
"greater than," "less than," or "equal" It is also convenient to
have skip operations, which will jump forward or backwards by a
few instructions. Finally, in most loops, there is usually a decre
ment or increment operation at the end, followed by a test and
branch. The availability of a single-instruction increment/
decrement plus test and branch is, therefore, a significant advan
tage for efficient loop implementation. This is not available in
most microprocessors. Only simple branches, combined with sim
ple tests, are available. This naturally complicates programming,
and reduces efficiency.
Input/Output
Input/output instructions are specialized instructions for the
handling of input/output devices. In practice, nearly all micro
processors use memory-mapped I/O. This means that input/output
devices are connected to the address-bus, just like memory chips,
and addressed as such. They appear to the programmer as mem
ory locations. AH memory-type operations can then be applied to
desired devices. This has the advantage of providing a wide vari
ety of instructions which can be applied. The disadvantage is that
memory-type operations normally require 3 bytes and are, there
fore, slow. For efficient input/output handling in such an envi
ronment, it is desirable to have a short addressing mechanism
available so that I/O devices whose handling speed is crucial may
reside in page 0. However, if page 0 addressing is available, it is
usually used for RAM memory, and therefore prevents its effec
tive use for input/output devices.
Control Instructions
Control instructions supply synchronization signals and may
suspend or interrupt a program. They can also function as a break
or a simulated interrupt. (Interrupts will be described in Chapter
6 on Input/Output Techniques.)
INSTRUCTIONS AVAILABLE ON THE 6502
Data Transfer Instructions
The 6502 has a complete set of data transfer instructions, ex-
102
6502 INSTRUCTION SET
cept for the loading of the stack pointer, which is restricted in
flexibility. The contents of the accumulator may be exchanged
with a memory location with the instructions LDA (load) and
STA (store). The same applies to registers X and Y. These are,
respectively, instructions LDX LDY, and STX STY. There is no
direct loading for S. Inter-register transfers are naturally pro
vided: the instructions are TAX (transfer A to X), TAY, TSX,
TXA, TXS, TYA. There is a slight asymmetry, since the stack
contents may be exchanged with X, but not with Y.
There is no 2-address memory to memory operation, such as "add
contents of LOCI and LOC2."
Stack Operations
Two "push" and "pop" operations are available. They transfer
register A or the status register (P) to the top of the stack in the
memory while updating the stack pointer S. They are PHA and
PHP. The reverse instructions are PLA and PLP (pull A and pull
P), which transfer the top of the stack respectively into A or P.
Data Processing
Arithmetic
The usual (restricted) complement of arithmetic, logical and
shift functions is available. Arithmetic operations are: ADC,
SBC. ADC is an addition with carry, and there is no addition
without carry. This is a minor nuisance as it requires a CLC
instruction prior to any addition. The subtraction is performed by
SBC.
A special decimal mode is available which allows the direct
addition and subtraction of numbers expressed in BCD. In many
other microprocessors only one of these BCD instructions is av
ailable as a separate instruction code. The presence of the decimal
flag multiplies by two the effective number of arithmetic opera
tions available.
Increment/Decrement
Increment and decrement operations are available on the
memory, and on index registers X and Y, but not on the ac
cumulator. They are respectively: INC and DEC, which operate on
the memory; INX, INY and DEX, DEY, which operate on index
registers X and Y.
103
PROGRAMMING THE 6502
Logical Operations
The logical operations are the classic ones: AND, ORA, EOR.
The role of each of these instructions will be clarified.
AND
Each logical operation is characterized by a truth table, which
expresses the logical value of the result in function of the inputs.
The truth table for AND appears below:
0 AND 0 = 0
0 AND 1 = 0
1 AND 0 = 0
1 AND 1 = 1
The AND operation is characterized by the fact that the output
is "1" only if both inputs are "1." In other words, if one of the
inputs is "0," it is guaranteed that the result is "0." This feature is
used to zero a bit position in a word. This is called "masking."
One of the important uses of the AND instruction is to clear or
mask out one or more specified bit positions in a word. Assume, for
example, that we want to zero the right-most four-bit positions in a
word. This will be performed by the following program:
LDA WORD WORD CONTAINS 10101010'
AND #\%11110000 '11110000' IS MASK
Let us assume that WORD is equal to '10101010/ The result of
this program is to leave in the accumulator the value '1010 0000.'
"\%" is used to represent a binary number.
Exercise 4.1: Write a three-line program which will zero bits 1 and
6 of WORD.
Exercise 4.2: What happens with a mask: MASK = '11111111'?
ORA
This instruction is the inclusive OR operation. It is charac-
104
6502 INSTRUCTION SET
terized by the following truth table:
0 OR 0 = 0
0 OR 1 = 1
1 OR 0 = 1
1 OR 1 = 1
The logical OR is characterized by the fact that if any one of the
operands is "1", the result is to set any bit in a word to='T\
LDA #W0RD
ORA #\%00001111
Let us assume that WORD did contain 10101010.' The final
value of the accumulator will be '10101111.'
Exercise 4.3: What would happen if we were to use the instruction
ORA #\%10101111?
Exercise 4.4: What is the effect of ORing with "FF" hexadecimal?
EOR
EOR stands for "exclusive OR." The exclusive OR differs from the
inclusive OR, that we have just described, in one respect: the result is " 1"
only if one, and only one, of the operands is equal to " 1." If both operands
are equal to "1," the normal OR would give a "1" result. The exclusive
OR gives a "0" result. The truth table is:
0 EOR 0 = 0
0 EOR 1 = 1
1 EOR 0 = 1
1 EOR 1=0
The exclusive OR is used for comparisons. If any bit is different,
the exclusive OR of two words will be non-zero. In addition, in the
case of the 6502, the exclusive OR is used to complement a word,
since there is no specific complement instruction. This is done by
performing the EOR of a word with all l's. The program appears
below:
LDA #WORD
EOR #\%11111111
105
PROGRAMMING THE 6502
Let us assume that WORD did contain "10101010." The final
value of the accumulator will be "01010101." We can verify that
this is the complement of the original value.
Exercise 4.5: What is the effect of EOR #\$00?
Shift Operations
The standard 6502 is equipped with a left shift, called ASL
(arithmetic shift left), and a right shift, called LSR (logical shift
right). They will be described below.
However, the 6502 has only one rotate instruction, to the left
(ROD.
Warning: newer versions of the 6502 have an extra rotate instruction.
Check the manufacturer's data to verify this fact. (ROR=rotate right)
Comparisons
Registers X, Y, A can be compared to the memory with instruc
tions CPX, CPY, CMP.
Test and Branch
Since testing is almost exclusively performed on the flags regis
ter, let us examine now the flags available in the 6502. The con
tents of the flags register appear in Figure 4-2 below.
7 6 5 4 3 2 10
N V B
SIGN
(NEGATIVE)
BREAK INTERRUPT
OVERFLOW
CARRY
DECIMAL ZERO
Fig. 4-2: The Flags Register
106
6502 INSTRUCTION SET
Let us examine the function of the flags from left to right.
Sign
The N flag is identical to bit 7 of the accumulator, in most cases.
As a result, bit 7 of the accumulator is the only bit that one can
test conveniently with a single instruction. To test any other bit of
the accumulator, it is necessary to shift its contents. In all cases
where one wants to test the contents of the word quickly, the
preferred bit position will, therefore, be bit 7. This is why input/
output status bits are normally connected to position 7 of the
data-bus. When reading the status of an I/O device, one will simply
read the contents of the external status register into the ac
cumulator and then test bit N.
The left-most bit is the sign bit, or negative bit. Whenever N is
1, it indicates that the value of a result is negative in two's com
plement representation. In practice, flag N is identical to bit 7 of a
result. It is set, or reset, by all data transfers and data processing
instructions.
The bit within the accumulator which is the next easiest to test
is bit Z (zero). However, it requires a right shift by 1 into the carry
bit so that it can be tested.
Instructions that set N are: ADC, AND, ASL, BIT, CMP, CPY,
CPX, DEC, DEX, DEY, EOR, INC, INX, INY, LDA, LDX, LDY,
LSR, ORA, PLA, PLP, ROL, ROR, TAX, TAY, TXS, TXA, TYA.
Overflow
The role of the overflow has already been discussed in Chapter
3 in the section on arithmetic operations. It is used to indicate
that the result of the addition or subtraction of two's complement
numbers might be incorrect because of an overflow from bit 6 to
bit 7, i.e., into the sign bit. A special correction routine must be
used whenever this bit is set. If one does not use two's complement
representation, but direct binary, the overflow bit is equivalent to
a carry from bit 6 into bit 7.
107
PROGRAMMING THE 6502
A special use of this bit is made by the BIT instruction. A result
of this instruction is to set the "V" bit identical to bit 6 of the data
being tested.
The V flag is conditioned by ADC, BIT, CLV, PLP, RTI, SBC.
Break
This break flag is automatically set by the processor if an inter
rupt is caused by the BRK command. It differentiates between a
programmed break and a hardware interrupt. No other user in
struction will modify it.
Decimal
The use of this flag has already been discussed in Chapter 3 in
the section on arithmetic programs. Whenever D is set to "1", the
processor operates in BCD mode, and whenever it is set to "0", it
operates in binary mode. This flag is conditioned by four instruc
tions: CLD, PLP, RTI, SED.
Interrupt
This interrupt-mask bit may be set explicitly by the programmer with
the SEI or PLP instructions, or by the microprocessor during the reset or
during an interrupt.
Its effect is to inhibit any further interrupt.
Instructions which condition this bit are: BRK, CLI, PLP, RTI,
SEI.
Zero
The Z flag indicates, when set (equal to "1"), that the result of
a transfer or an operation is a zero. It is also set by the comparison
instruction. There is no specific instruction which will set or clear
108
6502 INSTRUCTION SET
the Z bit. However, the same result can easily be accomplished. In
order to set the zero bit, one can, for example, execute the follow
ing instruction:
LDA #0
The Z bit is conditioned by many instructions: ADC, AND,
ASL, BIT, CMP, CPY, CPX, DEC, DEX, DEY, EOR, INC, INX,
INY, LDA, LDX, LDY, LSR, ORA, PLA, PLP, ROL, ROR, RTI,
SBC, TAX, TAY, TXA, TYA.
Carry
It has been seen that the carry bit is used for a dual purpose. Its
first purpose is to indicate an arithmetic carry or borrow during
arithmetic operations. Its second purpose is to store the bit "falling
out" of a register during the shift or rotate operations. The
two roles do not necessarily need be confused, and they are not on
larger computers. However, this approach saves time in the mi
croprocessor, in particular for the implementation of a multiplica
tion or a division. The carry bit can be set or cleared explicitly.
Instructions which will condition the carry bit are: ADC, ASL,
CLC, CMP, CPX, CPY, LSR, PLP, ROL, ROR, RTI, SBC, SEC.
Tkst and Branch Instructions
In the 6502, it is not possible to test every bit of the flags regis
ter for one or zero. There are 4 bits which can be tested, and there are,
therefore, 8 different branch instructions. They are:
— BMI (branch on minus), BPL (branch on plus). These two
instructions, naturally, test the N bit.
— BCC (branch on carry clear) and BCS (branch on carry set):
they test C.
— BEQ (branch when result is null) and BNE (branch on
result not zero). They test Z.
— BVS (branch when overflow is set) and BVC (branch on
overflow clear). They test V.
109
PROGRAMMING THE 6502
These instructions test and branch within the same instruction.
All branches specify a displacement relative to the current in
struction. Since the displacement field is 8 bits, this allows a
displacement of -128 to +127 (in two's complement). The dis
placement is added to the address of the first instruction following
the branch.
Since all branches are 2 bytes long, this results in an effective
displacement of -128 + 2 = -126 to +127 +2 = +129.
Two more unconditional instructions are available: JMP and
JSR. JMP is a jump to a 16-bit address. JSR is a subroutine call. It
jumps to a new address and automatically preserves the program
counter into the stack. Being unconditional, these two instructions
are usually preceded by a "test and branch" instruction.
Two returns are available: RTI, a return from interrupt, which
will be discussed in the interrupt section, and RTS, a return from
subroutine, which pulls a return address from the stack (and in
crements it).
Two special instructions are provided especially for bit-testing
and for comparisons.
The BIT instruction performs an AND between the memory
location and the accumulator. One important aspect is that it does
not change the contents of the accumulator. The flag N is set to the
value of bit 7 of the location tested, while the V flag is set to
bit 6 of the memory location being tested. Finally, bit Z indicates
the result of the AND operation. Z is set to "1" if the result is "0".
Typically a mask will be loaded in the accumulator, and successive
memory values will then be tested using the BIT instruction.
If the mask contains a single "1" for example, this will test
whether any given memory word does contain a "1" in that posi
tion. In practice, this means that a mask should be used only
when one is testing memory bit locations "0" to "5". The reader
will remember that bit locations "6" and "7" are automatically
stored respectively, in the "V" flag and in the "N" flag. They do not
need to be masked.
The CMP instruction will compare the contents of the memory
location to those of the accumulator by subtracting it from the ac
cumulator. The result of the comparison will be indicated, there-
110
6502 INSTRUCTION SET
fore, by bits Z and N. One can detect equality, greater than, or less
than. The value of the accumulator is not changed by the compar
ison. CPX and CPY will compare to X and Y respectively.
Input/Output Instructions
There are no specialized input/output instructions in the 6502.
Control Instructions
Control instructions include specialized instructions to set or
clear the flags. They are: CLC, CLD, CLI, CLV, which clear re
spectively bits C, D, I and V; and SEC, SED, SEI, which set re
spectively in bits C, D, and I.
The BRK instruction is the equivalent of a software interrupt
and will be described in Chapter 7 in the interrupt section.
The NOP instruction is an instruction which has no effect and is
commonly used to extend the timing of a loop. Finally, two special
pins on the 6502 will trigger an interrupt mechanism, and this will
be explained in Chapter 6 on input/output techniques. It is a hard
ware control facility (IRQ and NMI pins).
Let us now examine each instruction in detail.
In order to truly understand the various addressing modes, the reader
is encouraged to read the following section quickly the first time, and
then in more detail the second time after studying Chapter 5 on
Addressing Techniques.
ill
PROGRAMMING THE 6502
PART 2 - THE INSTRUCTIONS
ABBREVIATIONS
A
M
P
S
X
Y
DATA
HEX
PC
PCH
PCL
STACK
V
A
V
•
( )
M6)
Accumulator
Specified address (memory)
Status register
Stack pointer
Index register
Index register
Specified data
Hexadecimal
Program counter
Program counter high
Program counter low
Contents of top of stack
Logical or
Logical and
Exclusive or
Change
Receives the value of (assignment)
Contents of
Bit position 6 at address M
112
6502 INSTRUCTION SET
ADC Add with carry
Function:
Format:
(A) + DATA + C
OllbbbOl ADDR/DATA ADDR
_j
Description:
Add the contents of memory address or literal to the ac
cumulator, plus the carry bit. The result is left in the ac
cumulator.
Remarks:
—ADC may operate either in decimal or binary mode: flags
must be set to the correct value
—To ADD without carry, flag C must be cleared (CLC).
Data Paths:
Addressing Modes:
HEX
BYTES
CYCIES
bbb
ft///'
6D
3
4
on
y*
65
2
3
001
*/*
69
2
2
010
7D
3
4*
m
79
3
4*
no
61
2
6
000
74
71
2
5*
100
W//////
75
2
4
101
: PLUS 1 CYCLE IF CROSSING PAGE BOUNDARY.
Flags: N
•
V
•
B D 1 Z C
• •
113
PROGRAAAMING THE 6502
Instruction Codes:
ABSOLUTE 01101101
bbb= Oil
bbb= 010
b^ 110
bbb-= 101
16-BIT ADDRESS
I
HEX= 6D CYCLES = 4
ZERO-PAGE
IMMEDIATE
01100101
bbb= 001
01101001
ADDR
HEX-: 65
DATA
HEX ■= 69 CYCLES = 2
ABSOLUTE, X
ABSOLUTE, Y
bbb
01111101
- Ill
01111001
HEX
16-BIT
= 7D
16-BIT
ADDRESS
CYCLES =
1
ADDRESS
4*
79 CYCLES = 4*
(IND. X)
(IND),Y
7ERO-PAGE, X
bbb
bbb
01100001
= 000
01110001
- 100
01110101
ADDR
HEX- 61
ADDR
HEX - 71
ADDR
75 CYCLES^ 4
•: PLUS 1 CYCLE IF CROSSING PAGE BOUNDARY.
114
6502 INSTRUCTION SET
AND Logical AND
Function: A^-(A) A DATA
Format: ADDR/DATA ADDR
Description:
Perform the logical AND of the accumulator and specified data.
The result is left in the accumulator.
The truth table is:
a\m
0
,1
0
0
0
1
0
1
Data Paths:
Addressing Modes:
HEX
BYTES
CYCLES
bbb
V*
2D
3
4
Oil
ft///*/*
25
2
3
001
29
2
2
010
3D
3
4*
in
39
3
4*
110
21
2
6
000
Vi
31
2
5*
100
y*
35
2
4
101
7<
*/,
/*
•: PLUS 1 CYCLE IF CROSSING PAGE BOUNDARY.
Flags:
N
•
V B 0 I Z
•
c
115
PROGRAMMING THE 6502
Instruction Codes:
ABSOLUTE 00101101
bbb= Oil
16-BIT ADDRESS
HEX= 2D CYCLES = 4
bbb- 010
ZERO-PAGE
IMMEDIATE
00100101
bbb= 001
00101001
ADDR
HEX =
DATA
25
HEX- 29 CYCLES = 2
ABSOLUTE
ABSOLUTE,
X
Y
00111101
bbb - 111
00111001
HEX
16-BIT
= 3D
16-BIT
1
ADDRESS
CYCLES =
ADDRESS
4*
HEX = 39 CYCLES = 4*
(IND, X)
(IND),Y
ZERO PAGE, X
00100001
bbb= 000
0011001
bbb * 100
00110101
ADDR
HEX = 21
ADDR
HEX ■■- 31
ADDR
bbb - 101 HEX - 35 CYCLES = 4
•: PLUS 1 CYCLE IF CROSSING PAGE BOUNDARY.
116
6502 INSTRUCTION SET
ASL
Function:
Arithmetic shift left
Format:
7 6 5 4 3 2 10 » 0
OOObbbiO ADDR
,
I ADDR
- J
Description:
Move the contents of the accumulator or of the memory location
left by one bit position. 0 comes in on the right. Bit 7 falls into the
carry. The result is deposited in the source, i.e. either accumulator
or memory.
Data paths:
Addressing Modes:
HEX
BYTES
CYCIES
bbb
OA
i
2
010
OE
3
6
on
06
2
5
001
IE
3
7
111
16
2
6
101
Flags:
N
•
V B D 1 Z
•
c
•
117
PROGRAMMING THE 6502
Instruction Codes:
ACCUMULATOR
ABSOLUTE
ZERO-PAGE
ABSOLUTE, X
ZERO-PAGE, X
00001010
bbb=010
bbb=011
bbb=001
bbb =111
bbb =
HEX= 0A CYCLES = 2
000011 10 ADDRESS
I
HEX= 0E
000001 10 ADDR
HEX= 06
CYCLES = 6
CYCLES = 5
000111 10
1
ADDRESS
HEX= IE
000101 10 ADDR
HEX= 16
CYCLES = 7
CYCLES = 6
118
6502 INSTRUCTION SET
BCC Branch on carry clear
Function:
Go to specified address if C = 0
Format:
1001000 DISPLACEMENT
Description:
Test the carry flag. If C = 0, branch to the current address plus
the signed displacement (up to 4-127 or -128). If C = 1, take no
action. The displacement is added to the address of the first in
struction following the BCC. This results in an effective dis
placement of +129 to -126.
Data Paths:
BCC
+ 12
NEXT ADDR1
Addressing Mode:
Relative only:
HEX = 90, bytes = 2, cycles = 2 + 1 if branch succeeds
+ 2 if into another page
Flags:
N V B 0 1 z c
(NO ACTION)
119
PROGRAMMING THE 6502
BCS Branch on carry set
Function:
Go to specified address if C = 1
Format: 10110000 DISPLACEMENT
Description:
Test the carry flag. If C = 1, branch to the current address plus
the signed displacement (up to +127 or -128). If C = 0, take no
action. The displacement is added to the address of the first instruc
tion following the BCS. This results in an effective displacement of
+129 to -126.
Data Paths:
BCS
ADDR1
Addressing Mode:
Relative only:
HEX = B0, bytes = 2, cycles = 2 + 1 if branch succeeds
+2 if into another page
Flags:
N V B D 1 Z C
(NO ACTION)
120
6502 INSTRUCTION SET
BEQ Branch if equal to zero
Function:
Go to specified address if Z= 1 (result = 0).
Format: 111 10000 DISPLACEMENT
Description:
Test the Z flag. If Z = 1, branch to the current address plus the
signed displacement (up to +127 or -128). If Z = 0, take no
action.
The displacement is added to the address of the first instruction
following the BEQ. This results in an effective displacement of
+ 129 to -126.
Data Paths:
BEQ
A0DR1
Addressing Mode:
Relative only:
HEX = FO, bytes = 2, cycles = 2 +1 if branch succeeds
+2 if into another page
Flags:
N V B 0 I Z c
(NO ACTION)
121
PROGRAMMING THE 6502
BIT Compare memory bits with accumulator
Function:
Z-«-(A) A (M) ,
Format: 001Ob100 ADDR ADDR
Description:
The logical AND of A and M is performed, but not stored. The result
of the comparison is indicated by Z. Z = 1 if the comparison fails; 0
otherwise. In addition, bits 6 and 7 of the memory data are transferred
into V and N of the status register. It does not modify the contents of A.
Data Paths:
p
N, V, Z
fM
l \V
> 1
BITS 6 AND 7
Addressing Modes:
HEX
BYTES
CYCLES
bbb
2C
3
4
Oil
24
2
3
001
f////////
Flags:
odes:
ABSOLUTE
N
M7
V
Me
B
00101100
0 1 z
•
16-BIT
c
ADDRESS
HEX= 2C CYaES=
00100100 ADDR
HEX= 24 CYQES= 3
122
6502 INSTRUCTION SET
BMI Branch on minus
Function:
Go to specified address if N = 1 (result < 0).
Format: DISPLACEMENT
Description:
Test the N flag (sign). If N = 1, branch to the current address
plus the signed displacement (up to +127 or -128). If N = 0, take
no action.
The displacement is added to the address of the first instruction
following the BMI. This results in an effective displacement of
+ 129 to - 126.
Data Paths:
+ 12
NEXT
Addressing Mode:
Relative only:
HEX = 30, bytes = 2, cycles = 2 +1 if branch succeeds
+2 if into another page
Flags:
N V B D I Z c
(NO ACTION)
123
PROGRAMMING THE 6502
BNE Branch on not equal to zero
Function:
Go to specified address if Z = 0 (result * 0).
Format: 11010000 DISPLACEMENT
Description:
Test the result (Z flag). If the result is not equal to 0 (Z = 0),
branch to the current address plus the signed displacement (up to
+127 to -128). If Z = 1, take no action.
The displacement is added to the address of the first instruction
following the BNE. This results in an effective displacement of
+ 129 to -126.
Data Paths:
BNE
NEXT ADDR1
Addressing Mode:
Relative only:
HEX = DO, bytes = 2, cycles = 2 +1 if branch succeeds
+ 2 if into another page
Flags:
N V B D 1 Z c
(NO ACTION)
124
6502 INSTRUCTION SET
BPL Branch on plus
Function:
Go to specified address if N = 0 (result
Format: DISPLACEMENT
0).
Description:
Test the N flag (sign). If N = 0 (result positive), branch to the
current address plus the signed displacement (up to +127 or
-128). If N = 1, take no action.
The displacement is added to the address of the first instruction
following the BPL. This results in an effective displacement of
+129 to -126.
Data Paths:
BPL
+ 12
NEXT ADDR1
Addressing Mode:
Relative only:
HEX = 10, bytes = 2, cycles = 2 +1 if branch succeeds
+2 if into another page
Flags:
N V B D 1 Z c
(NO ACTION)
125
PROGRAMMING THE 6502
BRK Break
Function:
STACK (PC) + 2, STACK (P), PC -*-(FFFE,FFFF)
Format: 00000000
Description:
Operates like an interrupt: the program counter is pushed on
the stack, then the status register P. The contents of memory
locations FFFE and FFFF are then deposited respectively in PCL
and PCH. The value of P stored in the stack has the B flag set to 1,
to differentiate a BRK from an IRQ.
Important: unlike an interrupt, PC + 2 is saved. This may not
be the next instruction, and a correction may be necessary. This is
due to the assumed use of BRK to patch existing programs where BRK
replaces a 2-byte instruction. When debugging a program, BRK is gen
erally used to cause exit to monitor. Then, BRK often replaces the first
byte of an instruction.
Data Paths:
Addressing Mode:
Implied only:
HEX = 00 , byte = 1, cycles = 7
Flags:
D I Z C
1
Note: B is set in before P is pushed in the stack.
126
6502 INSTRUCTION SET
BVC Branch on overflow clear
Function:
Go to specified address if V = 0.
Format: 0101000 DISPLACEMENT
Description:
Test the overflow flag(V). If there is no overflow (V = 0), branch
to the current address plus the signed displacement (up to +127
or -128). If V = 1, take no action.
The displacement is added to the address of the first instruction
following the BVC. This results in an effective displacement of
+129 to -126.
Data Paths:
+ 12
NEXT ADDR1
Addressing Mode:
Relative only:
Hex = 50, bytes = 2, cycles = 2 + 1 if branch succeeds
+2 if into another page
Flags:
N V B D 1 Z c
(NO ACTION)
127
PROGRAMMING THE 6502
BVS Branch on overflow set
Function:
Go to specified address if V = 1.
Format: omoooo DISPLACEMENT
Description:
Test the overflow flag (V). If an overflow has occurred (V = l),
branch to the current address plus the signed displacement (up to
+127 or -128). If V = 0, take no action.
The displacement is added to the address of the first instruction
following the BVS. This results in an effective displacement of
+ 129 to -126.
Data Paths:
NEXT
Addressing Mode:
Relative only:
HEX = 70, bytes = 2, cycles = 2
Flags:
+1 if branch succeeds
+2 if into another page
N V B D I Z c
(NO ACTION)
128
6502 INSTRUCTION SET
CLC
Function:
Clear carry
Format: 00011000
Description:
The carry bit is cleared. This is often necessary before an ADC.
Addressing Mode:
Implied only
HEX = 18, byte = 1, cycles= 2
Flags:
N V B 0 1 2 C
129
PROGRAAAMING THE 6502
CLD
Function:
Format:
Description:
The D flag is
SBC.
Clear decimal flag
11011000
cleared, setting the binary mode for ADC and
Addressing Mode:
Implied only:
HEX = D8, byte = 1, cycles= 2
Flags:
N V B 0
0
1 Z
|
c
130
6502 INSTRUCTION SET
CLI
Function:
Clear interrupt mask
Format: 01011000
Description:
The interrupt mask bit is set to 0. This enables interrupts. An
interrupt handling routine must always clear the I bit, or else
other interrupts may be lost.
Addressing Mode:
Implied only:
HEX = 58, byte= 1, cycles= 2
Flags:
0
131
PROGRAMMING THE 6502
CLV Clear overflow flag
Function:
Format:
10111000
Description:
The overflow flag is cleared.
Addressing Mode:
Implied only:
HEX = B8, byte = 1, cycles = 2
Flags:
N V B D I Z C
101 1 |
132
CMP
6502 INSTRUCTION SET
Compare to accumulator
Function:
(A)-DATA—NZC:
+ (A>DATA)
-01
s
on
- (A<0ATA)
-00
Format: llObbbOl ADDR/DATA ADDR
Description:
The specified contents are subtracted from A. The result is not
stored, but flags NZC are conditioned, depending on whether the
result is positive, null or negative. The value of the accumulator
is not changed. Z is set by an equality, reset otherwise; N is set;
reset by the sign (bit 7), C is set when (A) > DATA. CMP is usual
ly followed by a branch: BCC detects A < DATA, BEQ detects A
= DATA, BCS detects A > DATA, and BEQ followed by BCS
detects A > DATA.
Data Paths:
p
\v
7
Addressing Modes:
HEX
BYTES
CYCLES
bbb
CO
3
4
Oil
C5
2
3
001
C9
2
2
010
DO
3
4*
111
D9
3
4*
110
C1
2
6
000
01
2
5*
100
D5
2
4
101
•: PLUS 1 CYCLE IF CROSSING PAGE BOUNDARY.
Flags:
N
•
V B D 1 Z
•
C
•
133
PROGRAMMING THE 6502
Instruction Codes:
ABSOLUTE
bbb= Oil
bbb= 010
bbb= 110
16-BIT ADDRESS
I
HEX= CD CYCLES = 4
ZERO-PAGE
IMMEDIATE
bbb
11000101
= 001
11001001
ADDR
HEX =
DATA
C5
HEX= C9 CYCLES = 2
ABSOLUTE,
ABSOLUTE,
X
Y
bbb =
11011101
111
11011001
HEX =
16-BIT
DD
16-BIT
ADDRESS
i
CYCLES =
ADDRESS
I
4*
(IND.X)
(IND),Y
ZERO-PAGE, X
bbb =
bbb =
11000001
000
11010001
100
11010101
ADDR
HEX =
ADDR
HEX =
ADDR
Cl
D1
bbb= 101
HEX= D9 CYCLES = 4*
CYCLES = 6
CYCLES = 5*
HEX= D5 CYCLES = 4
*: PLUS 1 CYCLE IF CROSSING PAGE BOUNDARY.
134
6502 INSTRUCTION SET
CPX
Function:
X-DATA
Format:
Compare to register X
+ (X> DATA)
-01
=
on
-(X<DATA)
-00
1110bb00 ADDR/DATA ADDR
J
Description:
The specified contents are subtracted from X. The result is not
stored, but flags NZC are conditioned, depending on whether the
result is positive, null or negative. The value of the accumulator
is not changed. CPX is usually followed by a branch: BCC detects X<
DATA, BEQ detects X = DATA, and BEQ followed by BCS detects
X>DATA. BCS detects X > DATA.
Data Paths:
p
T
1
1
M—•■
-.
! !
DATA
Addressing Modes:
HEX
BYTES
CYCLES
bb
/'///i
EC
3
4
11
E4
2
3
01
V/AAAVffl'A
EO
2
2
00
'A
Flags:
N
•
V B D 1 Z
•
c
•
135
PROGRAAAMING THE 6502
Instruction Codes:
ABSOLUTE 11101100
bb= 11
bb= 00
16-BIT ADDRESS
I
HEX= EC CYCLES = 4
ZERO-PAGE
IMMEDIATE
bb =
11100100
01
11100000
ADDR
HEX= E4
DATA
HEX= EO CYCLES = 2
136
6502 INSTRUCTION SET
CPY
Function:
Compare to register Y
(Y) - DATA -*-NZC:
Format:
+ (Y>DATA)
-01
=
on
-(Y<DATA)
-00
UOObbOO ADDR'DATA ADDR
Description:
The specified contents are subtracted from Y. The result is not
stored, but flags NZC are conditioned, depending on whether the
result is positive, null or negative. The value of the accumulator
is not changed. CPY is usually followed by a branch: BCC detects
Y < data, BEQ detects Y = data, and BEQ followed by BCS
detects Y > data. BCS detects Y ^ data.
Data Paths:
p
\v
T
Addressing Modes:
HEX
BYTES
CYCLES
bb
cc
3
4
11
C4
2
3
01
CO
2
2
00
Flags:.
N
•
V B D 1 Z
•
c
•
137
PROGRAMMING THE 6502
Instruction Codes:
ABSOLUTE
ZERO-PAGE
IMMEDIATE
11001100
bb= 11
11000100
bb= 01
11000000
bb= 00
16-BIT
HEX= CC
ADDR
HEX= C4
DATA
HEX= CO
ADDRESS
1
CYCLES = 4
CYCLES = 3
CYCLES = 2
138
DEC
Function:
Format:
6502 INSTRUCTION SET
Decrement
llObbUO ADDR ADDR
Description:
The contents of the specified memory address are decremented
by 1. The result is stored back at the specified memory address.
Data Paths:
DATA-M5ATA-1
Addressing Modes:
HEX
BYTES
CYCLES
■■ bb
CE
3
6
01
C6
2
5
00
DE
3
7
n
'/iff/*
D6
2
6
10
*ft
Flags:
N V
•I.
B D 1 Z
•
C
139
PROGRAAAAAING THE 6502
Instruction Codes:
ABSOLUTE
ZERO-PAGE
11001110 ADDRESS
i
bb=01
bb=00
HEX= CE CYCLES = 6
11000110 ADDR
HEX= C6 CYCLES = 5
ABSOLUTE, X 11011110 ADDRESS
bb = 1 HEX= DE CYCLES = 7
ZERO-PAGE, X 11010110 ADDR
bb-10 HEX= D6 CYCLES = 6
140
6502 INSTRUCTION SET
DEX
Function:
X -*- (X) - 1
Format:
Decrement X
11001010
Description:
The contents of X are decremented by 1. Allows the use of X as
a counter.
Data Paths:
X
N
Z
-1
AN-
i
1
Addressing Mode:
Implied only:
HEX = CA, byte= 1, cycles = 2
Flags:
N
•
V B D 1 Z
•
C
141
PROGRAMMING THE 6502
DEY
Function:
Y ^-0
Format:
Decrement Y
10001000
Description:
The contents of Y are decremented by 1. Allows the use of Y as
a counter.
Data Paths:
Y
N
Z
{}?
-1
L_
Addressing Mode:
Implied only:
HEX = 88, byte = 1, cycles = 2
Flags:
N
•
V B D 1 Z
•
c
142
6502 INSTRUCTION SET
EOR Exclusive—OR with accumulator
Function:
A**- (A) V DATA
Format:
OlObbbOl ADDR/DATA ADDR
Description:
The contents of the accumulator are exclusive -ORed with the
specific data. The truth table is:
0
1
0
0
1
1
1
0
Note: EOR with "-1" may be used to complement.
Data Paths: A
Addressing Modes:
HEX
BYTES
CYCLES
bbb
/'//A
4D
3
4
Oil
/ / *
45
2
3
001
49
2
2
010
'A
5D
3
4*
111
59
3
4*
110
41
2
6
000
'A
51
2
5*
100
ft/*
55
2
4
101
•: PIUS 1 CYCLE IF CROSSING PAGE BOUNDARY.
Flags:
N
•
V B D 1 Z
•
c
143
PROGRAMMING THE 6502
Instruction Codes:
ABSOLUTE 01001101
bbb= Oil
bbb= 010
bbb= 110
bbb ■= 101
16-BIT ADDRESS
I
HEX= 4D CYCLES = 4
ZERO-PAGE
IMMEDIATE
bbb
01000101
= 001
01001001
ADDR
HEX = 45
DATA
HEX = 49 CYCLES = 2
ABSOLUTE
ABSOLUTE,
X
Y
bbb
01011101
= 111
01011001
HEX
16-BIT
■= 5D
16-BIT
1
ADDRESS
CYCLES^
ADDRESS
4*
HEX-= 59 CYCLES-= 4*
(IND,
(IND)
'AGE,
X)
, Y
X
bbb =
bbb--
01000001
000
01010001
100
010101-01
ADDR
HEX =
ADDR
HEX •--
ADDR
41
51
HEX = 55 CYCLES = 4
*: PLUS 1 CYCLE IF CROSSING PAGE BOUNDARY.
144
6502 INSTRUCTION SET
INC
Function:
M -«- (M) +1
Format:
Increment memory
lllbbilO ADDR ADDR I
j
Description:
The contents of the specified memory location are incremented
by one, then redeposited into it.
Data Paths:
s—\
\l—?
M »-
1
i 1
! ;
DATA DATA-*OATA+1
Addressing Modes:
HEX
BYTES
CYCLES
bb
EE
3
6
01
E6
2
5
00
FE
3
7
11
F6
2
6
10
Flags:
N
•
V B D 1 Z
•
c
145
PROGRAMMING THE 6502
Instruction Codes:
ABSOLUTE momo ADDRESS
HEX= EE CYCLES = 6
ZERO-PAGE 11100110 ADDR
bb = 0O HEX= E6 CYCLES = 5
ABSOLUTE, X 11111110 ADDRESS
bb=ll HEX= FE CYCLES = 7
ZERO-PAGE, X 11110110 ADDR
bb=10 HEX= F6 CYCLES = 6
146
6502 INSTRUCTION SET
INX
Function:
X-*-(X) +1
Format:
Increment X
11101000
Description:
The contents of X are incremented by one. This allows the use
of X as counter.
Data Paths:
+ 1
1
/>—
Addressing Mode:
Implied only:
HEX = E8, byte = 1, cycles = 2
Flags:
N
•
V B D 1 Z
•
C
147
PROGRAMMING THE 6502
INY
Function:
Format:
1
Increment Y
11001000
Description:
The contents of Y are incremented by one. This allows the use
of Y as counter.
Data Paths:
Addressing Mode:
Implied only:
HEX = C8, byte = 1, cycles = 2
Flags:
N
•
V B D 1 Z
•
c
148
6502 INSTRUCTION SET
JMP Jump to address
Function:
PC^- ADDRESS
Format:
Description:
A new address is loaded in the program counter, causing a jump
to occur in the program sequence. The address specification may
be absolute or indirect.
Data Paths:
OlbOllOO ADDRESS
1 _
(ABSOLUTE)
Addressing Modes:
HEX
BYTES
CYCLES
b
4C
3
3
0
AC
3
5
1
Flags:
N V B 0 1 2 C
(NO EFFECT)
149
PROGRAMMING THE 6502
Instruction Codes:
ABSOLUTE
INDIRECT
b
oioonoo
=0
01101100
HEX = 4C
ADDRESS
CYCLES = 3
ADDRESS
HEX=6C CYCLES=5
(INDIRECT)
p c
— ADDRESS —
JMP
FINAL ADDRESS
150
6502 INSTRUCTION SET
JSR Jump to subroutine
00100000
1
ADDRESS
i
Function:
STACKS- (PC) +2
PC-«- ADDRESS
Format:
Description:
The contents of the program counter +2 are saved into the
stack. (This is the address of the instruction following the JSR).
The subroutine address is then loaded into PC. This is also called
a "subroutine CALL."
Data Paths:
©
©
ADDR
Addressing Mode:
Absolute only:
HEX = 20, bytes = 3, cycles = 6
Flags:
N V B D 1 Z C
(NO EFFECT)
151
PROGRAMMING THE 6502
LDA Load accumulator
Function:
A ^-DATA
Format:
Description:
The accumulator is loaded with new data.
Data Paths:
lOlbbbOl ADDR/DATA ADDR
Addressing Modes:
AD
3
4
on
AS
2
3
001
A9
2
2
010
BD
3
4*
111
B9
3
4*
no
A1
2
6
000
Bt
2
5"
100
B5
2
4
101
•: PLUS 1 CYCLE IF CROSSING PAGE BOUNDARY.
Flags:
152
Instruction Codes:
ABSOLUTE 10101101
6502 INSTRUCTION SET
16-BIT ADDRESS
HEX = AD CYCLES = 4
bbb-- 010
ZERO-PAGE
IMMEDIATE
bbb
10100101
■•= ooi
10101001
ADDR
HEX^=
DATA
A5
HEX= A9 CYCLES = 2
ABSOLUTE,
ABSOLUTE,
X
Y
bbb
10111101
^ 111
10111001
HEX
16-BIT
- BD
16-BIT
ADDRESS
CYCLESADDRESS
4*
bbb- 110 HEX= B9 CYCLES = 4*
(IND, X)
(IND).Y
7ERO-PAGE, X
bbb
bbb
10100001
- 000
10110001
■- ioo
10110101
ADDR
HEX^=
ADDR
HEX -■•
ADDR
A1
Bl
bbb - 101 HEX = B5 CYCLES = 4
: PLUS 1 CYCLE IF CROSSING PAGE BOUNDARY.
153
PROGRAMMING THE 6502
LDX
Function:
X-*- DATA
Format:
Load register X
lOlbbblO ADDR/DATA ADDR j
Description:
Index register X is loaded with data from the specified address.
Data Paths:
W///////////A Wf///////////,
Addressing Modes:
HEX
BYTES
CYCLES
bbb
^ / £y / / ® / <S / T / > / a
AE
3
4
on
A6
2
3
001
A2
2
2
000
BE
3
4*
111
B6
2
4
110
*: PLUS 1 CYCLE IF CROSSING PAGE BOUNDARY.
Flags:
N
•
V B 0 1 Z
•
c
154
Instruction Codes:
ABSOLUTE 10101110
bbb -- 011
bbb = 000
ABSOLUTE, Y
ZERO PAGE. Y
10111110
bbb 111
6502 INSTRUCTION SET
16-BIT ADDRESS
HEX - AE CYCLES - 4
ZtRO-PAGE
IMMEDIATE
bbb
10100110
- 001
10100010
ADDR
HEX - A6
DATA
HEX -- A2 CYCLES "■ 2
16-BIT ADDRESS
I
HEX BE CYCLES = 4*
10111010 ADDR
HEX • B6 CYCIES : 4
•: PLUS 1 CYCLE IF CROSSING PAGE BOUNDARY.
155
PROGRAMMING THE 6502
LDY
Function:
Y^- DATA
Format:
Load register Y
lOlbbbOO ADDR/DATA ADDR
.1
Description:
Index register Y is loaded with data from the specified address.
DataPaths:
WW////M W////////'///,
Addressing Modes:
AC
3
4
Oil
M
2
3
00)
A0
2
2
000
BO
3
4*
III
B4
4
4
101
*: PLUS 1 CYCLE IF CROSSING PAGE BOUNDARY.
Flags:
N
•
V B D 1 Z
•
c
156
Instruction Codes:
6502 INSTRUCTION SET
ABSOLUTE
ZERO-PAGE
IMMEDIATE
ABSOLUTE, X
ZERO-PAGE, X
10101100
bbb= 011
10100100
bbb=001
10100000
bbb= 000
10111100
bbb =111
10110100
1
16-BIT
HEX= AC
ADOR
HEX= A4
DATA
HEX=A0
16-BIT
HEX=BC
ADDR
ADDRESS
CYCLES = 4
CYCLES = 3
CYCLES = 2
ADDRESS
__
CYCLES = 4*
bbb =101 HEX= B4 CYCLES ^
*: PLUS 1 CYCLE IF CROSSING PAGE BOUNDARY.
157
PROGRAMMING THE 6502
LSR Logical shift right
Function: <t>—*- 7 6 5 4 3 2 1 t
Format: OlObbblO ADDR/DATA
Description:
Shift the specified contents (accumulator or memory) right by
one bit position. A "0" is forced into bit 7. Bit 0 is trafosferred to
the carry. The shifted data is deposited in the source, i.e., either
accumulator or memory.
Data Paths:
1
1
1
I
1
1
1
DATA
Addressing Modes:
HEX
BYTES
CYCLES
bbb
4A
1
2
010
4E
3
6
011
46
2
5
001
AA
5E
3
7
111
7*ytA
56-:
2
6
101
AAA
Flags:
N V B D I 2 C
0| • •
158
Instruction Codes:
6502 INSTRUCTION SET
ACCUMULATOR
ABSOLUTE
01010110
bbb=010
bbb=011
HEX=4A CYCLES = 2
01011110
— -1
ADDRESS
HEX= 4E CYCLES = 6
ZERO-PAGE 01001110 ADDR
bbb=001 HEX =46 CYCLES =5
ABSOLUTE, X 01111110 ADDRESS
bbb = 1 HEX=5E CYCLES =7
ZERO-PAGE, X 01101110 ADDR
bbb=101 HEX = 56 CYCLES = 6
159
PROGRAAAMING THE 6502
NOP No operation
Function:
None
Format: 11101010
Description:
Does nothing for 2 cycles. May be used to time a delay loop or to
fill patches in a program.
Addressing Mode:
Implied only:
HEX = EA, byte = 1, cycles = 2
Flags:
N V B D 1 Z c
(NO ACTION)
160
6502 INSTRUCTION SET
ORA
Function:
A^- (A) V DATA
Format:
Inclusive OR with accumulator
OOObbbOl ADDR/DATA
Description:
Performs the logical (inclusive) OR of A and the specified data.
The result is stored in A. May be used to force a "1" at selected bit
locations.
Truth table:
Data Paths:
0
1
0
0
1
1
1
1
Addressing Modes:
00
3
4
011
05
2
3
001
09
2
2
010
ID
3
4*
111
19
3
4*
110
01
2
6
000
11
2
5*
100
15
2
4
101
•: PLUS 1 CYCLE IF CROSSING PAGE BOUNDARY.
Flags:
N
•
V B
1
0 1 z
•
c
161
PROGRAMMING THE 6502
Instruction Codes:
ABSOLUTE 00001101
bbb=011
00000101
bbb=001
IMMEDIATE 00001001
bbb=010
bbb= 110
(IND, X)
(IND),Y
ZERO-PAGE, X
00000001
bbb=OOO
00010001
bbb=100
00010101
bbb= 101
16-BIT ADDRESS
I
HEX=0D CYCLES = 4
ADDR
HEX= 05 CYCLES = 3
DATA
HEX =09 CYCLES =2
ABSOLUTE, X
ABSOLUTE, Y
00011101
bbb=111
00011001
16-BIT
HEX=1D
16-BIT
I
ADDRESS
CYCLES =
1
ADDRESS
4*
HEX =19 CYCLES = 4*
HEX =01 CYCLES =6
HEX=11 CYCLES =5*
ADDR
HEX =15 CYCLES = 4
•: PLUS 1 CYCLE IF CROSSING PAGE BOUNDARY.
162
6502 INSTRUCTION SET
PHA
Function:
STACKS- (A)
Push A
Format: 01001000
Description:
The contents of the accumulator are pushed on the stack. The
stack pointer is updated. A is unchanged.
Data Path:
mm®
I
1
+
STACK^1
Addressing Mode:
Implied only:
HEX = 48, byte = 1, cycles = 3
Flags:
N V B 0 1 Z c
(NO EFFECT)
163
PROGRAMMING THE 6502
PHP
Function:
STACKS- (P)
Push processor status
Format: 00001000
Description:
The contents of the status register P are pushed on the stack.
The stack pointer is updated. A is unchanged.
Data Path:
Addressing Mode:
Implied only
Hex = 08, byte = 1, cycles= 3
Flags:
N V B D 1 z C
(NO EFFECT)
164
6502 INSTRUCTION SET
PLA
Function:
A^- (STACK)
S^- (S) +1
Pull accumulator
Format: 01101000
Description:
Pop the top word of the stack into the accumulator. Increment
the stack pointer.
Data Paths:
Addressing Mode:
Implied only:
HEX = 68, byte = 1, cycles = 4
Flags:
N V B D I Z C
165
PROGRAMMING THE 6502
PLP
Function:
P^- (STACK)
Pull processor status from stack
Format: 00101000
Description:
The top word of the stack is popped (transferred) into the status
register P. The stack pointer is incremented.
Data Paths:
Addressing Mode:
Implied only:
HEX = 28, byte = 1, cycles = 4
Flags:
N V B D 1 Z c
166
6502 INSTRUCTION SET
ROL
Function:
Rotate left one bit
6 5 i\ 3
C
2 1 0
Format: OOlbbbiO ADDR
1
ADDR I
Description:
The contents of the specified address (accumulator or memory)
are rotated left by one position. The carry goes into bit 0. Bit 7
sets the new value of the carry. This is a 9-bit rotation.
Data Paths:
Addressing Modes:
HEX
BYTES
CYCLES
bbb
M
2A
1
2
010
7*
2E
3
6
011
f/f///i/'/f/t/f/f/f/t/
26
2
5
001
3E
3
7
111
36
2
6
101
Flags:
N
•
V B D 1 Z
•
C
•
167
PROGRAAAMING THE 6502
Instruction Codes:
ACCUMULATOR
ABSOLUTE
ZERO-PAGE
ABSOLUTE, X
ZERO-PAGE, X
00101010
bbb=010
00101110
bbb=011
00100110
bbb=001
00111110
bbb = lll
00110110
bbb = 101
HEX=2A CYCLES=2
16 BIT-ADDRESS
i
HEX=2E CYCLES =6
ADDR
HEX =26 CYCLES =5
16BIT-AI)DRESS
HEX = 3E CYCLES = 7
ADDR
HEX =36 CYCLES = 6
168
6502 INSTRUCTION SET
ROR Rotate right one bit
Warning: This instruction may not be available on older 6502's;
also, it may exist but not be listed.
Function:
7 6 5 4 3
C
2 1 0
Format: OlibbblO ADDR
Description:
The contents of the specified address (accumulator or memory)
are rotated right by one bit position. The carry goes into bit 7. Bit 0
sets the new value of the carry. This is a 9-bit rotation.
Data Paths:
Addressing Modes:
HEX
BYTES
CYCIES
bbb
/'A
6A
1
2
010
'A
6E
3
6
011
'/'A
66
2
5
001
*/t/*/*/i/f/f/f/t/
71
3
7
111
76
2
6
101
Flags:
N
•
V B D 1 Z
•
c
•
169
PROGRAMMING THE 6502
Instruction Codes:
ACCUMULATOR
ABSOLUTE
ZERO-PAGE
ABSOLUTE, X
ZERO-PAGE, X
01101010
bbb=010
bbb=011
bbb=001
bbb = 111
HEX=6A CYCLES=2
01101110 16 BIT-ADDRESS
I
HEX=6E
01100110 ADDR
HEX= 66
CYCLES =6
CYCLES =5
01111110 16 BIT-ADDRESS
HEX= 7E
01110110 ADDR
bbb =101 HEX= 76
CYCLES =7
CYCLES =6
170
6502 INSTRUCTION SET
RTI
Function:
P ^- (STACK)
S -«-(S)+l
PCL -«- (STACK)
S ««-(S)+l
PCH -*- (STACK)
S ^-(S)+l
Return from interrupt
Format: 01000000
Description:
Restore the status register P and the program counter (PC)
which had been saved in the stack. Adjust the stack pointer.
Data Paths:
Addressing Mode:
Implied only:
HEX = 40, byte = 1, cycles = 6
Flags:
N V B D 1 Z c
171
PROGRAMMING THE 6502
RTS
Function:
PCL^-(STACK)
S -«-(S)+l
PCH-«- (STACK)
S ^-(S)+l
PC -*-(PC + 1)
Return from subroutine
Format: 01100000
Description:
Restore the program counter from the stack and increment it
by one. Adjust the stack pointer.
Data Paths:
PC Jr PCL
PCH
Addressing Mode:
Implied only:
HEX = 60, byte = 1, cycles = 6
Flags:
N V B D 1 z c
(NO EFFECT)
172
6502 INSTRUCTION SET
SBC Subtract with carry
Function:
A^- (A) -DATA -C (C is borrow)
Format: lllbbbOl
Description:
Subtract from the accumulator the data at the specified ad
dress, with borrow. The result is left in A. Note: SEC is used for a
subtract without borrow.
SBC may be used in decimal or binary mode, depending on bit
D of the status register.
Addressing Modes:
HEX
BYTES
CYCLES
bbb
ED
3
4
Oil
*/*
E5
2
3
001
E9
2
2
010
FD
3
4*
111
F9
3
4*
110
El
2
6
000
F1
2
5*
100
</i/iA
F5
2
4
101
*: PLUS 1 CYCLE IF CROSSING PAGE BOUNDARY.
Flags:
173
PROGRAMMING THE 6502
Instruction Codes:
ABSOLUTE 11101101
bbb=011
16-BIT ADDRESS
HEX = ED CYCLES =4
bbb=010
ZERO-PAGE
IMMEDIATE
11100101
bbb-=001
11101001
ADDR
HEX = E5
DATA
HEX=E9 CYCLES = 2
bbb=110
ABSOLUTE
ABSOLUTE,
X
Y
11111101
bbb = 111
11111001
HEX -
16-BIT
-w
16-BIT
1
1
ADDRESS
CYCLES =
ADDRESS
4*
HEX=F9 CYCLES = 4*
(IND, X)
(IND),Y
ZERO-PAGE, X
11100001
bbb = 000
11110001
bbb ^100
11110101
ADDR
HEX-El
ADDR
HEX= F1
ADDR
CYCLES = 6
bbb= 101 HEX=F5 CYCLES =4
*: PLUS 1 CYCLE IF CROSSING PAGE BOUNDARY.
174
6502 INSTRUCTION SET
SEC
Function:
Set carry
Format: 00111000
Description:
The carry bit is set to 1. This is used prior to an SBC to perform
a subtract without carry.
Addressing Modes:
Implied only:
HEX = 38, byte = 1, cycles= 2
Flags: N V B D 1 Z C
1
175
PROGRAMMING THE 6502
SED
Function:
Set decimal mode
Format:
11111000
Description:
The decimal bit of the status register is set to 1. When it is 0,
the mode is binary. When it is 1, the mode is decimal for ADC and
SBC.
Addressing Modes:
Implied only:
HEX = F8, byte = 1, cycles = 2
Flags: N V B D
1
I Z c
176
6502 INSTRUCTION SET
SEI
Function:
Format:
Set interrupt disable
01111000
Description:
The interrupt mask is set to 1. Used during an interrupt or a system
reset.
Addressing Modes:
Implied only:
HEX = 78, byte = 1, cycles = 2
Flags: N V B D 1
1
2 C
177
PROGRAMMING THE 6502
STA
Function:
M^-(A)
Format:
Store accumulator in memory
lOObbbOl ADDRESS
Description:
The contents of A are copied at the specified memory location.
The contents of A are not changed.
Data Paths:
Addressing Modes:
HEX
BYTES
CYCIES
bbb
80
3
4
Oil
ft///'
85
2
3
001
90
3
111
yr/i
99
3
110
81
2
000
W////////
91
2
100
95
2
101
Flags:
N V
1
B 0 1 Z c
(NO EFFECT)
178
Instruction Codes:
6502 INSTRUCTION SET
ABSOLUTE 10001101
bbb=011
ZERO-PAGE 10000101
bbb= 001
bbb=110
bbb= 101
16-BIT ADDRESS
I
HEX=8D CYCLES = 4
ADDR
HEX= 85 CYCLES = 3
(IND, X)
(IND),Y
ZERO-PAGE, X
10000001
bbb = 000
10010001
bbb= 100
10010101
ADDR
HEX =81
ADDR
HEX = 91
ADDR
HEX= 99 CYCLES = 5
CYCLES = 6
CYCLES- 6
HEX =95 CYCLES =4
ABSOLUTE,
ABSOLUTE,
X
Y
10011101
bbb=lll
10011001
16-BIT
HEX = 9D
16-BIT
ADDRESS
CYCLES =5
ADDRESS
_J .
179
PROGRAMMING THE 6502
STX
Function:
M«*-(X)
Format:
Store X in memory
lOObbllO ADDRESS
Description:
Copy the contents of index register X at the specified memory
location. The contents of X are left unchanged.
Data Paths:
AA
Addressing Modes:
Flags:
Instruction Codes:
N V B D 1 2 C
(NO EFFEa)
ABSOLUTE
ZEROPAGE
ZERO PAGE. V
.bb
bb
100011
=01
10000
=00
100101
10
10
0
HEX = BE
A00R
HEX-66
ADDR
ADORE SS
CYCLES
CYCLES
<
3
HfX
BY1F5
CYCIE5
hi*
Mft
8£
3
4
01
'/f/Z/t/t/f/i/f/f/f/t/
86
2
3
00
96
2
4
10
180
6502 INSTRUCTION SET
STY
Function:
M^-(Y)
Format:
Store Y in memory
lOObblOO ADDRESS
Description:
Copy the contents of index register Y at the specified memory
location. The contents of Y are left unchanged.
Data Paths:
wwm<mWy<
Addressing Modes:
HEX
BYTES
CYCLES
bb
8C
3
4
01
84
2
3
00
94
2
4
10
Flags: N V B 0 1 Z c
(NO EFFECT)
Instruction Codes:
ABSOIUIE
ZERO-PAGE
ZERO-PAGE. X
bb
bb
10001100
=01
10000100
=00
10010100
hex* ec
ADDR
HEX " 84
ADDR
ADDRESS
CVCIES= 4
CYCIES= 3
M!X= 94 CVCIES"
181
PROGRAMMING THE 6502
TAX
Function:
X^-(A)
Format:
Transfer accumulator into X
10101010
Description:
Copy the contents of the accumulator into index register X. The
contents of A are left unchanged.
Data Paths:
Addressing Mode:
Implied only:
HEX = AA, byte = 1, cycles = 2
Flags:
N
•
V B D 1 2
•
C
182
TAY
6502 INSTRUCTION SET
Transfer accumulator into Y
Function:
Format: j 10101000 |
Description:
Transfer the contents of the accumulator into index register Y.
The contents of A are left unchanged.
Data Paths:
Addressing Mode
Implied only:
HEX = A8, byte = 1, cycles = 2
Flags:
N
•
V B D 1 z
•
C
183
PROGRAMMING THE 6502
TSX
Function:
X^-(S)
Format:
Transfer S into X
10111010
Description:
The contents of the stack pointer S are transferred into index
register X. The contents of S are unchanged.
Data Paths:
Addressing Mode:
Implied only:
HEX = BA, byte = 1, cycles = 2
Flags:
N
•
V B D 1 Z
•
c
184
6502 INSTRUCTION SET
TXA
Function:
A^-(X)
Transfer X into accumulator
Format: | 10001010 [
Description:
The contents of index register X are transferred into the ac
cumulator. The contents of X are unchanged.
Data Paths:
Addressing Mode:
Implied only:
HEX = 8A, byte = 1, cycles = 2
Flags:
N
•
V B D 1 Z
•
C
185
PROGRAMMING THE 6502
TXS
Function:
Transfer X into S
Format: 10011010
Description:
The contents of index register S are transferred into the stack
pointer. The contents of X are unchanged.
Data Paths:
Addressing Mode:
Implied only:
HEX = 9A, byte = 1, cycles = 2
Flags:
N V B D 1 Z c
(NO ACTION)
186
6502 INSTRUCTION SET
TYA Transfer Y into A
Function:
A^-(Y)
Format: [ 10011000 |
Description:
The contents of index register Y are transferred into the ac
cumulator. The contents of Y are unchanged.
Data Paths:
Addressing Mode:
Implied only:
HEX = 98, byte = 1, cycles = 2
Flags:
N
•
V B D 1 Z
•
c
187
5
ADDRESSING TECHNIQUES
INTRODUCTION
This chapter will present the general theory of addressing, with
the various techniques which have been developed to facilitate
the retrieval of data. In a second section, the specific addressing
modes which are available in the 6502 will be reviewed, along
with their advantages and limitations, where they exist. Finally,
in order to familiarize the reader with the various trade-offs pos
sible, an applications section will show possible trade-offs be
tween the various addressing techniques by studying specific ap
plication programs.
Because the 6502 has no 16-bit register, other than the program
counter, which can be used to specify an address, it is necessary
that the 6502 user understand the various addressing modes, and
in particular, the use of the index registers. Complex retrieval
modes, such as a combination of indirect and indexed, may be
omitted at the beginning stage. However, all the addressing
modes are useful in developing programs for this micro
processor. Let us now study the various alternatives available.
ADDRESSING MODES
Addressing refers to the specification, within an instruction, of
the location of the operand on which the instruction will operate.
The main methods will now be examined.
188
ADDRESSING TECHNIQUES
IMPLICIT/IMPLIED
IMMEDIATE
DIRECT/SHORT
ENDED/ABSOLUTE
INDEXED
•
r
i
OPCODE A 1 R
OPCODE
LITERAL
LITERAL |
- -J
OPCODE
SHORT ADDRESS
OPCODE
FULL 16-BIT
ADDRESS
OPCODE X REG
DISPLACEMENT
OR ADDRESS |
_ J
Rg. 5-1: Addressing
189
PROGRAMMING THE 6502
Implicit Addressing
Instructions which operate exclusively on registers normally
use implicit addressing. This is illustrated in Figure 5-1. An im
plicit instruction derives its name from the fact that it does not
specifically contain the address of the operand on which it oper
ates. Instead, its opcode specifies one or more registers, usually
the accumulator, or else any other register(s). Since internal reg
isters are usually few in number (say a maximum of 8), this will
require a small number of bits. As an example, three bits within
the instruction will point to 1 out of 8 internal registers. Such in
structions can, therefore, normally be encoded within 8 bits. This
is an important advantage, since an 8-bit instruction normally
executes faster than any two- or three-byte instruction.
An example of an implicit instruction for the 6502 is TAX which
specifies "transfer the contents of A to X."
Immediate Addressing
Immediate addressing is illustrated in Figure 5-1. The 8-bit
opcode is followed by an 8- or a 16-bit literal (a constant). This
type of instruction id needed, for example, to load an 8-bit value
to an 8-bit register. If the microprocessor is equipped with 16-bit
registers, it may be necessary to load 16-bit literals. This depends
upon the internal architecture of the processor. An example of an
immediate instruction is ADC #0.
The second word of this instruction contains the literal "0",
which is added to the accumulator.
Absolute Addressing
Absolute addressing refers to the way in which data is usually
retrieved from memory, where an opcode is followed by a 16-bit
address. Absolute addressing, therefore, requires 3-byte instruc
tions. An example of absolute addressing is STA \$1234.
It specifies that the contents of the accumulator are to be stored
at the memory location'' 1234'' hexadecimal.
The disadvantage of absolute addressing is to require a 3-byte
instruction. In order to improve the efficiency of the microproces
sor, another addressing mode may be made available, where only
one word is used for the address: direct addressing.
190
ADDRESSING TECHNIQUES
Direct Addressing
In this addressing mode, the opcode is followed by an 8-bit
address. This is illustrated in Figure 5-1. The advantage of this
approach is to require only 2 bytes instead of 3 for absolute ad
dressing. The disadvantage is to limit all addressing within this
mode to addresses 0 to 255. This is page 0. This is also called
short addressing, or 0-page addressing. Whenever short addressing
is available, absolute addressing is often called extended addressing
by contrast.
Relative Addressing
Normal jump or branch instructions require 8 bits for the op
code, plus the 16-bit address which is the address to which the
program has to jump. Just as in the preceding example, this has
the inconvenience of requiring 3 words, i.e., 3 memory cycles. To
provide more efficient branching, relative addressing uses only a
two-word format. The first word is the branch specification,
usually along with the test it is implementing. The second word is
a displacement. Since the displacement must be positive or nega
tive, a relative branching instruction allows a branch forward to
128 locations (7-bits) or a branch backwards to 128 locations (plus
or minus 1, depending on the conventions). Because most loops
tend to be short, relative branching can be used most of the time
and results in significantly improved performance for such short
routines. As an example, we have already used the instruction
BCC, which specifies a "branch on carry clear" to a location
within 127 words of the branch instruction.
Indexed Addressing
Indexed addressing is a technique specifically useful to access
successively the elements of a block or of a table. This will be
illustrated by examples later in this chapter. The principle of
indexed addressing is that the instruction specifies both an index
register and an address. In the most general scheme, the contents
of the register are added to the address to provide the final ad
dress. In this way, the address could be the beginning of a table in
the memory. The index register would then be used to access
successively all the elements of the table in an efficient way. In
practice, restrictions often exist and may limit the size of the
191
PROGRAMMING THE 6502
index register, or the size of the address or displacement field.
Pre-indexing and Post-indexing
Two modes of indexing may be distinguished. Pre-indexing is
the usual indexing mode where the final address is the sum of a
displacement or address and the contents of the index register.
Post-indexing treats the contents of the displacement field like
the address of the actual displacement, rather than the displace
ment itself. This is illustrated in Figure 5-2. In post-indexing, the
final address is the sum of the contents of the index register plus
the contents of the memory word designated by the displacement
field. This feature utilizes, in fact, a combination of indirect ad
dressing and pre-indexing. But we have not defined indirect ad
dressing yet, so let us do that now.
PAGE ZERO Y (index)
OPCODE
SHORT ADDRESS
POI
^
NTER=BASE
MEMORY
DATAN
N
FINAL
A
16-BIT
DDRESS
Is
•■ )
J
Fig. 5-2: Indirect Post-Indexed Addressing
192
ADDRESSING TECHNIQUES
Indirect Addressing
We have already seen the case where two subroutines may wish
to exchange a large quantity of data stored in the memory. More
generally, several programs, or several subroutines, may need ac
cess to a common block of information. To preserve the generality
of the program, it is desirable not to keep such a block at a fixed
memory location. In particular, the size of this block might grow
or shrink dynamically, and it may have to reside in various
areas of the memory, depending on its size. It would, therefore,
be impractical to try to have access to this block using absolute
addresses.
The solution to this problem lies in depositing the starting ad
dress of the block at a fixed memory location. This is analogous
to a situation in which several persons need to get into a house,
INSTRUCTION MEMORY
OPCODE
INDIRECT
ADDRESS A.
(A.)
-
FINAL
ADDRESS (A2)
DATA
Rg. 5-3: Indirect Addressing
193
PROGRAMMING THE 6502
and only one key exists. By convention, the key to the house
will be hidden under the mat. Every user will then know where to
look (under the mat) to find the key to the house (or, perhaps, to
find the address of a scheduled meeting, to have a more correct
analogy). Indirect addressing, therefore, uses an 8-bit opcode fol
lowed by a 16-bit address. Simply, this address is used to retrieve
a word from the memory. Normally, it will be a 16-bit word (in our
case, two bytes) within the memory. This is illustrated by Figure
5-3. The two bytes at the specified address, Al, contain A2. A2 is
then interpreted as the actual address of the data that one wishes
to access.
Indirect addressing is particularly useful any time that pointers
are used. Various areas of the program can then refer to these
pointers to access conveniently and elegantly a word or a block of
data.
Combinations of Modes
The above addressing modes may be combined. In particular, it
should be possible in a completely general addressing scheme to
use many levels of indirection. The address A2 could be inter
preted as an indirect address again, and so on.
Indexed addressing can also be combined with indirect access.
That allows the efficient access to word n of a block of data, pro
vided one knows where the pointer to the starting address is.
We have now become familiar with all usual addressing modes
that can be provided in a system. Most microprocessor systems,
because of the limitation on the complexity of an MPU, which
must be realized within a single chip, do not provide all possible
modes but only a small subset of these. The 6502 provides an
unusually large subset of possibilities. Let us examine them now.
6502 ADDRESSING MODES
Implied Addressing (6502)
Implied addressing is used by a single byte instruction which
operates on internal registers. Whenever implicit instructions
operate exclusively in internal registers, they require only two
clock cycles to execute. Whenever they access memory, they re
quire three cycles.
Instructions which operate exclusively inside the 6502
194
ADDRESSING TECHNIQUES
are: CLC, CLD, CLI, CLV, DEX, DEY, INX, INY, NOP, SEC, SED?
SEI, TAX, TAY, TSX, TXA, TXS, TYA.
Instructions which require memory access are: BRK, PHA,
PHP, PLA, PLP, RTI, RTS.
These instructions have been described in the preceding chap
ter, and their mode of operation should be clear.
Immediate Addressing (6502)
Since the 6502 has only 8-bit working registers (the PC is not a
working register), immediate addressing in the case of the 6502 is
limited to 8-bit constants. All instructions in immediate addressing
mode are, therefore, two bytes in length. The first byte contains
the opcode, and the second byte contains the constant or literal
which is to be loaded in a register or used in conjunction with one
of the registers for an arithmetic or logical operation.
Instructions using this addressing mode are: ADC, AND, CMP,
CPX, CPY, EOR, LDA, LDX, LDY, ORA, SBC.
Absolute Addressing (6502)
By definition, absolute addressing requires three bytes. The
first byte is the opcode and the next two bytes are the 16-bit
address specifying the location of the operand. Except in the case
of a jump absolute, this address mode requires four cycles.
Instructions which may use absolute addressing are: ADC,
AND, ASL, BIT, CMP, CPX, CPY, DEC, EOR, INC, JMP, JSR,
LDA, LDX, LDY, LSR, ORA, ROL, ROR, SBC, STA, STX, STY.
Zero-Page Addressing (6502)
By definition zero-page addressing requires two bytes: the first
one is for the opcode; the second one is for the 8-bit, or short
address.
Zero-page addressing requires three cycles. Because zero-page
addressing offers significant speed advantages as well as shorter
code, it should be used whenever possible. This requires careful
memory management by the programmer. Generally speaking,
the first 256 locations of memory may be viewed as the set of
working registers for the 6502. Any instruction will essentially
execute on these 256 "registers" in just three cycles. This space
should, therefore, be carefully reserved for essential data that
195
PROGRAMMING THE 6502
needs to be retrieved at high speed.
Instructions which can use zero-page addressing are those
which can use absolute addressing, except for JMP and JSR
(which require a 16-bit address).
The list of legal instructions is: ADC, AND, ASL, BIT, CMP,
CPX, CPY, DEC, EOR, INC, LDA, LDX, LDY, LSR, ORA,
ROL, ROR, SBC, STA, STX, STY.
Relative Addressing (6502)
By definition, relative addressing uses two bytes. The first one
is a jump instruction, whereas the second one specifies the dis
placement and its sign. In order to differentiate this mode from
the jump instruction, they are here labeled branches. Branches,
in the case of the 6502, always use the relative mode. Jumps
always use the absolute mode (plus, naturally, the other submodes
which may be combined with those, such as indexed and
indirect). From a timing standpoint, this instruction should be
examined with caution. Whenever a test fails, i.e., whenever there
is no branch, this instruction requires only two cycles. This is be
cause the next instruction to be executed is pointed to by the pro
gram counter. However, whenever the test succeeds, i.e., whenever
the branch must take place this instruction requires three cycles: a
new effective address must be computed. The updating of the
program counter requires an extra cycle. However, if a branch
occurs through a page boundary, one more updating is necessary
for the program counter, and the effective length of the instruc
tion becomes four cycles.
From a logical standpoint, the user does not need to worry about
crossing a page boundary. The hardware takes care of it. However,
because an extra carry or borrow is generated whenever one crosses
a page boundary, the execution time of the branch will be changed.
If this branch was part of an exact timing loop, caution must be
exercised.
A good assembler will normally tell the programmer at the
time the program is assembled that a branch is crossing a page
boundary, in case timing might be critical.
Whenever one is not sure whether the branch will succeed, one
must take into consideration the fact that sometimes the branch
196
ADDRESSING TECHNIQUES
will require two cycles, and sometimes three. Often an average
time is computed.
The only instructions which implement relative addressing are the
branch instructions. There are 8 branch instructions which test flags
within the status register for value "0" or "1". The list is: BCC,
BCS, BEQ, BMI, BNE, BPL, BVC, BVS.
Indexed Addressing (6502)
The 6502 does not provide a completely general capability, but
only a limited one. It is equipped with two index registers. How
ever, these registers are limited to 8 bits. The contents of an index
register are added to the address field of the instruction. Usually,
the index register is used as a counter in order to access ele
ments of a block or a table successively. This is why specialized
instructions are available to increment or decrement each one of
the index registers separately. In addition, two specialized in
structions exist to compare the contents of the index registers
against a memory location, an important facility for the effective
use of the index registers to test against limits.
In practice, because most user tables are normally shorter than
256 words, the limitation of the index registers to 8 bits is usually
not a significant limitation.
The indexed addressing mode can be used not only with regular
absolute addressing, i.e., with 16-bit address fields, but also with
the zero-page addressing mode, i.e., with 8-bit address fields.
There is only one restriction. Register X can be used with both
types of addressing. However, register Y allows only absolute in
dexed addressing and not zero-page indexed addressing (except for
LDX and STX instructions, which can be modified by register Y).
Absolute indexed addressing will require four cycles, unless the
page boundary is being crossed, in which case five cycles will be
required.
Absolute indexed instructions can use either registers X or Y to
provide the displacement field. The list of instructions which may
use this mode are:
- with X: ADC, AND, ASL, CMP, DEC, EOR, INC, LDA, LDY,
LSR, ORA, ROL, ROR, SBC, STA, (not STY).
197
PROGRAMMING THE 6502
-with Y: ADC, AND, CMP, EOR, LDA, LDX, ORA, SBC, STA
(not ASL, DEC, LSR, ROL, ROR).
In the case of zero-page indexed addressing, register X is the
legal displacement register, except for LDX and STX. Legal in
structions are: ADC, AND, ASL, CMP, DEC, EOR, INC, LDA,
LDY, LSR, ORA, ROL, ROR, SBC, STA, STY.
Indirect Addressing (6502)
The 6502 does not have a fully general indirect addressing
capability. It restricts the address field to 8 bits. In other words,
all indirect addressing uses the sub-mode of zero page addressing.
The effective address on which the opcode is to operate is then the
16 bits specified by the zero-page address of the instruction. Also,
no further indirection may occur. This means that an address
retrieved from page zero must be used as is, and cannot be used as
a further indirection.
Finally, all indirect accesses must be indexed, except for JMP.
For fairness, it should be noted that very few microprocessors
provide any indirect addressing at all. Further, it is possible to
implement a more general indirect addressing using a macro
definition.
Two modes of indirect addressing are possible: (pre) indexed indirect
addressing, and indirect indexed addressing (post-indexed), except
with JMP, which uses pure indirect.
Indexed Indirect Addressing
This mode adds the contents of index register X to the zero-page
address to retrieve the final 16-bit address. This is an efficient way to
retrieve one of several possible data pointed to by pointers whose
number is contained in index register X. This is illustrated in Figure
5-4.
In this illustration, page zero contains a table of pointers. The
first pointer is at the address A, which is part of the instruction. If
the contents of X are 2N, then this instruction will access pointer
number N of this table and retrieve the data it is pointing to.
Indexed indirect addressing requires 6 cycles. It is naturally
less efficient time-wise than any direct addressing mode. Its ad
vantage is the flexibility which may result in coding, or the overall
speed improvement.
198
ADDRESSING TECHNIQUES
OPCOOE(X)
2N
/
\
ADDRESS A
1
ENTRY* N
= 16 BIT ADDRESS
REST Of
MEMORY
Fig. 5-4: Pre-lndexed Indirect Addressing
Permissible instructions are: ADC, AND, CMP, EOR, LDA,
ORA, SBC, STA.
Indirect Indexed Addressing
This corresponds to the post-indexing mechanism which has
been described in the preceding section. There, the indexing is
performed after the indirection, rather than before. In other
words, the short address which is part of the instructions is used
to access a 16-bit pointer in page zero. The contents of index
register Y are then added as a displacement to this pointer. The
final data are then retrieved, (see Fig. 5-2.)
In this case, the pointer contained in page zero indicates the
base of a table in the memory. Index register Y provides a dis
placement. It is a true index within a table. This instruction is
particularly powerful for referring to the nth element of a table,
provided that the start address of the table is saved in page zero.
199
PROGRAMMING THE 6502
It can do so in just two bytes.
Legal instructions are: ADC, AND, CMP, EOR, LDA, ORA, SBC,
STA.
Exception: Jump Instruction.
The jump instruction may use indirect absolute. It is the only
instruction that may use this mode.
USING THE 6502 ADDRESSING MODES
Long and Short Addressing
We have already used branch instructions in various programs
that we have developed. They are self explanatory. One interest
ing question is: what can we do if the permissible range for
branching is not sufficient for our needs? One simple solution is to
use a so-called long branch. This is simply a branch to a location
which contains a jump specification:
BCC +3 BRANCH TO CURRENT ADDRESS
+3 IF C CLEAR
JMP FAR OTHERWISE JUMP TO FAR
(NEXT INSTRUCTION)
The two-line program above will result in branching to location
FAR whenever the carry is set. This solves our long branch
problem. Let us therefore now consider the more complex addres
sing modes, i.e. indexing and indirection.
Use of indexing for sequential block accesses
Indexing is primarily used to address successive locations
within a table. The restriction is that the maximum displacement
must be less than 256 so that it can reside in an 8-bit index
register.
We have learned to check for the character f*\ Now we will
search a table of 100 elements for the presence of a **\ The start
ing address for this table is called BASE. The table has only 100
elements. It is less than 256 and we can use an index register. The
program appears below:
200
ADDRESSING TECHNIQUES
SEARCH
NEXT
NOTFOUND
STARFOUND
LDX
LDA
CMP
BEQ
INX
CPX
BNE
...
#0
BASE, X
r*
STARFOUND
#100
NEXT
The flowchart for this program appears in Figure 5-5. The equiva
lence between the flowchart and the program should be verified.
The logic of the program is quite simple. Register X is used to
point to the element within the table. The second instruction of
the program:
NEXT LDA BASE, X
uses absolute indexed addressing. It specifies that the accumu
lator is to be loaded from the address BASE (16-bit absolute ad
dress) plus contents of X. At the beginning, the contents of X are
"0." The first element to be accessed will be the one at address
BASE. It can be seen that after the next iteration, X will have the
value "1," and the next sequential element of the table will be
accessed, at address BASE + 1.
The third instruction of the program, CMP #'* compares the value
of the character which has been read in the accumulator with the code
for "*." The next instruction tests the results of the comparison. If a
match has been found, the branch occurs to the label STARFOUND:
BEQ STARFOUND
Otherwise, the next sequential instruction is executed:
INX
201
PROGRAMMING THE 6502
The index counter is incremented by 1. We find by inspecting the
bottom of the flow-chart of Figure 5.5 that the value of our index
register at this point must be checked to make sure that we are
not going beyond the bounds of the table (here 100 elements).
This is implemented by the following instruction:
CPX #100
INITIALIZE
TO ELEMENT 0
READ NEXT
ELEMENT
YES
STARFOUND
POINT TO
NEXT ELEMENT
NO
LAST ELEMENT?
NOT FOUND
Fig. 5-5: Character Searching Table
This instruction compares register X to the value \$100. If the test
fails we must again fetch the next character. This is what occurs
with:
BNENEXT
This instruction specifies a branch to the label NEXT if the test
has failed (the second instruction in our program). This loop will
be executed as long as a "*" is not found, or as long as the value
"100" is not reached in the index. Then the next sequential in-
202
ADDRESSING TECHNIQUES
struction to be executed will be "NOT FOUND". It corresponds to
the case where a "*" has not been found.
The actions taken for "*" found and not found are irrelevant
here and would be specified by the programmer.
We have learned to use the indexed addressing mode to
access successive elements in a table. Let us now use this new
skill and slightly increase the difficulty. We will develop an im
portant utility program, capable of copying a block from one area
of the memory into another. We will initially assume that the
number of the elements within the block is less than 256 so that
we can use index register X. Then we will consider the general
case where the number of elements in the block is greater than
256.
A Block Transfer Routinefor less than 256 elements
We will call "NUMBER" the number of elements in the block to
be moved. , The number is assumed to be less than 256. BASE is
the base address of the block. DESTINATION is the base of the
memory area where it should be moved. The algorithm is quite simple:
we will move a word at a time, keeping track of which word we are
moving by storing its position in index register X. The program
appears below:
NEXT
Let us examine it:
LDX*
LDX
LDA
STA
DEX
BNE
#NUMBER
BASE, X
DEST.X
NEXT
t NUMBER
This line of the program loads the number N of words to be trans
ferred in the index register. The next instruction loads word #N of
the block within the accumulator and the third instruction depo
sits it into the destination area. See Figure 5-6.
CAUTION: this program will work correctly only if the base
pointer is assumed to point just below the block, just like the
destination register. Otherwise a small adjustment to this
program is needed.
203
PROGRAMMING THE 6502
After a word has been transferred from the origin to the desti
nation area, the index register must be updated. This is per
formed by the instruction DEX, which decrements it. Then the
program simply tests whether X has decremented to O. If so, the
program terminates. Otherwise, it loops again by going bade to
location NEXT.
You will notice that when X = 0, the program does not loop.
Therefore, it will not transfer the word at location BASE. The last
word to be transferred will be at BASE+1. This is why we have
assumed that the base was just below the block.
Exercise 5.1: Modify the program above, assuming that
BASE and DEST point to the first entry in the block.
This program also illustrates the use of loop counters. You will
notice that X has been loaded with the final value, then decre
mented and tested. At first sight, it might seem simpler to start
with "0" in X, and then increment it until it reaches the maxi
mum value. However, in order to test whether X has attained its
maximum value, one extra instruction would be needed (the com
parison instruction). This loop would then require 5 instructions
instead of 4. Since this transfer program will normally be used for
large numbers of words, it is important to reduce the number of
instructions for the loop. This is why, at least for short loops, the
index register is normally decremented rather than incremented.
A Block Transfer Routine (more than 256 elements)
Let us now consider the general case of moving a block which
may contain more than 256 elements. We can no longer use a
single index register as 8 bits do not suffice to store a number
greater than 256. The memory organization for this program is
illustrated in Figure 5-7. The length of the memory-block to be
transferred requires 16 bits, and therefore is stored in memory.
The high-order part represents the number of 256-word blocks:
"BLOCKS". The rest is called "REMAIN" and is the number of
words to be transferred after all the blocks have been transferred.
The address for the source and the destination will be memory
locations FROM and TO. Let us first assume that REMAIN is
204
ADDRESSING TECHNIQUES
i SOURCE BLOCK
i DESTINATION BLOCK
Fig. 5-6: Memory Organization for Block Transfer
FROM-*-
TO ■
MEMORY
y//y//////////////////
^DEPARTURE AREA #\%
Fig. 5-7: Memory Map for General Block Transfer
205
PROGRAMMING THE 6502
zero, i.e., that we are transferring 256 word blocks. The program
appears below:
LDA #SOURCELO
STA FROM
LDA #SOURCEHI
STA FROM+1 STORE SOURCE ADDRESS
LDA #DESTLO
STA TO
LDA #DESTHI
STA TO+1 STORE DEST ADDRESS
LDX #BLOCKS HOW MANY BLOCKS
LDY #0 BLOCK SIZE
NEXT LDA (FROM), Y READ ELEMENT
STA (TO), Y TRANSFER IT
DEY UPDATE WORD POINTER
BNE NEXT FINISHED?
NEXBLK INC FROM+1 INCREMENT BLOCK POINTER
INC TO+1 SAME
DEX BLOCK COUNTER
BMI DONE
BNE NEXT
LDY #REMAIN
BNE NEXT
The 16-bit source address is stored by the first four instructions at
memory address "FROM." The next four instructions do the
same thing for the destination, which is stored at address "TO".
Since we have to transfer a number of words greater than 256, we
will simply use two 8-bit index registers. The next instruction
loads register X with the number of blocks to be transferred. This
is instruction 9 in the program. The next instruction loads the
value zero in index register Y in order to initialize it for the
transfer of 256 words. We will now use indexed indirect address
ing. It should be remembered that indexed indirect will result
first in an indirection within page zero, then an indexed access to
the 16-bit address specified by the index register. Look at the
program:
NEXT LDA (FROM), Y
The instruction loads the accumulator with the contents of the
memory location whose address is the source plus the index regis
ter Y's contents. Look at Figure 5-7 for the memory map. Here,
the content of register Y is initially 0. "A" will therefore be loaded
from memory address "SOURCE." Note that here, unlike in our
206
ADDRESSING TECHNIQUES
previous example, we assume that "SOURCE" is the address of
the first word within the block.
Using the same technique, the next instruction will deposit the
contents of the accumulator (the first word of the block we want to
transfer) at the appropriate destination location:
STA (TO), Y
Just as in the preceding case, we simply decrement the index
register, then we loop 256 times. This is implemented by the
next two instructions:
DEY
BNE NEXT
Caution: a programming trick is used here for compact pro
gramming. The alert reader will notice that the index register Y
is decremented. The first word to be transferred will, therefore, be
the word in position 0. The next one will be word 255. This is
because decrementing 0 yields all Ts in the register (or 255). The
reader should also ascertain that there is no error. Whenever
register Y decrements to 0, a transfer will not occur. The next
instruction to be executed will be: NEXBLK. Therefore, exactly
256 words will have been transferred. Clearly this trick could
have been used in the previous program to write a shorter pro
gram.
Once a complete block has been transferred, it is simply a mat
ter of pointing to the next page within our original block and our
destination block. This is accomplished by adding "1" to the
higher order part of the address for source and destination. This is
performed by the next two instructions in the program:
NEXBLK INC FROM+1
INC TO+1
After having incremented the page pointer, we simply check
whether or not we should transfer one more block by decrement
ing the block counter contained in X. This is performed by:
DEX
If all blocks have been transferred, we exit from the program by
branching to location DONE:
207
PROGRAMMING THE 6502
BMI DONE
Otherwise, we have two possibilities: Either we have not de
cremented to 0 or else we have exactly decremented to zero. If we
have not yet decremented to 0, we branch to location NEXT:
BNE NEXT
If we have decremented exactly to 0, we still have to transfer
the words specified by REMAIN. This is the last part of our
transfer. This is accomplished by:
LDY #REMAIN
which loads index Y with the transfer count.
We then branch back to location NEXT:
BNE NEXT
The reader should ascertain that, during this last loop where
the branch instruction to NEXT will be executed, the next time
we re-enter NEXBLK, we will, indeed, exit for good from this
program. This is because the index X had the value 0 prior to
entering NEXBLK. The third instruction of NEXBLK will
change it to -1, and we will exit to DONE.
Adding Two Blocks
This example will provide a simple illustration of the use of an
index register for the addition of two blocks of less than 256
elements. Then, the next program will make use of the indirect
indexed feature to address blocks whose address is known to re
side at the given location, but whose actual absolute address is
not known. The program appears below:
BLKADD
NEXT
LDY
CLC
LDA
ADC
STA
DEY
BPL
#NBR -1
PTR1,Y
PTR2,Y
PTR3,Y
NEXT
LOAD COUNTER
READ NEXT ELEMENT
ADD THEM
STORE RESULT
DECREMENT COUNTER
FINISHED?
Index Y is used as an index counter and is loaded with the
number of elements minus one. We assume that pointer PTR1
points to the first element of Block 1, PTR2 to the first element of
208
ADDRESSING TECHNIQUES
Block 2, and PTR3 points to the destination area where the re
sults should be stored.
The program is self-explanatory. The last element of Block 1 is
read in the accumulator, then added to the last element of Block
2. It is then stored at the appropriate location of Block 3. The next
sequential element is added, and so on.
Same Exercise Using Indexed Indirect Addressing
We assume here that the addresses PTR1, PTR2, PTR3 are not
known initially. However, we know that they are stored in Page 0
at addresses LOCI, LOC2, LOC3. This is a common mechanism
for passing information between subroutines. The corresponding
program appears below:
BLKADD LDY #NBR-1
NEXT CLC
LDA (LOCI), Y
ADC (LOC2), Y
STA (LOC3), Y
DEY
BPL NEXT
The correspondence between this new program and the previous
one should now be obvious. It illustrates clearly the use of the
indexed indirect mechanism whenever the absolute address is not
known at the time that the program is written, but the location of the
information is known. It can be rioted that the two programs
have exactly the same number of instructions. An interesting
exercise is now to determine which one will execute faster.
Exercise 5.2: Compute the number of bytes and the number of
cycles for each of these two programs, using the tables in the Ap
pendix section.
SUMMARY
A complete description of addressing modes has been presented.
It has been shown that the 6502 offers most of the possible mecha
nisms, and its features have been analyzed. Finally, several ap
plication programs have been presented to demonstrate the value
of each of the addressing mechanisms. Programming the 6502
requires an understanding of these mechanisms.
209
PROGRAMMING THE 6502
EXERCISES
5.3: Write a program to add the first 10 bytes of a table stored at
location "BASE." The result will have 16 bits. (This is a
checksum computation).
5.4: Can you solve the same problem without using the indexing
mode?
5.5: Reverse the order of the 10 bytes of this table. Store the re
sult at address "REVER."
5.6: Search the same table for its largest element. Store it at
memory address "LARGE."
5.7: Add together the corresponding elements of three tables,
whose bases are BASE1, BASE2, BASE3. The length of
these tables is stored in page zero at address "LENGTH."
210
INPUT/OUTPUT TECHNIQUES
INTRODUCTION
We have learned so far how to exchange information between the
memory and the various registers of the processor. We have
learned to manage the registers and to use a variety of instruc
tions to manipulate the data. We must now learn to communicate
with the external world. This is called the input/output.
Input refers to the capture of data from outside peripherals
(keyboard, disk, or physical sensor). Output refers to the transfer
of data from the microprocessor or the memory to external devices
such as a printer, a CRT, a disk, or actual sensors and relays.
We will proceed in two steps. First, we will learn to perform the
input/output operations required by common devices. Second, we
will learn to manage several input/output devices simultaneously,
i.e., to schedule them. This second part will cover, in particular,
polling vs. interrupts.
INPUT/OUTPUT
In this section we will learn to sense or to generate simple
signals, such as pulses. Then we will study techniques for enforc
ing or measuring correct timing. We will then be ready for more
complex types of input/output, such as high-speed serial and par
allel transfers.
211
PROGRAMMING THE 6502
Generate a Signal
In the simplest case, an output device will be turned off (or on)
from the computer. In order to change the state of the output
device, the programmer will merely change a level from a logical
"0" to a logical "1", or from "1" to "0". Let us assume that an
external relay is connected to bit "0" of a register called "OUT1."
In order to turn it on, we will simply write a "1" into the appropri
ate bit position of the register. We assume here that OUT1 repre
sents the address of this output register within our system. The
program which will turn the relay on is:
TURNON LDA #\%00000001
STA OUT1
We have assumed that the state of the other 7 bits of the regis
ter OUT1 is irrelevant. However, this is often not the case.
These bits might be connected to other relays. Let us, therefore,
improve this simple program. We want to turn the relay on, with
out changing the state of any other bit within this register. We
will assume that it is possible to read and write the contents of
this register. Our improved program now becomes:
TURNON LDA OUT1 READ CONTENTS OF OUT1
ORA #\%00000001 FORCE BIT 0 TO "1"
STA OUT1
The program first reads the contents of location OUT1, then
performs an inclusive OR on its contents. This changes only bit
position 0 to "1", and leaves the rest of the register intact. (For
more details on the ORA operation, refer to Chapter 4). This is
illustrated by Figure 6-1.
Pulses
Generating a pulse is accomplished exactly as in the case of
the level above. An output bit is first turned on, then later turned
off. This results in a pulse. This is illustrated in Figure 6-2. This
time, however, an additional problem must be solved: one must
generate the pulse for the correct length of time. Let us, therefore,
study the generation of a computed delay.
212
INPUT/OUTPUT TECHNIQUES
<=>
AFTER
-Il RELAY
Fig. 6-1: Turning on a Relay
OUTPUT PORT
REGISTER
0
0
0
0
0
0
1
0— 1
THE PROGRAM:
REGISTER WITH PATTERN
WAIT (LOOP FOR NUSEC)
LOAD OUTPUT PORT WITH ZERO
RETURN
Rg. 6-2: A Programmed Pulse
Delay Generation and Measurement
A delay may be generated by software or by hardware methods.
We will study here the way to perform it by program, and later
show how it can also be accomplished with a hardware counter,
called a programmable interval timer (PIT).
Programmed delays are achieved by counting. A counter regis
ter is loaded with a value, then is decremented. The program
loops on itself and keeps decrementing until the counter reaches
the value "0". The total length of time used by this process will
implement the required delay. As an example, let us generate a
delay of 37 microseconds.
213
PROGRAMMING THE 6502
DELAY LDY #07
NEXT DEY
BNE NEXT
Y IS COUNTER
DECREMENT
TEST
This program loads index register Y with the value 7. The next
instruction decrements Y, and the next instruction will cause a
branch to NEXT to occur as long as Y does not decrement to "0."
When Y finally decrements to zero, the program will exit from
this loop and execute whatever instruction follows. The logic of
the program is simple and appears in the flow chart of Figure 6-3.
YES
OUT
Fig. 6-3: A Delay Flowchart
Let us now compute the effective delay which will be im
plemented by the program. Looking at the Appendix section of the
book, we will look up the number of cycles required by each of
these instructions:
LDY, in the immediate mode, requires 2 cycles. DEY will use 2
cycles. Finally, BNE will use 3 cycles. When looking up the
number of cycles for BNE in the table, verify that 3 possibilities
exist; if the branch does not occur, BNE will only require 2 cycles.
If the branch does succeed, which will be the normal case during
the loop, then one more cycle is required. Finally, if the page
boundary is being crossed, then one extra cycle will be required.
We assume here that no page boundary will be crossed.
The timingis, therefore, 2 cycles for the first instruction, plus 5
214
INPUT/OUTPUT TECHNIQUES
cycles for the next 2, multiplied by the number of times the loop
will be executed, minus one cycle for the last BNE:
Delay = 2 + 5x7-1 = 36.
Assuming a 1-microsecond cycle time, this programmed delay
will be 36 microseconds.
We can see that the maximum definition with which we can
adjust the length of the delay is 2 microseconds. The minimum
delay is 2 microseconds.
Exercise 6.1: What is the maximum delay which can be imple
mented with these three instructions? Can you modify the pro
gram to obtain a one microsecond delay?
Exercise 6.2: Modify the program to obtain a delay of about 100
microseconds.
If one wishes to implement a longer delay, a simple solution is
to add extra instructions in the program, between DEY and BNE.
The simplest way to do so is to add NOP instructions. (The
NOP does nothing for 2 cycles).
Longer Delays
Generating longer delays by software can be achieved by using
a wider counter. Two internal registers, or, better, two words in the
memory, can be used to hold a 16-bit count. To simplify, let us
assume that the lower count is "0." The lower byte will be loaded
with "255," the maximum count, then go through a decrementa
tion loop. Whenever it is decremented to "0," the upper byte of the
counter will be decremented by 1. Whenever the upper byte is
decremented to the value "0," the program terminates. If more
precision is required in the delay generation, the lower count can
have a non-null value. In this case, we would write the program
just as explained and add at the end the three-line delay genera
tion program, which has been described above.
Naturally, still longer delays could be generated by using more
than two words. This is analogous to the way an odometer works
on a car. When the right-most wheel goes from "9" to "0," the next
wheel to the left is incremented by 1. This is the general principle
when counting with multiple discrete units.
However, the main objection is that when one is counting long
delays, the microprocessor will be doing nothing else for hundreds
of milliseconds or even seconds. If the computer has nothing else
215
PROGRAMMING THE 6502
to do, this is perfectly acceptable. However, in the general case,
the microcomputer should be available for other tasks so that
longer delays are normally not implemented by software. In fact,
even short delays may be objectionable in a system if it is to
provide some guaranteed response time in given situations.
Hardware delays must then be used. In addition, if interrupts are
used, timing accuracy may be lost if the counting loop can be
interrupted.
Exercise 6.3: Write a program to implement a 100 ms delay (for a
Teletype).
Hardware Delays
Hardware delays are implemented by using a programmable
interval timer, or "timer" for short. A register of the timer is loaded
with a value. The difference is that, this time, the timer will
automatically decrement this counter periodically. The period is
usually adjustable or selectable by the programmer. Whenever
the timer will have decremented to "0," it will normally send an
interrupt to the microprocessor. It may also set a status bit which
can be sensed periodically by the computer. The use of interrupts
will be explained later in this chapter.
Other timer operating modes may include starting from "0" and
counting the duration of the signal, or else counting the number
of pulses received. When functioning as an interval timer, the
timer is said to operate in a one-shot mode. When counting pulses,
it is said to operate in a pulse-counting mode. Some timer devices
may even include multiple registers and a number of optional
facilities which are program-selectable. This is the case, for
example, with the timers contained in the 6522 component, an I/O
chip described in the next chapter.
Sensing Pulses
The problem of sensing pulses is the reverse problem of gener
ating pulses, plus one more difficulty: whereas an output pulse is
generated under program control, input pulses occur asynchronously
with the program. In order to detect a pulse, two methods
may be used: polling and interrupts. Interrupts will be discussed
later in this chapter.
Let us consider now the polling technique. Using this technique,
the program reads the value of a given input register continu-
216
INPUT/OUTPUT TECHNIQUES
ously, testing a bit position, perhaps bit 0. It will be assumed that
bit 0 is originally "0." Whenever a pulse is received, this bit will
take the value "1" The program monitors bit 0 continuously until
it takes the value "1." When a "1" is found, the pulse has been
detected. The program appears below:
POLL
AGAIN
LDA
BIT
BEQ
#\$01
INPUT
AGAIN
ON
Conversely, let us assume that the input line is normally "1"
and that we wish to detect a "0." This is the normal case for
detecting a START bit when monitoring a line connected to a
Teletype. The program appears below:
POLL LDA #\$01
NEXT BIT INPUT
BNE NEXT
START
Monitoring the Duration
Monitoring the duration of the pulse may be accomplished in
the same way as computing the duration of an output pulse.
Either a hardware or a software technique may be used. When
monitoring a pulse by software, a counter is regularly in
cremented by 1, then the presence of the pulse is verified. If the
pulse is still present, the program loops upon itself. Whenever the
pulse disappears, the count contained in the counter register is
used to compute the effective duration of the pulse. The program
appears below
DURTN LDX #0 CLEAR COUNTER
LDA #\$01 MONITOR BIT 0
AGAIN BIT INPUT
BEQ AGAIN
LONGER INX
BIT INPUT
BNE LONGER
Naturally, we assume that the maximum duration of the pulse
will not cause register X to overflow. If this were the case, the
217
PROGRAMMING THE 6502
program would have to be longer to take this into account (or else
it would be a programming error!)
Since we now know how to sense and generate pulses, let us
capture or transfer larger amounts of data. Two cases will be
distinguished: serial data and parallel data. Then we will apply
this knowledge to actual input/output devices.
COUNT
STATUS
INPUT
PAGE*
PAGE1
VALID
8 BITS
Fig. 6-4: Parallel Word Transfer: The Memory
PARALLEL WORD TRANSFER
It is assumed here that 8 bits of transfer data are available in
parallel at address "INPUT." The microprocessor must read the
data word at this location whenever a status word indicates that
it is valid. The status information will be assumed to be contained
in bit 7 of address "STATUS." We will here write a program
218
INPUT/OUTPUT TECHNIQUES
which will read and automatically save each word of data as it
comes in. To simplify, we will assume that the number of words
to be read is known in advance and is contained in location
"COUNT." If this information were not available, we would test
for a so-called break character, such as a rubout, or perhaps the
character "*." We have learned to do this already.
POLLING OR SERVICE REQUEST
TRANSFER
WORD
DECREMENT
COUNTER
NO
YES
OUT
Fig. 6-5: Parallel Word Transfer: Flowchart
The flowchart appears in Figure 6-5. It is quite straightfor
ward. We test the status information until it becomes "1," indi
cating that a word is ready. When the word is ready, we read
it and save it at an appropriate memory location. We decre
ment the counter and then test whether it has decremented to
219
PROGRAMMING THE 6502
"0." If so, we are finished; if not, we read the next word. The
program which implements this algorithm appears below:
PARAL LDX COUNT COUNTER
WATCH LDA STATUS BIT 7 IS «1" IF DATA VALID
BPL WATCH DATA VALID?
LDA INPUT READ IT
PHA SAVE IT IN THE STACK
DEX
BNE WATCH
The first two instructions of the program read the status infor
mation and cause a loop to occur as long as bit 7 of the status
register is "0." (It is the sign bit, i.e. bit N).
WATCH LDA STATUS
BPL WATCH
When BPL fails, data is valid and we can read it:
LDA INPUT
The word has now been read from address INPUT where it was,
and must be saved. Assuming that the number of words to be trans
ferred is small enough, we use:
PHA
If the stack is full, or the number of words to be transferred is lafee,
we could not push them on the stack and we would have to transfer
them to a designated memory area, using, for example, an indexed
instruction. However, this would require an extra instruction to in
crement or decrement the index register. PHA is faster.
The word of data has now been read and saved. We will simply
decrement the word counter and test whether we are finished:
DEX
BNE WATCH
We keep looping until the counter eventually decrements to "0."
This 6-instruction program can be called a benchmark. A benchmark
program is a carefully optimized program designed to test the cap
abilities of a given processor in a specific situation. Parallel trans
fers are one such typical situation. This program has been designed
for maximum speed and efficiency. Let us now compute the maximum
220
INPUT/OUTPUT TECHNIQUES
transfer speed of this program. We will assume that COUNT is con
tained in page 0. The duration of every instruction is determined by
inspecting the table at the end of the book and is found to be the
following:
CYCLES
LDX
WATCH LDA
BPL
LDA
PHA
DEX
BNE
COUNT
STATUS
WATCH
INPUT
WATCH
3
4
2/3 (FAIL/SUPCEED)
4
3
2
2/3 (FAIL/SUCCEED)
The minimum execution time is obtained by assuming that
data is available every time that we sample STATUS. In other
words, the first BPL will be assumed to fail every time. Timing is
then: 3 + (4+2+4+3+2+3) x COUNT.
Neglecting the first 3 microseconds necessary to initialize the
counter register, the time used to transfer one word is 18 mi
croseconds.
The maximum data transfer rate is, therefore,
1
18(10-6)
= 55 K bytes per second.
Exercise 6.4: Assume that the number of words to be transferred
is greater than 256. Modify the program accordingly and determine
the impact on the maximum data transfer rate.
We have now learned to perform high-speed parallel transfers.
Let us consider a more complex case.
BIT SERIAL TRANSFER
A serial input is one in which the bits of information (0's or
l's) come in successively on a line. These bits may come in at
regular intervals. This is normally called synchronous transmis
sion. Or else, they may come as bursts of data at random inter
vals. This is called asynchronous transmission. We will develop a
program which can work in both cases. The principle of the cap
ture of sequential data is simple: we will watch an input line,
which will be assumed to be line 0. When a bit of data is detected
on this line, we will read the bit in, and shift it into a holding reg
ister. Whenever 8 bits have been assembled, we will preserve the
221
PROGRAMMING THE 6502
PAGE I
PAGE1
STATUS OR CLOCK
^r-SERIAL DATA
Fig. 6-6: Serial to Parallel Conversion
byte of data into the memory and assemble the next one. In order
to simplify, we will assume that the number of bytes to be received
is known in advance. Otherwise, we might, for example, have to
watch for a special break character, and stop the bit-serial
transfer at this point. We have learned to do that. The flow-chart
for this program appears in Figure 6-7. The program appears
below:
BIT 7 IS STATUS, "0" IS DATA
BIT RECEIVED?
SHIFT IT INTO C
SAVE BIT IN MEMORY
CONTINUE IF CARRY = "0"
SAVE ASSEMBLED BYTE
RESET BIT COUNTER
DECREMENT WORD COUNT
ASSEMBLE NEXT WORD
SERIAL
LOOP
LDA
STA
LDA
BPL
LSR
ROL
BCC
LDA
PHA
LDA
STA
DEC
BNE
#\$00
WORD
INPUT
LOOP
A
WORD
LOOP
WORD
#\$01
WORD
COUNT
LOOP
222
INPUT/OUTPUT TECHNIQUES
This program has been designed for efficiency and will use new
techniques which we will explain. (See Fig. 6-6.)
The conventions are the following: memory location COUNT is
assumed to contain a count of the number of words to be trans
ferred. Memory location WORD will be used to assemble 8 con
secutive bits coming in. Address INPUT refers to an input regis
ter. It is assumed that bit position 7 of this register is a status flag,
or a clock bit. When it is "0 " data is not valid. When it is "1" the
data is valid. The data itself will be assumed to appear in bit
position 0 of this same address. In many instances, the status
information will appear on a different register than the data reg-
POLLING OR SERVICE REQUEST
STORE BIT
INCREMENT COUNTER
YES
STORE WORD
RESET BIT COUNTER
DECREMENT WORD COUNT
Fig. 6-7: Bit Serial Transfer: Flowchart
223
PROGRAMMING THE 6502
ister. It should be a simple task, then, to modify this program
accordingly. In addition, we will assume that the first bit of data
to be received by this program is guaranteed to be a "1." It indi
cates that the real data follows. If this were not the case, we will
see later an obvious modification to take care of it. The program
corresponds exactly to the flowchart of Figure 6-7. The first few
lines of the program implement a waiting loop which tests
whether a bit is ready. Tb determine whether a bit is ready, we
read the input register then test the sign bit (N). As long as this
bit is "0," the instruction BPL will succeed, and we will branch
back to the loop. Whenever the status (or clock) bit will become
true ("1"), then BPL will fail and the next instruction will be
executed.
Remember that BPL means "Branch on Plus," i.e. when bit 7
(the sign bit) is "0." This initial sequence of instructions corre
sponds to arrow 1 on Figure 6-6.
At this point, the accumulator contains a "1" in bit position 7
and the actual data bit in bit position 0. The first data bit to arrive
is going to be a "1." However, the following ones may be either "0"
or "1." We now wish to preserve the data bit which has been
collected in position 0. The instruction:
LSRA
shifts the contents of the accumulator right by one position. This
causes the right-most bit of A, which is our data bit, to fall into
the carry bit. We will now preserve this data bit into the memory
location WORD (this is illustrated by arrows 2 and 3 in Fig. 6-6):
ROL WORD.
The effect of this instruction is to read the carry bit into the
right-most bit position of address WORD. At the same time, the
left-most bit of WORD falls into the carry bit. (If you have any
doubts about the rotation operation, refer to Chapter 4!)
It is important to remember that a rotation operation will both
save the carry bit, here into the right-most bit position, and also
recondition the carry bit with the value of bit 7.
Here, a "0" will fall into the carry. The next instruction:
BCC LOOP
tests the cany and branches back to address LOOP as long as the
carry is "0." This is our automatic bit counter. It can readily be
224
INPUT/OUTPUT TECHNIQUES
seen that as a result of the first ROL, WORD will contain
"00000001." Eight shifts later, the "1" will finally fall into the
carry bit and stop the branching. This is an ingenious way to
implement an automatic loop counter without having to waste an
instruction to decrement the contents of an index register. This
technique is used in order to shorten the program and improve its
performance.
Whenever BCC finally fails, 8 bits have been assembled into lo
cation WORD. This value should be preserved in the memory. This
is accomplished by the next instructions (arrow 4 in Fig. 6-6):
LDA WORD
PHA
We are here saving the WORD of data (8 bits) into the stack.
Saving it into the stack is possible only if there is enough room in
the stack. Provided that this condition is met, it is the fastest way
to preserve a word in the memory. The stack pointer is updated
automatically. If we were not pushing a word in the stack, we
would have to use one more instruction to update a memory
pointer. We could equivalently perform an indexed addressing
operation, but that would also involve decrementing or incre
menting the index, using extra time.
After the first WORD of data has been saved, there is no longer
any guarantee that the first data bit to come in will be a "1." It can
be anything. We must, therefore, reset the contents of WORD to
"00000001" so that we can keep using it as a bit counter. This is
performed by the next two instructions:
LDA #\$01
STA WORD
Finally, we will decrement the word counter, since a word has
been assembled, and test whether we have reached the end of the
transfer. This is accomplished by the next two instructions:
DEC COUNT
BNE LOOP
The above program has been designed for speed, so that one
may capture a fast input stream of data bits. Once the program
terminates, it is naturally advisable to immediately read away
from the stack the words'that have been saved there and transfer
them elsewhere into the memory. We have already learned to
225
PROGRAMMING THE 6502
perform such a block transfer in Chapter 2.
Exercise 6.5: .Compute the maximum speed at which this pro
gram will be able to read serial bits. To compute this speed, as
sume that addresses WORD and COUNT are kept in Page 0. Also,
assume that the complete program resides within the same page.
Look up the number of cycles required by every instruction, in the
table at the end of this book, then compute the time which will
elapse during execution of this program. To compute the length
of time which will be used by a loop, simply multiply the total
duration of this loop, expressed in microseconds, by the number
of times it will be executed Also, when computing the maximum
speed, assume that a data bit will be ready every time that the in
put location is sensed
This program is more difficult to understand than the previous
ones. Let us look at it again (refer to Figure 6-6) in more detail,
examining some trade-offs.
A bit of data comes into bit position 0 of "INPUT" from
time to time. There might be, for example, three "IV in succession.
We must, therefore, differentiate between the successive bits com
ing in. This is the function of the "clock" signal.
The clock (or STATUS) signal tells us that the input bit is
now valid.
Before reading a bit, we will therefore first test the status bit.
If the status is "0", we must wait. If itis"l", then the data
bit is good.
We assume here that the status signal is connected to bit 7
of register INPUT.
Exercise 6.6: Can you explain why bit 7 is used for status, and
bit 0 for data?
Once we have captured a data bit, we want to preserve it in
a safe location, then shift it left, so that we can get the next bit.
Unfortunately, the accumulator is used to read and test both data
and status in this program. If we were to accumulate data in the
accumulator, bit position 7 would be erased by the status bit.
Exercise 6.7: Can you suggest a way to test status without eras
ing the contents of the accumulator (a special instruction)? If this
226
INPUT/OUTPUT TECHNIQUES
can be done, could we use the accumulator to accumulate the suc
cessive bits coming in?
Exercise 6.8: Re-write the program, using the accumulator to
store the bits coming in. Compare it to the previous one in terms
of speed and number of instructions.
Let us address two more possible variations:
We have assumed that, in our particular example, the very first bit to
come in would be a special signal, guaranteed to be "1." However, in
the general case, it may be anything.
Exercise 6.9: Modify the program above, assuming that the very
first bit to come in is valid data (not to be discarded), and can be
"0" or "1 ."Hint- our "bit counter" should still work correctly,
if you initialize it with the correct value.
Finally, we have been saving the assembled WORD in the stack, to
gain time. We could naturally save it in a specified memory area:
Exercise 6.10: Modify the program above, and save the assem
bled WORD in the memory area starting at BASE.
Exercise 6.11: Modify the program above so that the transfer
will stop when the character "S" is detected in the input stream.
The Hardware Alternative
As usual for most standard input/output algorithms, it is possi
ble to implement this procedure by hardware. The chip is called a
UART. It will automatically accumulate the bits. However, when
one wishes to reduce the component count, this program, or a
variation of it, will be used instead.
Exercise 6.12: Modify the program assuming that data is avail
able in bit position 0 of location INPUT, while the status informa
tion is available in bit position 0 of address INPUT + 1.
227
PROGRAMMING THE 6502
BASIC I/O SUMMARY
We have now learned to perform elementary input/output op
erations as well as to manage a stream of parallel data or serial
bits. We are ready to communicate with real input/output devices.
COMMUNICATING WITH INPUT/OUTPUT DEVICES
In order to exchange data with input/output devices, we will
first have to ascertain whether data is available, if we want to
read it, or whether the device is ready to accept data, if we want to
send it. Two procedures may be used: handshaking and inter
rupts. Let us study handshaking first.
Handshaking
Handshaking is generally used to communicate between any
two asynchronous devices, i.e., between any two devices which
are not synchronized. For example, if we want to send a word to a
parallel printer, we must first make sure that the input buffer of
this printer is available. We will, therefore, ask the printer: Are
you ready? The printer will say "yes" or "no." If it is not ready we
will wait. If it is ready, we will send the data. (See Fig. 6-8.)
(READ
STATUS)
STATUS
REGISTER
OUTPUT
DEVICE
Fig. 6-8: Handshaking (Output)
Conversely, before reading data from an input device, we will
verify whether the data is valid. We will ask: "Is data valid?" And
the device will tell us "yes" or "no." The "yes" or "no" may be
indicated by status bits, or by other means. (See Fig. 6-9.)
228
INPUT/OUTPUT TECHNIQUES
MPU
CHARACTER
READY?
YES/NO
| 1
INPUT
REGISTER
STATUS
REGISTER
<^
INPUT
DEVICE
Fig. 6-9: Handshaking (Input)
In short, whenever you wish to exchange information with
someone who is independent and might be doing something else
at the time, you should ascertain that he is ready to communicate
with you. The usual courtesy rule is to shake his hand. Data
exchange may then follow. This is the procedure normally used in
communicating with input/output devices.
Let us illustrate this procedure now with a simple example:
Sending a Character To The Printer
The character will be assumed to be contained in memory loca
tion CHAR. The program to print it appears below:
CHARPR LDX CHAR READ CHARACTER
WAIT LDA STATUS BIT 7 IS "READY"
BPL WAIT
TXA
STA PRINTD
Register X is first loaded from the memory with a character to
be printed. Then we test the status bit of the printer to determine
that it is ready to accept the character. As long as it is not ready to
print, however, we branch back to address WAIT, and we loop.
Whenever the printer indicates that it is ready to print by setting
its ready-bit (here bit 7 by convention of address STATUS), we
can send the character. We transfer the character from register X
to register A:
TXA
229
PROGRAMMING THE 6502
and we send it to the printer's output register address, called here
PRINTD.
STA PRINTD
Exercise 6.13: Modify the program above to print a string of n
characters, where n will be assumed to be less than 255.
Exercise 6.14: Modify the above program to print a string of
characters until a "carriage-return" code is encountered
Let us now complicate the output procedure by requiring a code
conversion and by outputting to several devices at a time:
D
Fig. 6-10: Seven Segment LED
Output to a 7-Segment LED
A traditional 7-segment light-emitting-diode (LED) may dis
play the digits "0" through "9," or even "0" through "F" hexadec
imal by lighting combinations of its 7 segments. A 7-segment
LED is shown in illustration 6-10. The characters that may be gen
erated with this LED appear in Figure 6-11. The segments of an LED
ARE LABELLED "A" through "G" in Figure 6-10.
For example, "0" will be displayed by lighting the segments
230
INPUT/OUTPUT TECHNIQUES
"ABCDEF." Let us assume, now, that bit "0" of an output port is
connected to segment "A," that "1" is connected to segment "B,"
and so on. Bit 7 is not used. The binary code required to light up
"FEDCBA" (to display "0") is, therefore, "0111111." In hexa
decimal this is "3F." Do the following exercise.
■L
D
A
7
n
n
i
b
i_
r
i
j
n
o
i
u
u
n
i
r
n
u
r
r
Fig. 6-11: Characters Generated with a 7-Segment LED
Exercise 6.15: Compute the 7-segment equivalent for the hexa
decimal digits "0" through "F. "Fill out the table below:
Hex LED code Hexl LED code |Hex | LED code |Hex | LED code
0
1
2
3
4
5
6
7
8
9
A
B
C
D
E
F
Let us now display hexadecimal values on several LEDs.
Driving Multiple LEDs
An LED has no memory. It will display the data only as long as
its segment lines are active. In order to keep the cost of an LED
display low, the microprocessor will display information in turn
on each of the LEDs. The rotation between the LEDs must be fast
enough so that there is no apparent blinking. This implies that
the time spent from one LED to the next is less than 100 milli-
231
PROGRAMMING THE 6502
seconds. Let us design a program which will accomplish this.
Register Y will be used to point to the LED on which we want to
display a digit. The accumulator is assumed to contain the
hexadecimal value to be displayed on the LED. Our first concern
is to convert the hexadecimal value into its 7-segment repre
sentation. In the preceding section, we have built the equivalence
table. Since we are accessing a table, we will use the indexed
addressing mode, where the displacement index will be provided
by the hexadecimal value. This means that the 7-segment code for
hexadecimal digit #3 is obtained by looking up the third element
of the table after the base. The address of the base will be called
SEGBAS. The program appears below:
LEDS TAX USE HEX VALUE AS INDEX
LDA SEGBAS,X READ CODE IN A
LDX #\$00
STX SEGDAT TURN OFF SEGMENT DRIVERS
STA SEGDAT DISPLAY DIGIT
LDX #\$70 ANY LARGE NUMBER
STY SEGADR
DELAY DEX
BNE DELAY
DEY POINT TO NEXT LED
BNE OUT
LDY LEDNBR
OUT RTS
The program assumes that register Y contains the number of the
LED to be illuminated next, and that register X contains the digit
to be displayed.
The program first looks up the 7-segment code corresponding to
the hexadecimal value contained in the accumulator with its first
two instructions. The next two instructions load "00" as the value
of the segments to be displayed, i.e., turn them off. The next
instruction then selects the appropriate LED segments for dis
play: STY SEGADR.
A three-instruction loop delay is then implemented before
switching to the next LED. Finally, the LED pointer is de
cremented. (It could be incremented).
If the LED pointer decrements to "0," it must be reloaded with
the highest LED number. This is accomplished by the next two
instructions. It is assumed here that this is a subroutine and the
last instruction is an RTS: "return from subroutine."
232
INPUT/OUTPUT TECHNIQUES
STOP1ST0P2
l I
HARK
SPACE 1 |l1!S8'n ' '
9.09 ms
Fig. 6-12: Format of a Teletype Word
Exercise 6.16: Assuming that the above program is a subroutine,
you will notice that it uses registers X and Y internally and mod
ifies their contents. Assuming that the subroutine may freely use
the memory area designated by address Tl, T2, T3, T4, T5, could
you add instructions at the beginning and at the end of this pro
gram which will guarantee that, when the subroutine returns, the
contents of registers X and Y will be the same as when the sub
routine was entered?
Exercise 6.17: Same exercise as above, but assume that the
memory area Tl, etc. is not available to the subroutine. (Hint: re
member that there is a built-in mechanism in every computer for
preserving information in a chronological order).
We have now solved common input/output problems. Let us
consider the case of a real peripheral: the Teletype.
Teletype Input/Output
The Teletype is a serial device. It both sends and receives words
of information in a serial format. Each character is encoded in ah
8-bit ASCII format (the ASCII table appears at the end of this
233
PROGRAAAAAING THE 6502
YES
WAIT 4.5 ms
ECHO START BIT
WAIT 9.09 ms
SHIFT IN DATA BIT
ECHO IT
WAIT 9.09 ms
OUTPUT STOP BIT
WAIT 13.59 ms
Fig. 6-13: TTY Input with Echo
234
INPUT/OUTPUT TECHNIQUES
book). In addition, every character is preceded by a "start" bit,
and terminated by two "stop" bits. In the so-called 20-milliamp
current loop interface, which is most frequently used, the state of
the line is normally a "1." This is used to indicate to the processor
that the line has not been cut. A start is a "l"-to-"0" transition. It
indicates to the receiving device that data bits follow. The standard
Teletype is a 10-characters-per-second device. We have just es
tablished that each character requires 11 bits. This means that
the Teletype will transmit 110 bits per second. It is said to be a 110-
baud device. We will design a program to serialize bits in from the
Teletype at the correct speed.
One hundred and ten bits per second implies that bits are sepa
rated by 9.09 milliseconds. This will have to be the duration of the
delay loop to be implemented between successive bits. The format
of a Teletype word appears in Figure 6-12. The flowchart for bit
input appears in Figure 6-13. The program follows:
TTYN
NEXT
LDA
BPL
JSR
LDA
STA
JSR
LDX
LDA
STA
LSR
ROL
JSR
DEX
BNE
LDA
STA
JSR
RTS
STATUS
TTYIN
DELAY
TTYBIT
TTYBIT
DELAY
#\$08
TTYBIT
TTYBIT
A
CHAR
DELAY
NEXT
TTYBIT
TTYBIT
DELAY
USUAL STATUS POLL
WAIT
START BIT
ECHO BACK
BIT COUNTER
SAVE INPUT
ECHO BACK
SAVE BIT IN CARRY
SAVE BIT IN CHAR
NEXT BIT
STOP BIT
Fig. 6-14: Input from Teletype
Note that this program differs slightly from the flowchart of Fig. 6-13.
235
PROGRAMMING THE 6502
The program should be examined with attention. The logic is quite
simple. The new fact is that, whenever a bit is read from the Tele
type (at address TTYBIT), it is echoed back to the Teletype. This
is a standard feature of the Teletype. Whenever a user presses a key,
the information is transmitted to the processor and then back to the
printing mechanism of the Teletype. This verifies that the transmis
sion lines are working and that the processor is operating when a
character is, indeed, printing correctly on the paper.
MEMORY + i/O
A
X
c
H x 1
I CHAR
STATUS
TTYBIT
X
X
TELETYPE
Fig. 6-15: Teletype Input
The first two instructions are the waiting loop. The program waits
for the status bit to become true before it starts reading bits in.
As usual, the status bit is assumed to come in bit position 7,
since this position can be tested in one instruction by BPL (Branch
on Plus-this is the sign bit).
JSR is the subroutine jump. We use a DELAY subroutine to
implement the 9.09 ms delay. Note that DELAY can be a delay loop,
or can use the hardware timer, if our system has one.
The first bit to come in is the start bit. It should be echoed to the
Teletype, but otherwise ignored This is done by instructions 4 and 5.
Again, we wait for the next bit. But, this time, it is a true
data bit, and we must save it. Since all shift instructions will
drop a bit in the carry flag, we need two instructions to preserve
our data bit (the X in Figure 6-15): one to drop it into C (LSR A),
236
INPUT/OUTPUT TECHNIQUES
and one to preserve it into memory location CHAR (ROL).
Beware of one problem: the "ROL" will destroy the contents of
C. If we want to echo the data bit back, a precaution must be tak
en to preserve it before it disappears into CHAR. Finally, we echo
the data bit (STA TTYBIT) and wait for the next one (JSR
DELAY) until we accumulate all eight data bits (DEX).
Whenever we decrement to zero, all 8 bits are in CHAR. We
just have to echo the STOP bits, and we are finished.
Exercise 6.18: Write the delay routine which results in the 9.09
millisecond delay. (DELAY subroutine)
ENTER
SEND START
BIT
SEND DATA
BITS
SEND STOP
BIT
EXIT
ENTER
Fig. 6-16: Teletype Output
237
PROGRAAAAAING THE 6502
Exercise 6.19: Using the example of the program developed
above, write a PRINTC program which will print on the Teletype
the contents of memory location CHAR.
Exercise 6.20: Modify the program so that it waits for a START
bit instead of a STATUS bit
Printing a String of Characters
We will assume that the PRINTC routine (see Exercise 6-18)
takes care of printing a character on our printer, display, or any
output device. We will here print the contents of memory loca
tions START + N to START.
We will naturally use the indexed addressing mode and the
program is straight-forward:
PSTRING
NEXT
LDX
LDA
JSR
DEX
BPL
#N
START+N
PRINTC
NEXT
NUMBERS OF WORDS
MEMORY
COUNTER
OUTPUT REGISTER
TO PRINTER
Fig. 6-17: Print a Memory Block
PERIPHERAL SUMMARY
We have now described the basic programming techniques used
to communicate with typical input/output devices. In addition to
the data transfer, it will be necessary to condition one or more
238
INPUT/OUTPUT TECHNIQUES
control registers within each I/O device in order to condition cor
rectly the transfer speeds, the interrupt mechanism, and the var
ious other options. The manual for each device should be con
sulted. (For more details on the specific algorithms to exchange
information with all the usual peripherals, the reader is referred
to our book,"C207, Microprocessor Interfacing Techniques.")
We have now learned to manage single devices. However, in a
real system, all peripherals are connected to the busses, and may
request service simultaneously. How are we going to schedule the
processor's time?
INPUT/OUTPUT SCHEDULING
Since input/output requests may occur simultaneously, a
scheduling mechanism must be implemented in every system to
determine in which order service will be granted. Three basic
input/output techniques are used, which can be combined.
They are: polling, interrupt, DMA. Polling and interrupts
will be described here. DMA is purely a hardware tech-
MEMORY
MPU
DATA BUS
, 0
— »| I/O
L.
J ?
:> POLLING
MPU
J
INTI
HOLD
MPU
MEMORY
1
J
| MEMORY
* I 1 *
1 1 _11
I/O
t INT
1
DMA
I/O |
t JNT
_f * .
j_l-1
INTERRUPT
Fig. 6-18: Three Methods of I/O Control
239
PROGRAMMING THE 6502
nique, and as such will not be described here. (It is covered in
the reference books C201 and C207).
Polling
Conceptually, polling is the simplest method for managing multiple
peripherals. With this strategy, the processor interrogates the devices
connected to the buses in turn. If a device requests service, the service
is granted. If it does not request service, the next peripheral is exam
ined. Polling is not just used for the devices, but for any device service
routine.
^^wcERVICE? ^^^
^^^ REQUI
^^^-^SERV
^^REQUE
^*^w SERV
f
NO
__^
.STING^^V
NO
^^
STING ^*
ICE?^^^^*^
NO
YES
1
SERVICE ROUTINE
FOR DEVICE A
1
YES
SERVICE ROUTINE
FOR DEVICE B
1
YES
* 1
SERVICE ROUTINE
FOR DEVICE C
1
Fig. 6-19: Polling Loop Flow-chart
As an example, if the system is equipped with a Teletype, a tape re
corder, and a CRT display, the polling routine would interrogate the
Teletype: "Do you have a character to transmit?" It would interrogate
the Teletype output routine, asking: "Do you have a character to send?"
Then, assuming that the answers are negative so far, it would interro
gate the tape recorder routines, and finally the CRT display. In the case
that only one device is connected to a system, polling will be used as
240
INPUT/OUTPUT TECHNIQUES
SET READER
ENABLE ON
NO
YES
READ CHARACTER
Fig. 6-2O: Reading from a Paper-Tape Reader
LOAD PUNCH
OR PRINTER
BUFFER
TRANSMIT
DATA
Fig. 6-21: Printing on a Punch or Printer
241
PROGRAMMING THE 6502
well to determine whether it needs service. As an example, the flow
charts for reading from a paper-tape reader and for printing on a print
er appear in Figures 6-20 and 6-21.
Example: a polling loop for devices 1, 2, 3, 4, (see Fig. 6-18):
POLL4 LDA STATUS1 SERVICE REQUEST IS BIT 7
BMI ONE
LDA STATUS2 DEVICE2?
BMI TWO
LDA STATUS3 DEVICE3?
BMI THREE
LDA STATUS4 DEVICE4
BMI FOUR
JMP POLL4 TEST AGAIN
Bit 7 of the status register for each device is "1" when it wants
service. When a request is sensed, this program branches to the
device handler, at address ONE for device 1, TWO for device 2, etc.
The advantages of polling are obvious: it is simple, does not
require any hardware assistance, and keeps all input/output syn
chronous with the program operation. Its disadvantage is just as
obvious: most of the processor's time is wasted looking at devices
that do not need service. In addition, the processor might give
service to a device too late, by wasting so much time.
Another mechanism is, therefore, desirable which guarantees
that the processor's time can be used to perform useful computa
tions, rather than polling devices needlessly all the time. How
ever, let us stress that polling is used extensively whenever a
microprocessor has nothing better to do, as it keeps the overall
organization simple. Let us now examine the essential alterna
tive to polling: interrupts.
Interrupts
The concept of interrupts is illustrated in Figure 6-18. A spe
cial hardware line is available, the interrupt line, which is con
nected to a specialized pin of the microprocessor. Multiple input/
output devices may be connected to this interrupt line. When any
one of them needs service, it sends a level or a pulse on this line.
An interrupt signal is the service request from an input/output
242
INPUT/OUTPUT TECHNIQUES
STACK PC, P
SET I
LOAD PC FROM
(FFFE, FFFF)
JUMP
YES ^ IGNORE
INTERRUPT
Fig. 6-22: Interrupt Processing
243
PROGRAMMING THE 6502
device to the processor. Let us examine the response of the proc
essor to this interrupt.
In any case, the processor completes the instruction that it was
currently executing, or else this would create chaos inside the
microprocessor. Next, the microprocessor should branch to an
interrupt handling routine which will process the interrupt. Branching
to such a subroutine implies that the contents of the program counter
must be saved on the stack. An interrupt must, therefore, cause
the automatic preservation of the program counter on the stack.
In addition, the status register (P) should also be automatically
preserved, as its contents will be altered by any subsequent in
struction. Finally, if the interrupt handling routine should modify
any internal registers, these internal registers should also be pre
served on the stack.
After all these registers have been preserved, one can branch to
the appropriate interrupt handling address. At the end of this
routine, all the registers should be restored, and a special inter
rupt return should be executed so that the main program will
resume execution. Let us examine in more detail the two inter
rupt lines of the 6502.
6502 Interrupts
The 6502 is equipped with two interrupt lines, IRQ and NMI.
IRQ is the regular interrupt line, while NMI is a higher priority
non-maskable interrupt. Let us examine their operation.
IRQ is the level-activated interrupt. The status of the IRQ line
will be sensed or ignored by the microprocessor depending upon
the value of its internal flag I (interrput-mask flag). We will ini
tially assume that interrupts are enabled. Whenever IRQ is
activated, the interrupt will be sensed by the microprocessor. As
soon as the interrupt is accepted (upon completion of the instruc
tion currently executing), the internal I flag is automatically set.
This will prevent the microprocessor from being interrupted
again at a time when it is manipulating internal registers. The
6502 then automatically preserves the contents of PC (the pro
gram counter) and P (the status register) into the stack. The
aspect of the stack after an interrupt has been processed is illus
trated by Figure 6-23.
Next, the 6502 will automatically fetch the content of memory
locations "FFFE" and "FFFF." This 16-bit memory location will
244
INPUT/OUTPUT TECHNIQUES
PCL
PCH
Fig. 6-23:65O2 Stack After Interrupt
contain the interrupt-vector. The 6502 will fetch the contents of
this address, then branch to the specified 16-bit vector. The user is
responsible for depositing this vectoring address at "FFFE"-
"FFFF". However, several devices may be connected to the IRQ
line. In this case, we are branching to a single interrupt handling
routine. How are we going to differentiate between the various
devices? This will be studied in the next section.
The NMI interrupt is essentially identical to IRQ except that it
FFFD
FFFE
FFFF
Fig. 6-24: Interrupt Vectors
245
PROGRAMMING THE 6502
cannot be masked by the I bit. It is a higher priority interrupt,
typically used for power failures. Its operation is otherwise iden
tical except that the processor branches automatically to the con
tents of "FFFA"-"FFFB". This is illustrated in Figure 6-24.
The return from an interrupt is accomplished by instruction
RTI. This instruction transfers back into the microprocessor the
top three words of the stack which contains P and PC (the 16-bit
program counter). The program which had been interrupted can
then resume. The internal state of the machine is exactly identi
cal to the one at the time that the interrupt occurred. The effect
has been to introduce a delay in the execution of the program.
Prior to returning from an interrupt, the programmer is re
sponsible for clearing the interrupt that it has now serviced, and
restoring the interrupt disable flag. In addition, should the inter
rupt handling routine modify the contents of any register, such as
X or Y, the programmer is specifically responsible for preserving
these registers in the stack prior to executing the interrupt han
dling routine. Otherwise, the contents of these registers will be
modified, and when the interrupted program resumes execution,
it will not be correct.
Assuming that the interrupt handling routine will use regis
ters A, X, and Y, five instructions will be necessary within the
interrupt handler to preserve these registers. They are:
SAVAXY PHA
TXA
PHA
TYA
PHA
PUSH A IN
TRANSFER
PUSH IT
TRANSFER
PUSH IT
THE STACK
XTOA
YTOA
Unfortunately, the 6502 may only directly push the contents of A or
P on the stack. As a result, preserving X and Y is time-consuming; it
requires 4 instructions. This is illustrated in Figure 6-25.
Upon the completion of the interrupt handling routine, these
registers must be restored and the interrupt handler must termi
nate with the sequence of six instructions:
246
INPUT/OUTPUT TECHNIQUES
PLA
TAY
PLA
TAX
PLA
RTI
PULL Y FROM STACK
RESTORE Y
PULLX
RESTORE X
RESTORE A
EXIT
PCL
PCH
STACK
Fig. 6-25: Saving all the Registers
Exercise 6.21: Using the table indicating the number of cycles
per instruction, in the Appendix, compute how much time will be
lost by saving and then restoring registers A, X, and Y.
For a graphic comparison of the polling process vs. the interrupt
process, refer to Figure 6-18, where the polling process is illustrated
on the top, and the interrupt process underneath. It can be seen that
in the polling technique, the program wastes a lot of time waiting.
Using interrupts, the program is interrupted, the interrupt is serviced,
then the program resumes. However, the obvious disadvantage of an
interrupt is to introduce several additional instructions at the beginning
and at the end, resulting in a delay before the first instruction of the
device handler can be executed. This is additional overhead.
247
PROGRAMMING THE 6502
Having clarified the operation of the two interrupt lines, let us
now consider two important problems remaining:
1. How do we resolve the problem of multiple devices trigger
ing an interrupt at the same time?
2. How do we resolve the problem of an interrupt occurring
while another interrupt is being serviced?
Multiple Devices Connected to a Single Interrupt Line
Whenever an interrupt occurs, the processor automatically
branches to an address contained at "FFFE-FFFF" (for an IRQ),
or at "FFFA-FFFB" (for an NMI). Before it can do any effective
processing, the interrupt handling routine must determine which
device triggered the interrupt. Two methods are available to iden
tify the device, as usual: a software method and a hardware
method.
INT 1 POLLING INTERRUPT VECTORED
POLLING
ROUTINE
SERVICE
ROUTINE
SERVICE
ROUTINE N
Fig. 6-26: Polled vs. Vectored Interrupt
In the software method, polling is used: the microprocessor in
terrogates each of the devices in turn and asks them, "Did you
trigger the interrupt?" If not, it interrogates the next one. This
process is illustrated in Figure 6-26. A sample program is:
LDA
BMI
LDA
BMI
STATUS 1
ONE
STATUS 2
TWO
248
INPUT/OUTPUT TECHNIQUES
The hardware method uses additional components but provides
the address of the interrupting device simultaneously with the
interrupt request. The device now universally used to provide this
facility is called a "PIC," or priority-interrupt-controller. Such a
PIC will automatically place on the data bus the actual required
branching address for the interrupting peripheral. When the
6502 goes to "FFFE"-"FFFF," it will fetch this vectoring address.
This concept is illustrated in Figure 6-26.
In most cases, the speed of reaction to an interrupt is not cru
cial, and a polling approach is used. If response time is a primary
consideration, a hardware approach must be used.
HPU
INT
I—H r—1
I/O ... I/O
INTERFACE 1 | INTERFACE n
LULL. JlNTi
Fig. 6-27: Several Devices May Use the Same interrupt Line
Multiple Interrupts
The next problem which may occur is that a new interrupt can
be triggered during the execution of an interrupt handling
routine. Let us examine what happens and how the stack is used
to solve the problem. We have indicated in Chapter 2 that this
was another essential role of the stack, and the time has come
now to demonstrate its use. We will refer to Figure 6-28 to illus
trate multiple interrupts. Time elapses from left to right in the
illustration. The contents of the stack are shown at the bottom of
the illustration. Looking at the left, at time TO, program P is in
execution. Moving to the right, at time Tl, interrupt II occurs. We
will assume that the interrupt mask was enabled, authorizing II.
Program P will be suspended. This is shown at the bottom of the
illustration. The stack will contain the program counter and the
status register of Program P, at least, plus any optional registers
that might be saved by the interrupt handler or II itself.
At time Tl, interrupt II starts executing until time T2. At time
T2, interrupt 12 occurs. We will assume that interrupt 12 is con
sidered to have a higher priority than interrupt II. If it had a
249
PROGRAMMING THE 6502
TIME To
PROGRAM P »—
INTERRUPT 1,
INTERRUPT 1,
INTERRUPT 1,
STACK □ QQQ
Fig. 6-28: Stack During Interrupts
lower priority, it would be ignored until II had been completed. At
time T2, the registers for II are stacked, and this appears at the
bottom of the illustration. Again, the contents of the program
counter and P are pushed into the stack. In addition, the routine
for 12 might decide to save an additional few registers. 12 will now
execute to completion at time T3.
When 12 terminates, the contents of the stack are automati
cally popped back into the 6502, and this is illustrated at the
bottom of Figure 6-28. Automatically, interrupt II thus resumes
execution. Unfortunately, at time T4, an interrupt 13 of higher
priority occurs again. We can see at the bottom of the illustration
that the registers for II are again pushed into the stack. Interrupt
13 executes from T4 to T5 and terminates atT5. At that time, the
contents of the stack are popped into 6502, and interrupt II re
sumes execution. This time it runs to completion and terminates
at T6. At T6, the remaining registers that have been saved in the
stack are popped into the 6502, and program P may resume execu
tion. The reader will verify that the stack is empty at this point.
In fact, the number of dashed lines indicating program suspen
sion indicates at the same time the number of levels there are in the
stack.
Exercise 6.22: If we assume that every time an interrupt occurs
the program counter PC, the register P, and the accumulator will
be saved, this will be a minimum of four locations. (In practice9X
250
INPUT/OUTPUT TECHNIQUES
and Y may be saved as well, resulting in six locations used). As
suming, therefore, that three registers only are saved in the stack,
how many interrupt levels does the 6502 allow? ^Remember that
the stack is limited to 256 locations with Page 1).
Exercise 6.23: Assuming this time that 5 registers may be pre
served in the stack, what is the maximum number of simultane
ous interrupts that can be handled? Will any other factor reduce even
further the number ofsimultaneous interrupts?
It must be stressed, however, that, in practice, microprocessor
systems are normally connected to a small number of devices
using interrupts. It is, therefore, unlikely that a high number of
simultaneous interrupts will occur in such a system.
We have now solved all the problems normally associated with
interrupts. Their use is, in fact, simple and they should be used to
advantage even by the novice programmer. Let us complete our
analysis of the 6502 resources by introducing one more instruc
tion whose effect is identical to that of a synchronous interrupt:
Break
The BRK command in the 6502 is the equivalent of a software
interrupt. It can be inserted in a program and results, just as in
the case of IRQ, in the automatic preservation of PC and P, and
an indirect branch to "FFFE"-"FFFF." This instruction can be
used to advantage to generate programmed interrupts during the de
bugging of a program. This will result in creating a breakpoint, halt
ing the program at a predetermined location, and branching to a
routine which will typically allow the user to analyze the pro
gram. Since the net effect of the break and an interrupt are iden
tical after they have occurred, a means must be provided for the
programmer to determine whether it was an interrupt or a break.
The 6502 will set a B-flag in register P (saved in the stack) to "1" if
it was a break and to "0" if it was an interrupt. Testing the status
of this bit may be accomplished by the following simple program:
BTEST PLA READ TOP OF STACK INTO A
PHA WRITE IT BACK
AND #\$10 MASK B-BIT
BNE BRKPRG GO TO BREAK PROGRAM
251
PROGRAMMING THE 6502
This test program is normally inserted at the end of the polling
sequence which determines the nature of the device that
triggered the interrupt.
Caution: A feature of the break is to preserve the contents of
the program counter plus 2 automatically. Since the break is only
a 1-byte instruction, the programmer may sometimes have to adjust
the contents of the program counter in the stack by using an
incrementing or decrementing instruction in order to resume
execution of the correct address. In particular, the break is exten
sively used during debugging by writing it over another instruc
tion in the program. If the program is reassembled prior to execu
tion, the contents of the program counter which have been saved
will normally have to be decremented by 1.
SUMMARY
We have presented in this chapter the range of techniques used
to communicate with the outside world. From elementary input/
output routines to more complex programs to communicate with
actual peripherals, we have learned to develop all the usual pro
grams and have even examined the efficiency of benchmark pro
grams in the case of a parallel transfer and a parallel-to-serial
conversion. Finally, we have learned to schedule the operation of
multiple peripherals by using polling and interrupts. Naturally,
many other exotic input/output devices might be connected to a
system. With the array of techniques which have been presented
so far, and with an understanding of the peripherals involved, it
should be possible to solve most usual problems.
In the next chapter, we will examine the actual characteristics
of the input/output interface chips usually connected to a 6502.
Then, we will consider the basic data structures that the pro
grammer may consider using.
EXERCISES
Exercise 6.24: A 7-segment LED display can also display digits
other than the hex alphabet Compute the codes forH,I,J,L,OtP,S,
252
INPUT/OUTPUT TECHNIQUES
Exercise 6.25: The flow-chart for interrupt management appears
in Figure 6-29 below. Answer the following questions:
a-What is done by hardware, what is done by software?
b- What is the use of the mask?
c-How many registers should be preserved?
d-How is the interrupting device identified?
e-What does the RTI instruction do? How does it differ from
a subroutine return?
f-Suggest a way to handle a stack overflow situation,
g- What is the overhead ("lost time") introduced by the interrupt
mechanism?
RETURN
Fig. 6-29: Interrupt Logic
253
7
INPUT/OUTPUT DEVICES
INTRODUCTION
We have learned how to program the 6502 microprocessor in
most usual situations. However, we should make a special men
tion of the input/output chips normally connected to the micro
processor. Because of the progress in LSI integration, new chips
have been introduced which did not exist before. As a result, pro
gramming a system requires, naturally, first programming a mi
croprocessor itself, but also programming the input/output chips.
In fact, it is often more difficult to remember how to program the
various control options of an input/output chip than to program
the microprocessor itself! This is not because the programming in
itself is more difficult, but because each of these devices has its
own idiosyncrasies. We are going to examine here first the most
general input/output device, the programmable input/output chip
(in short a "PIO"), then''improvements" over this standard PIO,
now frequently used with the 6502: the 6520, 6530, 6522 and
6532. The complete details are presented in reference D302.
The Standard PIO (6520)
There is no "standard PIO." However, the 6520 device is essen
tially analogous in function to all similar PIOs produced by other
manufacturers for the same purpose. The purpose of a PIO is to
provide a multiport connection for input/output devices. (A "port"
is simply a set of 8 input/output lines). Each PIO provides at least
254
INPUT/OUTPUT DEVICES
two sets of 8-bit lines for I/O devices. Each I/O device needs a data
buffer in order to stabilize the contents of the data bus on output
at least. Our PIO will, therefore, be equipped at a minimum with
a buffer for each port.
In addition, we have established that the microcomputer will
use a handshaking procedure, or else interrupts to communicate
with the I/O device. The PIO will also use a similar procedure to
communicate with the peripheral. Each PIO must, therefore, be
equipped with at least two control lines per port to implement the
handshaking function.
The microprocessor will also need to be able to read the status
of each port. Each port must be equipped with one or more status
bits. Finally, a number of options will exist within each PIO to
configure its resources. The programmer must be able to access a
special register within the PIO to specify the programming op
tions. This is the control register. In the case of the 6520, the
status information is part of the control register.
DATA BUS
IRQB
CRA DDRA PORA
Is!
REGISTER
SELECT
Irqa
*J
-^
RSO
RSI
CRB DDRB PDRB
PORT A
PORTB
Fig. 7-1: Typical PIO
One essential faculty of the PIO is the fact that each line may
be configured as either an input or an output line. The diagram of
a PIO appears in illustration 7-1. The programmer may specify
whether any line will be input or output. In order to program the
direction of the lines, a data direction register is provided for each
port. A "0" in a bit position of the data direction register specifies
an input. A "1" specifies an output.
255
PROGRAMMING THE 6502
It may be surprising to see that a "0" is used for input and a "1"
for output when really "0" should correspond to Output and "1" to
Input. This is quite deliberate: whenever power is applied to the
system, it is of great importance that all the I/O lines be confi
gured as input. Otherwise, if the microcomputer is connected to
some dangerous peripheral, it might activate it by accident.
When a reset is applied, all registers are normally zeroed and that
will result in configuring all input lines of the PIO as inputs. The
connection to the microprocessor appears on the left of the illus
tration. The PIO naturally connects to the 8-bit data bus, the mi
croprocessor address bus, and the microprocessor control bus.
The programmer will simply specify the address of any register
that it wishes to access within the PIO. The 6520, which is com
patible with Motorola's 6820, has inherited one of its peculiari
ties: it is equipped with 6 internal registers. However, one can
specify only one out of four registers! The way this problem is
solved is by switching bit position 2 of the control register. When
this bit is a "0," the corresponding data direction register may be
selected. When it is a "1," the data register may be selected.
Therefore, whenever the programmer wants to write data into the
data direction register, he will first have to make sure that bit 2
of the appropriate control register is zero, before he can select
this register. This is somewhat awkward to program, but it is im
portant to remember in order to avoid painful difficulties.
CRA IRQA1 IRQA2 CA2 CONTROL
DDRA I CA1
ACCESS I CONTROL
READ-ONLY READ/WRITE BY MPU
Fig. 7-2: PIA Control Word Format
RSI
0
0
0
1
1
1
RSO
0
0
1
0
0
1
CRA 2
1
0
-
-
-
CRB2
-
-
-
1
0
-
REGISTER SELECTED
PERIPHERAL REGISTER A
DATA DIRECTION REGISTER A
CONTROL REGISTER A
PERIPHERAL REGISTER B
DATA DIRECTION REGISTER B
CONTROL REGISTER B
Fig. 7-3: Addressing PIA Registers
256
INPUT/OUTPUT DEVICES
Td clarify the effect of the address selection on the 6520, the
address selection table appears above. RSO and RSI are two
register-selection signals which are derived from the address bus.
In other words, they represent two bits of the address specified by
the programmer. CRA is the control register for port A. CRA (2)
is bit 2 of this register. CRB is the control register for port B.
The Internal Control Register
The Control Register of the 6520 specifies, as we have seen, in
bit position 2, a selection mode for the internal registers of the
port. In addition, it provides a number of options for generating or
sensing interrupts, or for implementing automatic handshake
functions. The complete description of the facilities provided is
not necessary here. Simply, the user of any practical system which
uses the 6520 will have to refer to the data sheet showing the
effect of setting the various bits of the control register. Whenever
the system is initialized, the programmer will have to load the
control register of the 6520 with the correct contents for the ex
pected application.
PAO
VSS VCC
Fig. 7-4: 653O Pinout
257
PROGRAMMING THE 6502
The 6530
The 6530 implements a combination of four functions, RAM,
ROM, PIO, and TIMER. The RAM is a 64x8 memory. The ROM
is a 1Kx8 memory. The timer provides the programmer with mul
tiple interval timing facilities. The PIO section is essentially ana
logous to the 6520, which we have described: There are two ports,
each with a data register and a data direction register. A "0" in a
given bit position of the direction register specifies an input,
while a "1" specifies an output.
The programmable interval timer can be programmed to count
up to 256 intervals (it has 8 bits internally). The programmer may
specify the time period to be 1, 8, 64, or 1024 times the system dock.
Whenever the count is reached, the interrupt flag of the chip will be
set to a logic "1". The contents of the timer are set by means of the
data bus. The four possible time intervals must be specified on lines
A0 and Al of the address bus.
Three pins of port B have a dual role: PB5, PB6, and PB7 may
be used for control functions. Pin PB7, for example, may be pro
grammed as an interrupt input.
This chip is used, in particular, on the KIM board. (Note:
on the KIM, PB6 is not available.)
Programming a PIO
As an example, here is a program to use a 6520 or a 6522.
(\flfe assume that the control register has already been set).
LDA #FF SET DATA DIRECTION
STA DDRB CONFIGURE B FOR OUTPUT
LDA #00
STA IORB GENERATE ZERO OUTPUT
DDRB is the address of the Data Direction Register of port B for this
PIO. IORB is the Input/Output or data register for port B;
"FF" hexadecimal is "11111111" binary = all outputs.
The 6522
The 6522, also called "versatile interface adapter" (VIA), is an
improved version of the 6520. In addition to the capabilities of the
258
INPUT/OUTPUT DEVICES
IRQA
D0-D7
IRQB
Fig. 7-5: Using a PIA: Load Control Register
IRQA
D0-D7,
IRQB'
CONTROL
(CRB)
► PB0-PB7
. CB 1
»CB 2
Fig. 7-6: Using a PIA Load Data Direction
259
PROGRAMMING THE 6502
IRQA .
IRQB .
Fig. 7-7: Using a PIA: Read Status
IRQA .
D0-D7 ,
CSOCS1
-
CS2-
RSORS1
-
R/WENIRQB
•«-
260
pATABUS
BUFFER
BUS INPUT
CONTROL
CHIP SELECT
I REGISTER
SELECT
PERIPHERAL
INTERFACE B
DATA DIRECTION
(DDRB)
CONTROL
(CRB)
► PA0-PA7
PB0-PB7
CB 1
-CB 2
Fig. 7-8: Using a PiA: Read Input
INPUT/OUTPUT DEVICES
6520, it provides two programmable interval timers and a serialto-
parallel, plus parallel-to-serial converter, plus input data latch
ing. The detailed hardware description of this component is be
yond the scope of this book. Simply, with the description which
has been provided for the previous components, it should be
simple for the programmer to familiarize himself with the ad
dressing of the internal registers of this component as well as its
programming. This information is supplied in the manufacturer's
data sheets.
The 6532
The 6532 is a combination chip which includes one 128x8 RAM,
a PIO with two bi-directional ports, and a programmable interval
timer. It is used on the SYM board, manufactured by Synertek
Systems, which is analogous to the KIM board, manufactured
by MOS Technology and by Rockwell. Again, the user should
carefully examine the data sheets for this component in order to
learn how to address and use the various internal registers.
SUMMARY
Unfortunately, in order to make effective use of such compo
nents, it will be necessary to understand in detail the function of
every bit, or group of bits, within the various control registers.
These complex new chips automate a number of procedures that
had to be carried out by software or special logic before. In par
ticular, many of the handshaking procedures are automated with
in components such as a 6522. Also, some interrupt handling
and detection may be internal. With the information that has
been presented in the preceding chapter, the reader should be able
to read the corresponding data sheets and understand what the
functions of the various signals and registers are. Naturally, still
new components are going to be introduced which will offer a
hardware implementation of still more complex algorithms.
For a comprehensive description of I/O devices and techniques, the
reader is referred to the companion volume D302.
261
8
APPLICATION EXAMPLES
INTRODUCTION
This chapter is designed to test your new programming skills by
presenting ^ collection of utility programs. These programs, or
"routines," are frequently encountered in applications and are generally
called "utility routines." They will require a synthesis of the knowledge
and techniques presented so far.
We are going to fetch characters from an I/O device and process
them in various ways. But first, let us clear an area of the memory
(this may not be necessary; each of these programs is only presented as
a programming example).
CLEAR A SECTION OP MEMORY
We want to clear (zero) the contents of the memory from ad
dress BASE + 1 to address BASE + LENGTH, where
length is less than 256.
The program is:
262
APPLICATION EXAMPLES
ZEROM LDX #LENGTH
LDA#0
CLEAR STA BASE, X
DEX
BNE CLEAR
RTS
Note that register X is used as an index to point to the current
location of the memory section to be zeroed.
The accumulator A is loaded only once with the value 0 (all O's),
then written at successive memory locations:
BASE + LENGTH, BASE + LENGTH - 1, etc., until X dec
rements to zero. When X=0, the program returns.
In a memory test for example, this program could be used to zero
a block, then verify its contents.
Exercise 8.1: Write a memory test program which will zero a 256-word
block and verify that each location is 0. Then, it will write all 19s and
verify the contents of the block. Next, it will write 01010101 and verify
the contents. Finally, it will write 10101010 and verify the contents.
Let us now poll our I/O devices to find which one needs service.
POLLING I/O DEVICES
We will assume that 3 I/O devices are connected to our system.
Their status registers are located at addresses I0STATUS1,
IOSTATUS2, and IOSTATUS3.
If their status bits are in bit position 7, we will just read the status
registers, and test their sign bits. If the status bits are anywhere else,
we will take advantage of the BIT instruction of the 6502:
263
PROGRAMMING THE 6502
TEST LDA
BIT
BNE
BIT
BNE
BIT
BNE
(failure
MASK
IOSTATUS1
FOUND1
IOSTATUS2
FOUND 2
IOSTATUS3
FOUND3
exit)
The MASK will contain, for example, "00100000" if we test bit
position 5. As a result of the BIT instruction, the Z bit of the
status flap will be set to 0 if "MASK AND IOSTATUS" is non
zero i.e. if the corresponding bit of IOSTATUS matches the one
in MASK. The BNE instruction (branch if non-equal to zero)
will then result in a branch to the appropriate FOUND routine.
GETTING CHARACTERS IN
Assume we have just found that a character is ready at the key
board. Let us accumulate characters in a memory area called
buffer until we encounter a special character called SPC, whose
code has been previously defined.
The subroutine GETCHAR will fetch one character from the
keyboard (see Chapter 6 for more details) and leave it in the ac
cumulator. We assume that a maximum of 256 characters will be
fetched before an SPC character is found.
INITIALIZE INDEX TO ZERO
IS IT THE BRK CHAR?
IF SO, FINISHED
NO: SAVE CHAR
INCREMENT POINTER
GET NEXT CHAR
STRING
NEXT
OUT
LDX
JSR
CMP
BEQ
STA
INX
JMP
RTS
#0
GETCHAR
#SPC
OUT
BUFFER, X
NEXT
264
APPLICATION EXAMPLES
Exercise 8.2: Let us improve this basic routine:
a-Echo the character back to the device (for a Teletype, for example)
b-Check that the input string is no longer than 256 characters
We now have a string of characters in a memory buffer. Let us
process them in various ways.
TESTING A CHARACTER
Let us determine if the character at memory location LOC is
equal to 0,1, or 2:
ZOT LDA
CMP
BEQ
CMP
BEQ
CMP
BEQ
JMP
LOC
#\$00
ZERO
#\$01
ONE
#\$02
TWO
NOTFND
We simply read the character, then use the CMP instruction to check
its value.
Let us run a different test now.
BRACKET TESTING
Let us determine if the ASH character at memory location LOC
is a digit between 0 and 9:
BRACK
OUT
LDA
ADC
LDA
ORA
CMP
BCC
CMP
BEQ
BCS
CLC
CLV
RTS
#\$40
#\$40
LOC
#\$80
#\$B0
TOOLOW
#\$B9
OUT
TOOHIGH
FORCE OVEF
SET BIT 7=1
ASCII 0
ASCII 9
9 EXACTLY
265
PROGRAMMING THE 6502
TOOLOW SEC SET C TO ONE
CLV
RTS
TOOHIGH RTS (CISONE)
ASCII 0 is represented in hexadecimal by "BO"
ASCII 9 is represented in hexadecimal by "B9"
Remember that when using a CMP instruction, the carry bit will be
set if the value of the literal that follows is less than or equal to the
accumulator. It will be reset (0) if greater.
If BO is greater than the character, our character is too low, and
a branch occurs.
We then compare it against B9. If it is less than or equal to 9,
all is well, and we exit. Otherwise, we go to TOOHIGH.
When we exit from this program, we want to know if the number
is TOOLOW, TOOHIGH, or else between 0 and 9. This will be
indicated by the flags C and V. V is not altered by CMP, whereas Z, N
and C are.
When returning from the subroutine, a"0"in V indicates "too low," a
"1" in V indicates "too high," and a "0" in C indicates a correct digit
between 0 and 9.
Naturally, other conventions could be used, such as loading a digit
in the accumulator to indicate the result of the tests.
Exercise 8.3: Simplify the above program by testing against the
ASCII character which follows "9" instead of testing against 9
exactly.
Exercise 8.4: Determine if an ASCII character contained in the
accumulator is a letter of the alphabet
266
APPLICATION EXAMPLES
When using an ASCII table, you will notice that parity is often
used. (The example above does not use parity.) For example, the
ASCII for "0" is "0110000," a 7-bit code. However, if we use odd
parity,! for example we guarantee that the total number of ones
in a word is odd), then the code becomes "10110000." An extra
"1" is added to the left. This is "B0" in hexadecimal. Let us there
fore develop a program to generate parity.
PARITY GENERATION
This program will generate an even parity in bit position 7:
PARITY
NEXT
ONE
ZERO
LDX
LDA
STA
LDA
ROL
ROL
BCC
INC
DEX
BNE
ROL
ROL
LSR
ROR
RTS
#\$07
#\$00
ONECNT
CHAR
A
A
ZERO
ONECNT
NEXT
A
A
ONECNT
A
BIT COUNT
COUNT OF l'S
READ CHARACTER
DISCARD BIT 7
NEXT BIT
IS IT A 1?
DECREMENT BIT COUNT
LAST BIT?
RESTORE BIT 0
DISCARD BIT
RIGHTMOST BIT IS PARITY
PUT IT IN A
Register X is used to count bits as they are shifted left from the
accumulator. Every time that a "1" is shifted off the left of A
(it is tested by BCC), the one-counter is incremented. When 8
bits have shifted (the program ignores bit 7 which will be
the parity bit), A is shifted left two more times so that bit 6 is on
the left of A.
The correct parity bit is the right-most bit of ONECNT; it is installed
into the carry bit by LSR and becomes bit 7 of A. Another ROR
A copies this bit back into position 7 of A, and we are finished.
267
PROGRAMMING THE 6502
Exercise 8.5: Using the above program as an example, verify the
parity of a word You must compute the correct parity, then com
pare it to the one expected.
CODE CONVERSION: ASCII to BCD
Converting ASCII to BCD is very simple. We will observe that
the hexadecimal representations of ASCII characters 0 to 9 are BO to B9
with parity, or 30 to 39 without parity. The BCD representation is
simply obtained by dropping the "B"; that is, by masking off the left
nibble (4 bits):
LDA CHAR
AND #\$OF MASK OFF LEFT NIBBLE
STA BCDCHAR
Exercise 8.6: Write a program to convert BCD to ASCII
Exercise 8.7: (more difficult) Write a program to convert BCD to
binary.
Hint: N3 N2 Ni No in BCD is (((Na x 10) + N2) x 10 + Ni) x 10
+ No in binary.
To multiply by 10, use a left shift (=x2), another left shift (=x4),
an ADC (=x5), and another left shift(=xlO).
In full BCD notation, the first word may contain the count of
BCD digits, the next nibble may contain the sign, and every successive
nibble may contain a BCD digit. (We assume no decimal point ).The last
nibble of the block may be unused.
FIND THE LARGEST ELEMENT OF A TABLE
The beginning address of the table is contained at memory ad
dress BASE in page zero. The first entry of the table is the num
ber of bytes it contains. This program will search for the largest
element of the table. Its value will be left in A, and its position
will be stored in memory location INDEX.
268
MAX LDY
LDA
TAY
LDA
STA
LOOP CMP
BCS
LDA
STY
NOSWITCH DEY
BNE
RTS
#0
(BASE), Y
#0
INDEX
(BASE), Y
NOSWITCH
(BASE), Y
INDEX
LOOP
APPLICATION EXAMPLES
This program uses registers A and Y, and will use indirect addressing,
so that it can search any table anywhere in the memory.
THIS IS OUR INDEX TO TABLE
ACCESS ENTRY 0=LENGTH
SAVE IT IN Y
MAX VALUE INITIALIZED TO ZERO
INITIALIZE INDEX TO ZERO
IS CURRENT MAX ELEMENT?
YES?
LOAD NEW MAX
LOCATION OF MAX
POINT TO NEXT ELEMENT
KEEP TESTING?
FINISH IF Y=0
This program tests the Nth entry first. If it is greater than 0, it
goes in A, and its location is remembered into INDEX. The (N-l)st
entry is then tested, etc.
This program works for positive integers.
Exercise 8.8: Modify the program so that it works also for nega
tive numbers in two's complement.
Exercise 8.9: Will this program also work for ASCII characters?
Exercise 8.10: Write a program which will sort N numbers in as
cending order.
Exercise 8.11: Write a program which will sort N names (3 char
acters each) into alphabetical order.
SUM OF N ELEMENTS
This program will compute the 16-bit sum of N entries of a table.
The starting address of the table is contained at memory address
BASE in page zero. The first entry of the table contains the num
ber of elements N. The 16-bit sum will be left in memory locations
SUMLO and SUMHI. If the sum should require more than 16
bits, only the lower 16 will be kept. (The high-order bits are said to be
truncated.)
269
PROGRAMMING THE 6502
This program will modify registers A and Y. It assumes 256
elements maximum.
LDA
STA
STA
TAY
LDA
TAY
CLC
ADLOOP LDA
ADC
STA
BCC
INC
CLC
NOCARRY DEY
BNE
RTS
#0
SUMLO
SUMHI
(BASE), Y
(BASE), Y
SUMLO
SUMLO
NOCARRY
SUMHI
ADLOOP
INITIALIZE SUM
INITIALIZE SUM
INITIALIZE SUM
INITIALIZE Y TO ZERO
GETN
INTOY
CLEAR CARRY FOR ADC
GET NEXT ELEMENT
ADD IT TO SUMLO
SAVE RESULT
CARRY?
ADD IT TO SUMHI
FOR NEXT SUM
NEXT ELEMENT
AGAIN IF Y NOT ZERO
This program is straightforward and should be self-explanatory.
Exercise 8.12: Modify this program to compute:
a) a 24-bit sum,
b) a 32-bit sum,
c) to detect any overflow.
A CHECKSUM COMPUTATION
A checksum is a digit, or set of digits, computed from a block of
successive characters. The checksum is computed at the time the
data is stored and put at the end. In order to verify the integrity
of the data, the data is read and the checksum is recomputed and
compared against the stored value. A discrepancy indicates an error
or a failure.
270
APPLICATION EXAMPLES
Several algorithms are used. Here, we will sxclusive-OR all bytes
in a table of N elements, and leave the result in the accumulator.
As usual, the base of the table is stored at the address BASE in
page zero. The first entry of the table is its number of elements N.
The program modifies A and Y. N must be less than 256.
CHECKSUM LDY
LDA
TAY
LDA
CHLOOP EOR
DEY
BNE
RTS
#0 POINT TO FIRST ENTRY
(BASE),Y GETN
STORE IT IN Y
#0 INITIALIZE CHECKSUM
(ADDR), Y EOR NEXT ENTRY
POINT TO NEXT
CHLOOP KEEP GOING
COUNT THE ZEROES
This program will count the number of zeroes in our usual table,
and leave it in register X.
It modifies A,X,Y:
ZEROES
ZLOOP
NOTZ
LDY
LDA
TAY
LDX
LDA
BNE
INX
DEY
BNE
RTS
#0 POINT TO FIRST ENTRY
(ADDR), Y GETN
STORE IT IN Y
#0 INITIALIZE NO. OF ZEROES
(ADDR), Y GET NEXT ENTRY
IS IT ZERO?
YES. COUNT IT
POINT TO NEXT
KEEP GOING
NOTZ
ZLOOP
Exercise 8.13: Modify this program to count:
a-the number ofstars (the character "*")
b-the number of letters of the alphabet
c-the number of digits between 0 and 9
A STRING SEARCH
A string of characters is stored in the memory, as indicated in
Fig 8-1 We will search the string for the occurrence of a shorter
one, called a template (TEMPLT), of length TPTLEN.The length
of the original string is STRLEN, and the program will return
271
PROGRAMMING THE 6502
with register X containing the location where the TEMPLT was
found, and FF hexadecimal otherwise. The flowchart for the pro
gram is shown in Fig. 8-2. The string is first scanned for the oc
currence of the first character in TEMPLT. If this first character
is never found, the program will exit with a failure. If this first
character is found, the second character will be matched against
the next one in the string. If that fails, the search is restarted for
the first character since there might be another occurrence of this
first character within the original string. If the first and the sec
ond one match, the search will proceed with the following charac
ters of TEMPLT in the same manner. The corresponding pro
gram is shown in Fig. 8-3. Note that Register X is used as the
running pointer during the search pointing to the current element
of string. Indexed addressing is naturally used to retrieve the
current element of string.
0
\$10
\$20
\$50
\$FF
STRING LENGTH
TEMPLATE LENGTH
(SEARCH START POINTER
Fig: 8-1: String Search: The Memory
272
APPLICATION EXAMPLES
Fig. 8-2: Program Flowchart: String Search
273
PROGRAMMING THE 6502
LINE
0002
0003
0004
0005
0004
O007
O008
O009
ooto
00 tl
0012
O013
OOH
O015
0016
0017
O0I8
O019
O020
0021
0022
O023
0024
O02S
O026
0027
0028
0029
0030
0031
O032
0033
0034
O03S
O036
0037
0038
0039
0040
0041
1 IOC
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0010
0011
0012
0013
0014
0200
0202
0204
0206
0208
0209
0206
020D
020F
0210
0212
0212
0214
0216
0218
021A
021C
02IE
0220
0223
0225
0228
022A
022C
0220
A2
AS
OS
FO
E8
E4
DO
A2
60
86
A9
83
E6
E6
A4
C4
FO
19
A4
09
DO
FO
60
CODE
00
SO
20
08
12
F5
ff
11
00
10
11
10
10
13
OC
SO 00
11
20 00
0E
EA
LINE
;STIING SEARCH.
JFINDS LOCATION IN STRING OF LENfTI 'STRLEN'
{STARTING AT 'STUMS' OF A TEMPLATE OF
;len8th 'tptlen' stAtTine at 'tehply', and
;RETURNS VITN X-LOCATION OF TEMPLATE
('IN STRIN8 IF FOUND,
t
STRIN6 >
TEHPLT i
CHKPTR <
TENPTR i
STRLEN *
TPTLEN <
' 120
> ISO
> * 110
»••♦!
>*♦♦!
>■♦♦!
>«•♦!
► « 1200
L0X 10
NXTPOS L0A TENPLT
CNP STRIN6VX
DEO CHECK
NXTSTR INX
CPX STRLEN
0NE NXTPOS
L0X BIFF
RTS
CHECK 8TX TENPTR
OR X'fFF IF NOT FOUND.
;1ST LOCATIOi OF STRING.
;1ST LOCATION OF TEMPLATE.
;lensth of string.
;LEN6TH OF TEMPLATE.
,'RESET SEARCH START POINTER.
JIS FIRST ElENENT OF TEMPLATE...
;« CURRENT STRIN6 ELENENTT
,'IF YES, CHECK FOR REST OF MATCH.
f*INCREMENT SEARCH START COUNTER.
;IS IT EQUAL TO STRIN8 LEN6TN?
;no, check next string position.
JVES, SET 'NOT FOUND' INDICATOR.
;RETURNi ALL CHRS CHECKED.
:let tenporary pointer*
,'CURRENT 8TRIN6 POINTER.
L0A 80
8TA CHKPTR
CHKLP INC TENPTR
INC CHKPTR
LDY CHKPTR
CPY TPTLEN
0EO FOUND
LDA TENPLT,Y
LDY TEHPTR
CNP STRIN6,Y
DNE NXTSTR
BEO CHKLP
FOUND RTS
END
;keset template pointer.
;INCRENENT TENPORARY POINTER.
;INCRENENT TENPLATE POINTER.
;D0E8 TENPLATE POINTER=TENPLATE LENG
;IF YES, TENPLATE HATCHED.
JLOAD TENPLATE ELENENT.
;COHPARE TO STRING CHR.
f'IF NO NATCH, CHECK NEXT STtllG CNR.
V'IF NATCH, CHECK NEXT CNR.
;done.
Fig. 8-3: String Search Program
SUMMARY
In this chapter, we have presented common utility routines which use
combinations of the techniques described in previous chapters. These
routines should now allow you to start designing your own programs.
Many of them have used a special data structure, the table. However,
other possibilities exist for structuring data, and these will now be
reviewed.
274
DATA STRUCTURES
PART I: DESIGN CONCEPTS
INTRODUCTION
The design of a good program involves two tasks: algorithm
design and data structures design. In most simple programs, no
significant data structures are involved, so the main problem that
must be surmounted to learn programming is learning how to
design algorithms and code them efficiently in a given machine lan
guage. This is what we have accomplished here. However, design
ing more complex programs also requires an understanding of data
structures. Two data structures have already been used through
out the book: the table, and the stack. The purpose of this chapter
is to present other, more general, data structures that you may
want to use. This chapter is completely independent from the
microprocessor, or even the computer, selected. It is theoretical
and involves logical organization of data in the system. Specialized
books exist on the topic of data structures, just like specialized
books exist on the subject of efficient multiplication, division or
other usual algorithms. This single chapter, therefore, should be con
sidered as an overview, and it will be necessarily limited to the essentials
only. It does not claim to be exhaustive.
Let us now review the most common data structures:
POINTERS
A pointer is a number which is used to designate the location of
the actual data. Every pointer is an address. However, every ad-
275
PROGRAMMING THE 6502
dress is not necessarily called a pointer. An address is a pointer on
ly if it points at some type of data or at structured information. We
have already encountered a typical pointer, the stack pointer,
which points to the top of the stack (or usually just over the top of
the stack). We will see that the stack is a common data structure,
called a LIFO structure.
As another example, when using indirect addressing, the in
direct address is always a pointer to the data that one wishes to
retrieve.
Exercise 9.1: Examine Figure 9-1. At address 15 in the memory,
there is a pointer to Table T. Table T starts at address 500. What
are the actual contents of the pointer to T?
500
— POINTER TO T —
TABLE T
Fig 9-1: An Indirection Pointer
LISTS
Almost all data structures are organized as lists of various
kinds.
Sequential Lists
A sequential list, or table, or block, is probably the simplest data
structure, and one that we have already used. Tables are normally
276
DATA STRUCTURES
ordered in function of a specific criterion, such as, for example,
alphabetical ordering, or numerical ordering. It is then easy to
retrieve an element in a table, using, for example, indexed address
ing, as we have done. A block normally refers to a group of data
which has definite limits but whose contents are not ordered. It
may, for example, contain a string of characters. Or it may be a
sector on a disk. Or it may be some logical area (called segment) of
the memory. In such cases, it may not be easy to access a random
element of the block.
In order to facilitate the retrieval of blocks of information, directories
are used.
Directories
A directory is a list of tables, or blocks. For example, the file
system will normally use a directory structure. As a simple exam
ple, the master directory of the system may include a list of the
users' names. This is illustrated in Figure 9-2. The entry for user
"John" points to John's file directory. The file directory is a table
which contains the names of all of John's files and their location.
This is, again, a table of pointers. In this case, we have just de
signed a two-level directory. A flexible directory system will allow
the inclusion of additional intermediate directories, as may be
found convenient by the user.
USER DIRECTORY
JOHN
JOHN'S
FILE DIRECTORY
ALPHA
SIGMA
JOHN'S FILE
ALPHA
DATA
Fig. 9-2: A Directory Structure
277
PROGRAMMING THE 6502
Linked List
In a system there are often blocks of information which repre
sent data, or events, or other structures, which cannot be easily
moved. If they could be easily moved, we would probably assemble
them in a table in order to sort them or structure them. The
problem now is that we wish to leave them where they are and
still establish an ordering between them such as first, second,
third, and fourth. A linked list will be used to solve this pro
blem. The concept of a linked list is illustrated by Figure 9-3. In
the illustration, we see that a list pointer, called FIRSTBLOCK,
points to the beginning of the first block. A dedicated location
within Block 1, such as, perhaps, the first or the last word of it,
contains a pointer to Block 2, called PTRl. The process is then re
peated for Block 2 and Block 3. Since Block 3 is the last entry in
the list, PTR3, by convention, contains a special "nil" value, or
else points to itself, so that the end of the list can be detected. This
structure is economical as it requires only a few pointers (one per
block) and prevents the user from having to physically move the
blocks in the memory.
FIRST
BLOCK
BLOCK 1 BLOCK 2
Fig. 9-3: A Linked List
BLOCK 3
Let us examine, for example, how a new block will be inserted.
This is illustrated by Figure 9-4. Let us assume that the new block
is at address NEWBLOCK, and is to be inserted between Block 1
and Block 2. Pointer PTRl is simply changed to the value NEWBLOCK,
so that it now points to Block X. PTRX will contain the
former value of PTRl (i.e., it will point to Block 2). The other
pointers in the structure are left unchanged. We can see that the inser
tion of a new block has simply required updating two pointers in
the structure. This is clearly efficient.
Exercise 9.2: Draw a diagram showing how Block 2 would be
removed from this structure.
Several types of lists have been developed to facilitate specific
278
DATA STRUCTURES
NEW BLOCK ■
FIRST^
BLOCK
BLOCK 1 Jl
BLOCK X h
BLOCK 2 2|PT1R BLOCK 3 3|PT1R Fig. 9-4: Inserting a New Block
types of access or insertions or deletions to or from the list. Let us
examine some of the most frequently used types of linked lists:
Queue
A queue is formally called a FIFO, or first-in-first-out list. A
queue is illustrated in Figure 9-5. To clarify the diagram, we can
assume, for example, that the block on the left is a service routine
for an output device, such as a printer. The blocks appearing on the
right are the request blocks from various programs or routines, to
print characters. The order in which they will be serviced is the
Fig. 9-5: A Queue
279
PROGRAMMING THE 6502
order established by the waiting queue. It can be seen that the
next event which will obtain service is Block 1, then Block 2, and finally
Block 3. In a queue, the convention is that any new event arriving in the
queue will be inserted at the end of it. Here it will be inserted after
PTR3. This guarantees that the first block to have been inserted in the
queue will be the first one to be serviced. It is quite common in a com
puter system to have waiting queues for a number of events whenever
they must wait for a scarce resource, such as the processor or some
input/output device.
Stack
The stack structure has already been studied in detail through
out the book. It is a last-in-first-out structure (LIFO). The last ele
ment deposited on top of it is the first one to be removed. A stack
may be implemented as a sorted block, or else it may be imple
mented as a list. Because most stacks in microprocessors are used
for high speed events, such as subroutines and interrupts, a contin
uous block is usually allocated to the stack rather than using a
linked list.
Linked List vs. Block
Similarly, the queue could be implemented as a block of reserved
locations. The advantage of using a continuous block is fast
retrieval and the elimination of the pointers. The disadvantage is
that it is usually necessary to dedicate a fairly large block to ac
commodate the worst-case size of the structure. Also, it makes it
difficult or impractical to insert or remove elements from within
the block. Since memory is traditionally a scarce resource, blocks
have been traditionally reserved for fixed-size structures or else
structures requiring the maximum speed of retrieval, such as the
stack.
Circular List
"Round robin" is a common name for a circular list. A circular
list is a linked list where the last entry points back to the first one.
This is illustrated in Figure 9-6. In the case of a circular list, a
current-block pointer is often kept. In the case of events or pro
grams waiting for service, the current-event pointer will be moved
by one position to the left or to the right every time. A round-robin
usually corresponds to a structure where all blocks are assumed to
280
DATA STRUCTURES
have the same priority. However, when performing a search a circular
list may also be used as a subcase of other structures simply to facilitate
the retrieval of the first block after the last one.
As an example of a circular list, a polling program usually goes
around in a round-robin fashion, interrogating all peripherals and
then coming back to the first one.
U- EVENT 1 |"H EVENT 2 ""*" * * * ~"*" EVENT N |
CURRENT EVENT
Fig. 9-6: Round-Robin is Circular List
Trees
Whenever a logical relationship exists between all elements of a
structure (this is usually called a syntax), a tree structure may be
used. A simple example of a tree structure is a descendant tree or a
genealogical tree. This is illustrated in Figure 9-7. It can be seen
that Smith has two children: a son, Robert, and a daughter, Jane.
Jane, in turn, has three children: Liz, Tom and Phil. Tom, In turn
has two more children: Max and Chris. However, Robert, on the
left of the illustration, has no descendants.
This is a structured tree. We have, in fact, already encountered
an example of a simple tree in Figure 9-2. The directory structure
is a two-level tree. Trees are used to advantage whenever elements
may be classified according to a fixed structure. This facilitates in
sertion and retrieval. In addition, trees may establish groups of infor
mation in a structured way. Such information may be required for later
processing, such as in a compiler or interpreter design.
Doubly-Linked Lists
Additional links may be established between elements of a list.
The simplest example is the doubly-linked list. This is illustrated
in Figure 9-8. We can see that we have the usual sequence of links
from left to right, plus another sequence of links from right to left.
281
PROGRAMMING THE 6502
Fig. 9-7: Genealogical Tree
The goal is to allow easy retrieval of the element just before the
one which is being processed, as well as the one just after it. This costs
an extra pointer per block.
BLOCKl BLOCK 2 BLOCK 3
Fig. 9-8: Doubly-Linked List
SEARCHING AND SORTING
Searching and sorting elements of a list depend directly on the
type of structure which has been used for the list. Many searching
algorithms have been developed for the most frequently used data
structures. We have already used indexed addressing. This is pos
sible whenever the elements of a table are ordered in function of a
known criterion. Such elements may then be retrieved by their
numbers.
Sequential searching refers to the linear scanning of an entire
block. This is clearly inefficient but, for lack of a better technique, may
have to be used whenever the elements are not ordered.
282
DATA STRUCTURES
Binaryt or logarithmic searching, attempts to find an element in a
sorted list by dividing the search interval in half at every step.
Assuming, for example, that we are searching an alphabetical list,
one might start in the middle of a table and determine if the name
for which we are looking is before or after this point. If it
is after this point, we will eliminate the first half of the table and
look at the middle element of the second half. We again compare
this entry to the one for which we are looking, and restrict our search
to one of the two halves, and so on. The maximum length of a
search is then guaranteed to be log2n, where n is the number of
elements in the table.
Many other search techniques exist.
SUMMARY
This section was intended as only a brief presentation of typical
data structures which may be used by a programmer. Although
most common data structures have been rationalized in types and
given a name, the overall organization of data in a complex system
may use any combination of them, or require the programmer to
invent more appropriate structures. The array of possibilities is
limited only by the imagination of the programmer. Similarly, a
number of well-known sorting and searching techniques have been
developed to cope with the usual data structures. A comprehensive
description is beyond the scope of this book. The contents of this
section were intended to stress the importance of designing appro
priate data structures for the data to be manipulated and to pro
vide the basic tools to that effect.
283
DATA STRUCTURES
PART II: DESIGN EXAMPLES
INTRODUCTION
Actual design examples will be presented here for typical data
structures: table, linked list, sorted tree. Practical sorting, search
ing and insertion algorithms will be programmed for these struc
tures. Additional advanced techniques such as hashing and merg
ing will also be described.
The reader interested in these advanced programming tech
niques is encouraged to analyze in detail the programs presented
in this section. However, the beginning programmer may skip this
section initially, and come back to it when he feels ready for it.
A good understanding of the concepts presented in the first part
of this chapter is necessary to follow the design examples. Also,
the programs will use all the addressing modes of the 6502, and
integrate many of the concepts and techniques presented in the
previous chapters.
Four structures will now be introduced: a simple list, an alpha
betical list, a linked list plus directory, and a tree. For each struc
ture, three programs will be developed: search, enter and delete.
In addition, three specialized algorithms will be described separately
at the end of the section: hashing, bubble-sort, and merging.
284
DATA STRUCTURES
ENTLEN
TABLEN
TAB BASE
ENTRY
H LABEL —
DATA
LENGTH OF ENTRY
NUMBER OF ENTRIES
M BYTES
ENTER NEW ELEMENT
Fig. 9-9: The Table Structure
ELEMENT
1
ELEMENT
2
LABEL
DATA
LABEL
DATA
ENTLEN
ENTLEN
Fig 9-10: Typical List Entries in the Memory
285
PROGRAMMING THE 6502
DATA REPRESENTATION FOR THE LIST
Both the simple list and the alphabetic list will use a common re
presentation for each list element:
c c c D D D D
3-byte label data
Each element or "entry" includes a 3-byte label and an n-byte
block of data with n between 1 and 253. Thus, each entry uses, at
most, one page (256 bytes). Within each list, all elements have the
same length (see Fig. 9-10). The programs operating on these two
simple lists use some common variable conventions:
ENTLEN is the length of an element. For example, if each ele
ment has 10 bytes of data, ENTLEN = 3 + 10 = 13 bytes
TABASE is the base of the list or table in the memory
POINTR is a running pointer to the current element
OBJECT is the current entry to be inserted or deleted
TABLEN is the number of entries
All labels are assumed to be distinct. Changing this convention
would require a minor change in the programs.
A SIMPLE LIST
The simple list is organized as a table of n elements. The
elements are not sorted (see Fig. 9-11).
When searching, one must scan through the list until an entry is
found or the end of the table is reached. When inserting, new en
tries are appended to the existing ones. When an entry is deleted,
the entries in higher memory locations, if any, will be shifted down
to keep the table continuous.
Searching
A serial search technique is used. Each entry's label field is com
pared in turn to the OBJECT'S label, letter by letter.
The running pointer POINTR is initialized to the value of
TABASE.
The index register X is initialized to the number of entries con
tained in the list (stored at TABLEN).
286
DATA STRUCTURES
IlENGTH =
ENTLEN
OBJECT
TO BE INSERTED
Fig. 9-11: The Simple List
The search proceeds in the obvious way, and the corresponding
flowchart is shown in Fig. 9-12. The program appears in Fig.
9-16 at the end of this section (program "SEARCH").
Element Insertion
When inserting a new element, the first available memory block
of (ENTLEN) bytes at the end of the list is used (see Fig. 9-11).
The program first checks that the new entry is not already in the
list (all labels are assumed to be distinct in this example). If not, it
increments the list length TABLEN, and moves the OBJECT to
the end of the list. The corresponding flowchart is shown on Fig.
9-13.
The program is shown on Fig. 9-16 at the end of this section. It is
called "NEW" and resides at memory locations 0636 to 0659.
Element Deletion
In order to delete an element from the list, the elements follow
ing it at higher addresses are merely moved up by one element position.
The length of the list is decremented. This is illustrated in Fig. 9-14.
287
PROGRAMMING THE 6502
SEARCH
COUNTER =
NUMBER OF ENTRIES
COUNTER = COUNTER - 1
FAILURE EXIT
FOUND
(SET A TO "FF")
FAILURE EXIT
Fig. 9-12: Table Search Flowchart
288
DATA STRUCTURES
EXIT
END
Fig. 9-13: Table Insertion Flowchart
The corresponding program is straightforward and appears in
Fig. 9-16. It is called "DELETE" and resides at memory ad
dresses 0659 to 0686. The flowchart is shown in Fig. 9-15.
Memory location TEMPTR is used as a temporary pointer point
ing to the element to be moved up.
Index register Y is set to the length of a list element, and used to
automate block transfers. Note that indirect indexed addressing is
used:
(0672) LOOPE DEY
LDA
STA
CPY
BNE
(TEMPTR), Y
(POINTR), Y
#0
LOOPE
During the transfer, POINTR always points to the "hole" in the
list, i.e. the destination of the next block transfer.
The Z flag is used to indicate a successful deletion upon exit.
289
PROGRAMMING THE 6502
DELETE •
TEAAPTR •
BEFORE
©
©
0
©
MOVE
MOVE
AFTER
©
0
©
Fig. 9-14: Deleting An Entry (Simple List)
ALPHABETIC LIST
The alphabetic list, or "table" unlike the previous one, keeps all
its elements sorted in alphabetic order. This allows the use of
faster search techniques then the linear one. A binary search is
used here.
Searching
The search algorithm is a classical binary search. Let us recall
that the technique is essentially analogous to the one used to find a
name in a telephone book. One usually starts somewhere in the middle
of the book, and then, depending on the entries found there, goes either
backwards or forwards to find the desired entry. This method is fast,
and it is reasonably simple to implement.
The binary search flowchart is shown in Fig. 9-17, and the pro
gram is shown in Fig. 9-22.
This list keeps the entries in alphabetical order and retrieves
them by using a binary or "logarithmic" search. An example is
shown in Fig. 9-18.
290
DATA STRUCTURES
FIND ENTRY
■► OUT
DECREMENT TABLE LENGTH
FIND NBR OF ENTRIES
AFTER OBJECT IN TABLE
DECREASE COUNT OF
ENTRIES REMAINING
AFTER THE ONE SHIFTED
EXIT
OUT
Fig. 9-15: Table Deletion Flow Chart
291
PROGRAMMING THE 6502
LINE
0002
0009
0004
OOOS
0004
0007
0001
0009
ooto
0011
0012
0013
0014
O01S
0016
0017
0011
001?
O020
O02I
0022
0023
0024
O02S
0026
0027
0028
0029
0030
0031
0032
0033
0034
0035
0036
0037
O038
0039
0040
0041
O042
0043
0044
0045
0046
0047
0048
0049
0050
0051
0052
0053
0054
0055
0056
O057
0058
0059
0060
0061
O062
O063
0064
0065
0066
O067
0068
• IOC
0000
0000
0000
ooot
OOM
0000
0000
0000
0600
0600
0602
0604
0606
0608
060ft
06K
060E
0610
0612
0614
0615
0617
0619
0611
061C
061E
0620
0622
0623
0625
0627
0628
062A
062C
062E
0630
0633
0635
0636
0636
0636
0636
0639
063B
0630
063F
0641
0642
0644
0646
0648
064A
064C
064E
0650
0652
0654
0655
0656
0658
0659
0659
0659
0659
065C
065E
0660
AS
85
AS
85
A4
ro
AO
•1
11
10
C8
11
11
10
ct
11
PI
FO
CA
FO
AS
18
65
65
90
E6
4C
A9
60
20
SO
A6
FO
A5
18
65
85
90
E6
E6
AO
A6
B1
91
C8
CA
90
60
20
FO
C6
CA
CUE
10
12
11
13
14
29
H
15
12
OE
IS
12
07
15
12
11
10
17
12
12
DE
13
OC 06
rr
00 06
ID
14
OB
12
17
12
02
13
14
00
17
15
12
F8
00 06
20
14
HIE
TAM8E • »10
POINTR > 112
TAKE! > 114
OBJECT - US
ENTLEN « \$17
TENPTR > 118
•
•H400
SEARCH IDA TABASE
STA POINT*
LBA TABASE*1
STA POINTR*1
LBI TABLE*
BEO OUT
ERTRT LIT 10
LBA (OBJECT)
CMP (POINTR)
BNE N0600B
INY
LBA (OBJECT)
CMP (POINTR)
BNE N0600B
INY
LBA (OBJECT)
CNP (POINTR)
ICO FOUND
N0600D BEX
BEO OUT
LBA ENTLEN
CLC
ABC POINTR
STA POINTR
BCC ENTRY
INC POINTR*1
JHP ENTRY
FOUNB LOA ItFF
OUT RTS
;
•
NEU JSR SEARCH
BNE OUTE
LBX TABLEN
BEO INSERT
LDA POINTR
CLC
ABC ENTLEN
STA POINTR
BCC INSERT
INC POINT**!
INSERT INC TABLEN
LOT 10
LBX ENTLEN
LOOP LBA (OBJECT),
STA (POINTR),
INY
DEX
BNE LOOP
)UTE RTS
)ELETE JSR SEARCH
BEO OUTS
BEC TABLEN
DEX
,Y
tY
,Y
,Y
,Y
,Y
Y
Y
;INITIALIZE POUTER
.'STORE TAKER AS A VARIABLE
;CNECK FOR 0 TABLE
{COMPARE FIRST LETTERS
;C6HPARE SECSNB LETTERS
;CONPARE TNIRB LETTERS
;SEE NOU RAfY ERNIES ARE LEFT
;A0P ENTLEN TO POINTER
JCLEAR Z FLAS IF FOUND
{SEE IF OBJECT 18 THERE
{CHECK FOR 0 TABLE
{POINTER IS AT LAST ENTRY
;..NU8T NOVE IT TO END OF TABLE
{INCREMENT TABLE LENGTH
;hove object to end of table
;Z SET IF UA8 DONE
JFIHB HHERE BBJECT IS
{EXIT IF NOT FOUN)
{DECREMENT TABLE LENGTH
;8EE HOW MANY ENTRIES ARE
Fig. 9-16: Simple List Programs: Search, Enter, Delete
292
DATA STRUCTURES
0049
0070
0071
0072
0073
0074
O075
0076
0077
0078
007?
0080
008)
0082
0063
0084
0085
0086
0087
O088
008?
00?0
Of?1
00?2
O0?3
O0?4
0661
0663
0665
0666
0668
066A
066C
066E
0670
0672
0673
0675
0677
067?
067B
067C
067E
0680
0682
0684
0686
068?
0681
068C
068C
068C
F0
AS
18
65
65
A?
65
85
A4
88
B1
91
CO
DO
CA
FO
AS
85
AS
85
4C
A9
60
26
12
17
18
00
13
19
17
18
12
00
F7
OB
18
12
19
13
63 06
FF
ADDEN
LOOPE
DONE
OUTS
;
i
BEO BONE
LBA POINTR
CLC
ABC ENTLEN
STA TENPTR
LBA 10
ABC POINTR+1
STA TENPTR*1
LBY ENTLEN
BEY
LBA <TENPTR),Y
STA (POINTR)rY
CPY 10
BNE LOOPE
BEX
BEG BONE
LBA TENPTR
STA POINTR
LBA TEHPTR*1
STA P0INTR41
JHP A0OEH
LDA IIFF
RTS
.END
;..AFTER ONE TO BE DELETED
;ab» entlcn to pointer and
J..SAVE AT TENP STORAGE
{ADO CARRY TO HIGH BYTE
;SHIFT ONE ENTRY OF HEHOftY DOWN
DECREMENT ENTRY COUNTER
;NOVE TENP TO POINTER
;CLEAR Z FLA6 IF IT VAS BONE
ERRORS * 0000 <0000>
SYNB8L TABLE
SYNBOL VALUE
AI9EN 0663 DELETE 065? BONE 068? fNTLEN 0117
ENTRY 060C FOUNB 0633 INSERT 064A LOOP 0650
LBOPE 0672 NEU 0636 N0800D 0622 OBJECT 0019
<WT 0635 OUTE 0658 OUTS 068B POINTR 0112
SEARCH 0600 TABASE 0010 TABLEN 0014 TENPTR O»1I
ENB OF A88EHBLY
Fig. 9-16: Simple List Programs: Search, Enter, Delete (cont.)
293
PROGRAMMING THE 6502
FLAGS = 0
POINT TO TABLE BASE
LOGICAL POSITION = INCREMENT VALUE
= TABLE LENGTH/2
POINT TO MIDDLE OF TABLE
INCREMENT COUNTER = INCREMENT COUNTER/2
PRESERVE CARRY (SIGN OF COMPARISON)
INTO COMPRES FLAG
- (ENTRY)
YES
(LAST ONE)
Fig. 9-17: Binary Search Flowchart
294
DATA STRUCTURES
(NEXT) (IASTONE)
NOT
FOUND
Fig. 9-17: Binary Search Flowchart (cont.)
295
PROGRAMMING THE 6502
The search is somewhat complicated by the need to keep track of
several conditions. The major problem to be avoided is searching for an
object that is not there. In such a case, the entries with the immediately
higher and lower alphabetic values could be alternately tested forever.
To avoid this, a flag is maintained in the program to preserve the value
of the carry flag after an unsuccessful comparison. When the INCMNT
value, which shows by how much the pointer will next be incremented,
reaches a value of "1", another flag called "CLOSE" is set to the value
of the CMPRS flag. Thus, since all further increments will be "1," if
the pointer goes past the point where the object should be, CMPRES
will not longer equal CLOSE, and the search will terminate. This fea
ture also enables the NEW routine to determine where the logical and
physical pointers are located, relative to where the object will go.
Thus, if the OBJECT searched for is not in the table, and the
running pointer is incremented by one, the CLOSE flag will be set.
On the next pass of the routine, the result of the comparison will be
opposite to the previous one. The two flags will no longer match,
and the program will exit indicating "not found."
OBJECT
"SYB"
TABASE
BAC
TES
(NO)
TES
XYZ
(NO)
FIRST TRY
SEARCH INTERVAL = 5
SECOND TRY
SEARCH INTERVAL = 2
Fig. 9-18: A Binary Search
296
DATA STRUCTURES
The other major problem that must be dealt with is the possibili
ty of running off one end of the table when adding or subtracting
the increment value. This is solved by performing an "add" or
"subtract" test using the logical pointer and length value to determine
the actual number of entries, rather than using physical pointers to
determine their mere physical positions.
In summary, two flags are used by the program to memorize in
formation: CMPRES and CLOSE. The CMPRES flag is used to
preserve the fact that the carry was either "0" or "1" after the
most recent comparison. This determines if the element under test
was larger or smaller than the one to which it was compared. Whenever
the carry C is "1," the entry is smaller than the object, and CMPRES
is set to "1." Whenever the carry C is "0," the entry is greater than the
object, and CMPRES will be set to "FF."
Also note that when the carry is "1", the running pointer will point
to the entry below the OBJECT.
The second flag used by the program is CLOSE. This flag is set
equal to CMPRES when the search increment INCMNT
becomes equal to "1." It will detect the fact that the element has
not been found if CMPRES is not equal to CLOSE the next time
around.
Other variables used by the program are:
LOGPOS,which indicates the logical position in the table (ele
ment number).
INCMNT, which represents the value by which the running
pointer will be incremented or decremented if the next comparison
fails.
TABLEN represents, as usual, the total length of the list.
LOGPOS and INCMNT will be compared to TABLEN in order to
ascertain that the limits of the list are not exceeded.
The program called "SEARCH" is shown in Fig. 9-22. It resides
at memory locations, 0600 to 06E3, and deserves to be studied
with care, as it is much more complex than in the case of a linear
search.
An additional complication is due to the fact that the search
interval may at times be either even or odd. When it is even, a cor
rection must be introduced. It cannot, for instance, point to the middle
element of a 4-element list.
When it is odd, a "trick" is used to point to the middle element:
the division by 2 is accomplished by a right shift. The bit "falling
out'1 into the carry after the LSR instruction will be "1" if the in-
297
PROGRAMMING THE 6502
terval was odd. It is merely added back to the pointer:
(0615) DIV LSR A DIVIDE BY TWO
ADC #0 PICK UP CARRY
STA LOGPOS NEW POINTER
The OBJECT is then matched against the entry in the middle of
the new search interval. If the comparison succeeds, the program
exits. Otherwise ("NOGOOD"), the carry is set to 0 if the OB
JECT is less than the entry. Whenever the INCMNT becomes "1",
the CLOSE flag (which had been initialized to "0") is then checked
to see if it was set. If it was not, it gets set. If it was set, a check is
run to determine whether we passed the location where the OB
JECT should have been but was not found.
Element Insertion
In order to insert a new element, a binary search is conducted. If
the element is found in the table, it does not need to be inserted.
(We assume here that all elements are distinct). If the element was
not found in the table, it must be inserted. The value of the CMPRES
flag after the search indicates whether this element should be inserted
immediately before or immediately after the last element to which it
was compared. All the elements following the new location where it is
going to be placed are then moved down by one block position, and the
new element is inserted.
The insertion process is illustrated in Figure 9-19 and the corres
ponding program appears on Figure 9-22.
The program is called "NEW", and resides at memory locations
06E3 to 075E.
Note that indirect indexed addressing is used again for block
transfers:
(072A)
ANOTHR
LDY
DEY
LDA
STA
CPY
BNE
ENTLEN
(POINTR), Y
(TEMP), Y
#0
ANOTHR
Observe the same at memory location 0750.
298
DATA STRUCTURES
BEFORE AFTER
TABASE- AAA
ABC
BAT
TAR
ZAP
OBJECT- BAC
AAA
ABC
BAC
BAT
TAR
ZAP
—NEW
ELEMENT
MOVE DOWN
Fig. 9-19: Insert: "BAC"
Element Deletion
Similarly, in order to delete an element, a binary search is conducted
to find the object. If the search fails, it does not need to be deleted. If
the search succeeds, the element is deleted, and all the following ele
ments are moved up by one block position. A corresponding example is
shown in Fig. 9-20, and the program appears in Figure 9-22. The flow
chart is shown in Fig. 9-21.
It is called "DELETE," and resides at memory addresses
075F to 0799.
LINKED LIST
The linked list is assumed to contain, as usual, the three alpha
numeric characters for the label, followed by 1 to 250 bytes of data,
followed by a 2-byte pointer which contains the starting address of
the next entry, and lastly followed by a 1-byte marker. Whenever this
1-byte marker is set to "1," it will prevent the insert-routine from
substituting a new entry in the place of the existing one.
299
PROGRAMMING THE 6502
Further, a directory contains a pointer to the first entry for each
letter of the alphabet, in order to facilitate retrieval. It is assumed
in the program that the labels are ASCII alphabetic characters.
All pointers at the end of the list are set to a NIL value which has
been chosen here to be equal to the table base, as this value should
never occur within the linked list.
The insertion and the deletion program perform the obvious pointer
manipulations. They use the flag INDEXD to indicate if a pointer
pointing to an object came from a previous entry in the list or
from the directory table. The corresponding programs are shown in
Fig. 9-27. the data structure is shown in Fig. 9-23.
An application for this data structure would be a computerized
address book, where each person is represented by a unique
3-letter code (perhaps the usual initials) and the data field contains
a simplified address, plus the telephone number (up tq/250
characters).
BEFORE AFTER
MOVE UP
AAA
ABC
BAC
BAT
TAR
ZAP
AAA
ABC
BAT
TAR
ZAP
DELETE
Fig. 9-2O: Delete: "BAC"
300
DATA STRUCTURES
DELETE
COUNT HOW MANY
ELEMENTS FOLLOW THE
ONE TO BE DELETED
RESULT « COUNTER
LOGPOS
POINT TO NEXT ENTRY
POINTER = TEMP (SOURCE)
TRANSFER IT UP ONE BLOCK
NO
-► OUTS
YES
POINT TO NEXT ENTRY
POINTER = POINTER (DESTINATION)
DECREMENT LOGPOS
(DECER)
SET 2 FLAGS
RTS
Fig. 9-21: Deletion Flowchart (Alphabetic List)
301
PROGRAMMING THE 6502
LINE • IOC CODE
O002 0000
0003 0000
0004 0000
0003 0000
0006 0000
O007 0000
O008 0000
0009 0000
0010 0000
00It 0000
0012 0000
O013 0000
0014 0600
OOtS 0600 A9 00
0016 0602 85 10
0017 0604 85 11
0016 0606 AS 12
0019 0608 85 14
0020 060A AS 13
0021 060C 85 15
O022 060E AS 16
0023 0610 DO 03
0024 0612 4C CO 06
O025 0615 4A
O026 0616 69 00
0027 0618 85 \7
0028 061A 85 18
0029 06IC A6 17
0030 06 IE CA
0031 06IF FO OE
0032 0621 AS 18
0033 0623 18
0034 0624 65 14
O035 0626 85 14
0036 0626 90 02
O037 062A £6 15
0038 062C CA
0039 0620 00 F2
O040 062F A5 18
0041 0631 4A
O042 0632 69 00
0043 0634 85 18
0044 0636 AO 00
O045 0638 11 1C
O046 063A 01 14
0047 063C DO 11
0048 063E C8
O049 063F Bl 1C
0050 0641 D1 H
0051 0643 00 OA
0052 0645 C8
0053 0646 Bl 1C
O054 0648 01 14
0055 064A 00 03
0056 064C 4C E? 06
O057 064F AO FF
0058 0651 90 02
O059 0653 AO 01
0060 0655 84 11
O06I 0657 A4 18
O062 0659 88
0063 065A 00 10
0064 065C A5 10
0065 065E FO 08
0066 0660 38
0067 0661 E5 11
0068 0663 FO 07
LINE
CLOSE = 110
CHPRES * \$11
TAIASE « \%\2
POINTR « fM
TAKEN • t16
L06P0S * \%\7
INCRNT * *16
TEMP * t19
ENTLEN * I!B
OBJECT * SIC
• b \$600
SEARCH LOA NO
STA CLOSE
STA CNPRES
L>A TABASC
STA POINTR
LOA TA8ASE+1
STA POINTR*!
LOA TA6LEN
BNE OIV
JNP OUT
OIV LSR A
AOC 10
STA L06P0S
STA INCMNT
LOX L06P0S
OEX
BEQ ENTRY
LOOP LOA ENTLEN
CLC
ADC POINTR
STA POINTR
BCC LOPP
INC POINTRM
LOPP OEX
BNE LOOP
ENTRY LOA INCHNT
LSR A
AOC SO
STA INCNNT
LOT 10
LOA (OBJECT),r
CMP (POINTR),Y
BNE N06000
INY
LOA (OBJECT),Y
CNP (POINTR),Y
BNE N06000
INY
IDA (OBJECT),Y
CMP (POINTR),Y
BNE N0600D
JNP FOUND
N0600D LOY VfFF
BCC TESTS
LOY III
TESTS STY CNPRES
LOY INCNNT
OEY
BNE NEXT
LOA CLOSE
BEQ NAKCLO
SEC
SBC CNPRES
BEQ NEXT
,'ZERO FLAGS
;INITIALIZ6 POINTER
;get table length
.'DIVIDE IT BY 2
;ado back in i-s bit
JSTORE AS LOGICAL POSITION
,• STORE AS INCREMENT VALUE
MULTIPLY ENTLEN BY LOSPOS
,*..ADDING RESULT TO POINTER
,-DIVIDE INCREMENT VALUE BY 2
,'COHPARE FIRST LETTERS
,-CONPARE 2ND LETTERS
.'COMPARE 3RD LETTERS
,*SET COMPARE RESULT FLAG
;IF 08J < POINTR : C-0
;IS 1NCR. VALUE A I?
,'CMECK CLOSE fLUG IF IT UAS
,'IF CLOSE FLAG NOT SET, GO DO IT
;SEE IF GAVE PASSED UHFRK OBJ.
,-..SHOULD BE BUT ISNT
Fig. 9-22: Alphabetic List Programs: Binary Search, Delete, Insert
302
DATA STRUCTURES
0069
0070
0071
0072
0073
O074
O07S
0074
0077
0078
0079
0080
O081
O082
O083
O084
0083
O086
0087
O088
0089
0090
O091
0092
0093
O094
O09S
0096
O097
0098
0099
0100
0101
0102
0103
0104
0105
0106
0107
0108
0109
0110
0111
0112
0(13
0114
0113
0116
0117
0118
0119
0120
0121
0(22
0123
0124
0123
0126
0127
0128
0129
0130
0131
0132
0133
0134
0135
0136
0137
0138
0665
0668
066A
066C
066t
0670
0672
0673
0673
0677
0679
0671
067D
067F
0680
0682
0684
0686
0688
0689
0681
0686
068E
0690
0692
0693
0697
0699
069A
069C
069E
06AO
06A2
06A5
06A7
06A6
06AA
06AC
06AE
0610
0662
0614
0615
0617
0669
0666
0666
066E
06C0
06C3
06C5
06C6
06C8
06CA
06CC
06C6
06CF
0661
0663
0665
0667
0669
0666
0666
06E0
06E2
06E3
06E3
06E3
06E3
4C EO 06
AS 11
85 10
24 11
30 35
A5 16
38
E5 17
FO 69
E5 18
90 1A
A6 18
A5 II
18
65 14
85 14
90 02
E6 IS
CA
60 F2
AS 17
18
65 18
85 17
4C 2F 06
E6 \7
AS II
18
65 14
85 14
90 35
E6 15
4C 65 06
AS 17
38
E5 18
FO 17
90 15
85 17
A6 18
AS 14
38
ES II
85 14
80 02
C6 IS
CA
60 F2
4C 2F 06
A6 17
CA
FO (8
C6 17
A3 14
38
E5 18
85 14
60 02
C6 15
A9 01
85 IB
AS 11
85 10
4C 2F 06
A2 FF
60
NEXT
JHP OUT
HAKCLO IDA CNPRES
STA CLOSE
BIT CNPRES
INI SUIIT
L6A TA8LEN
SEC
S6C LOGPOS
IEQ OUT
86C INCNNT
6CC TOOHI
L6X INCNNT
L6A ENTLEN
CLC
ADC POINTR
STA POINTR
6CC A61
INC POINTR+t
6EX
6NE ADDER
L6A L08P08
CLC
A6C INCHNT
STA L08P08
JHP ENTRY
INC L08P08
L6A ENTLEN
CLC
A6C POINTR
STA POINTR
8CC SETCLO
INC POINTRH
JNP SETCLO
L6A LOGPOS
SEC
S6C INCNNT
IE8 TOOLOU
8CC TOOLOU
STA L08P08
L6X INCHNT
SU6L0P L6A POINTR
SEC
S6C ENTLEN
STA POINTR
8CS 8U60
6EC POINTR+t
6EX
8NE SU6L0P
JHP ENTRY
TOOLOU L6X L08P08
6EX
6E8 OUT
6EC L08P0S
L6A POINTR
SEC
S8C ENTLEN
STA POINTR
6C8 SETCLO
6EC POINTRH
SETCLO L6A II
STA INCHNT
L6A CNPRES
STA CLOSE
JHP ENTRY
OUT L6X IIFF
F0UN6 RTS
A66ER
A61
TOOHI
SU6IT
SU60
;8ET CLOSE FLAB TO CNPRES
;SEE IF A6DITI10I OF INCNNT
;..UILL RUN PAST END OF TABLE
JCHECK TO SEE IF IT END OF TABLE ILREIDY
JIS ALL RIGHT, INC POINTEI IY
{..PROPER AHOUNT
;INCREMENT LOGICAL POSITION
;INCR. LOGICAL POSITION
;HOVE POINTER UP ONE ENTRY
;SEE IF INC WILL GO OFF BOTTON
;.. OF TABLE
;SAVE NEU L08ICAL POSITION
{SUBTRACT PROPER ANT. FRON POINTER
;SEE IF POS IS ALREADY 1
}SUB 1 ENTRY FROM POINTER
20 00 06 NEU JSR SEARCH
,*Z BET IF FOUND
;SEE IF OBJECT IS ALREADY THERE
Fig. 9-22: Alphabetic List Programs: Binary Search, Delete, Insert (cont.)
303
PROGRAMMING THE 6502
0139 06E6 FO 76
0140 06E8 AS 16
0141 06EA FO 62
0142 06EC 24 11
0143 06EE 10 05
0144 06F0 C6 17
0145 06F2 4C 00 0?
0146 06F5 A5 IB
0147 06F7 18
0148 06F8 65 14
0149 06FA 85 14
0150 06FC 90 02
0151 06FE E6 15
0152 0700 A5 16
0153 0702 38
0154 0703 E5 \7
0155 0705 FO 47
0156 0707 AA
0157 0708 A8
0158 0709 88
0159 070A FO OE
0160 070C AS IS
0161 070E 18
0162 070F 65 14
0163 0711 85 14
0164 0713 90 02
0165 0715 E6 15
0166 0717 88
0167 0718 DO F2
0168 071A A5 14
0169 071C 18
0170 07ID 65 IB
0171 071F 83 19
0172 0721 90 01
0173 0723 C8
0174 0724 98
0175 0725 18
0176 0726 65 15
0177 0728 85 1A
0178 072A A4 IB
0179 072C 88
0180 072D Bl 14
0181 072F 91 J9
0182 0731 CO 00
0183 0733 DO F7
0184 0735 A5 14
0185 0737 38
0186 0738 E5 IB
0187 073A 85 14
0188 073C BO 02
0189 073E C6 15
0190 0740 CA
019J 0741 DO D7
0192 0743 A5 IB
0193 0745 18
0194 0746 65 14
0195 0748 85 14
0196 074A 90 02
0197 074C E6 15
0198 074E AO 00
0199 0750 A6 IB
0200 0752 Bf IC
0201 0754 91 14
0202 0756 C8
0203 0757 CA
0204 0758 DO F8
0205 075A E6 16
0206 075C A2 FF
BEO OUTE
IDA TABLEN
BEO INSERT
BIT CHPRES
BPL LOSIDE
DEC LOGPOS
JHP SETUP
LOSIDE IDA ENTLEN
CLC
ADC POINTR
STA POINTR
BCC SETUP
INC POINTR*!
SETUP LDA TABLEN
SEC
SBC LOGPOS
BEO INSERT
TAX
TAY
DEY
BEO SETEHP
LDA ENTLEN
CLC
ADC POINTR
STA POINTR
BCC SETO
INC POINTR+I
DEY
ME UfLOOP
LDA POINTR
CLC
ADC ENTLEN
STA TEMP
BCC SET1
INY
TVA
CLC
ADC POINTR*I
STA TEHP+I
LDY ENTLEN
DEY
LDA (POINTR),r
STA <TEHP),Y
CPY 10
BNE ANOTHR
LDA POINTR
SEC
SBC ENTLEN
STA POINTR
BCS Ml
DEC POINTR+1
DEX
BNE SETEMP
LBA ENTLEN
CLC
ADC POINTR
STA POINTR
BCC INSERT
INC POINTR+1
LDY 10
LDX ENTLEN
LDA (OBJECT),r
STA (POINTR)tY
INY
DEX
BNE INNER
INC TABLEN
LDX ItFF
UPLOOP
SETO
SETENP
SETI
HOVER
ANOTHR
INSERT
iH HER
.'CHECK FOR 0 TABLE
;TEST LAST COHPARE RESULT
.'SET LOGICAL POSITION SO
,'..SUB WORKS LATER
,'SET POINTER ABOVE WHERE
;..OBJECT UILL 60
.'SEE HOU rtANY ENTRIES THERE
;..ARE AFTER UHERE OBJ. UILL GO
;see if already pointing fo
.'..last entry
;nove pointer to last entry
JADD ENTLEN TO POINTER
;..STORE AT TEMP
IT HAS ALBE«£ir 0
.'SET i FOR SHIFT
,'HOVE A BYTE
;decr. pointer and temp
;..by entlen
JHOVE POINTER BACK TO
,'UHERE OBJ. UILL 60
;nove object into table
[INCREMENT TAILE LENGTH
Fig. 9-22: Alphabetic Ust Programs: Binary Search, Delete, Insert (cont.)
304
DATA STRUCTURES
0207
0208
0209
0210
0211
VZ12
0213
0214
0213
0216
0217
0218
0219
0220
0221
0222
0223
0224
0225
O22«
0227
0228
0229
0230
0231
0232
0233
0234
0239
0236
0237
0238
0239
0240
0241
0242
0243
07SE
075F
075F
075F
07SF
0762
0764
0766
0767
0769
076B
076D
076F
0770
0772
0774
0776
0778
077A
077C
077E
0780
0782
0783
0764
0786
0788
0789
078t
0789
078F
0791
0793
079S
0797
0799
079A
60
20
00
AS
38
ES
F0
85
AS
18
65
65
A?
65
85
A6
AO
•1
91
C8
CA
DO
AS
16
65
85
90
E6
C6
DO
C6
A9
60
00 06
to
16
17
2A
(7
1D
14
19
00
15
(A
11
00
19
14
F8
II
14
14
02
15
17
08
16
00
OUTE
;
;
;
DELETE
DI6L0P
IVTE
D2
DECER
OUTS
RTS
J8R SEARCH
INE OUTS
LDA TADLEN
SEC
SIC L06P0S
IEO IECER
STA L06P0S
LDA ENTLEN
CLC
ADC POINTR
STA TEHP
LDA 10
AIC P0INTR*1
STA TEHP*!
LDX ENTLEN
LIT 10
LIA <TEHP),Y
8TA (POINTR),V
1NY
IEX
•NE IYTE
LDA ENTLEN
CLC
AIC POINTR
STA POINTR
ICC 12
INC PIINTR*1
6EC L08P0S
INE II6L0P
DEC TABLE!
LDA 10
RTS
.END
;Z SET IF NOT DINC
;6ET ADD! OF OBJECT IN TAILS
;SEE IF IT IS THERE
;SEE HOU NANY ENTRIES ARE
;..LEFT AFTER 01J. IN TAKE
}STORE RESULT A8 A COUNTER
;8ET TEHP a ENTRY AIOVE 1 El
;8ET COUNTERS
;hove a iyte
,'IS BLOCK NIVEI YETT
;Z SET IF HAS IONE
ERRORS • 0000 <0000>
8YHB0L
STNIOL
All
BYTE
DECER
ENTRY
INSERT
L08IIE
OUT
SEARCH
SETEHP
SUILOP
TESTS
END OF
TABLE
VALBE
0688
077E
0795
062F
074E
06F5
06E3
06E0
0600
071A
06B2
0655
ASSENDLY
ADDER
CLOSE
DELETE
FOUND
L06P0S
HI
NEXT
OUTE
SETO
SETUP
TABASE
TOOHI
0671
0010
075F
06E2
0017
0740
066C
075E
0717
0700
0012
0695
AN9THR
CHPRES
DIV
INCHNT
LOOP
NAKCLO
N0800D
OUTS
SET1
SUIO
TAILEN
TOOLOU
072C
0011
0615
0018
0621
0668
064F
0799
0724
06ID
0016
06C3
BIGLOP
02
ENTLEN
INNER
LOPP
HOVER
OBJECT
POINTR
SETCLO
SUBIT
TEHP
UPLOOP
076D
0791
O01I
0752
062C
072A
OOU
0014
0615
06AS
O01f
O70C
Fig. 9-22: Alphabetic List Programs: Binary Search, Delete, Insert (cont.)
305
PROGRAMMING THE 6502
Let us examine the structure in more detail in Fig. 9-23.
The entry format is:
c c c D D D P P 0
unique label data (1 to 250 bytes) pointer to
(ASCII) next
occupied
As usual the conventions are:
ENTLEN: total element length (in bytes)
TABASE: address of base of list
TABLEN: number of entries (1 to 256)
Here, REFBASE points to the base address of the directory, or
* 'reference table."
Each two-byte address within this directory points to the first
occurrence of the letter to which it corresponds in the list. Thus
each group of entries with an identical first letter in their labels ac
tually form a separate list within the whole structure. This feature
facilitates searching and is analogous to an address book. Note
that no data are moved during an insert or a delete. Only pointers
are changed, as in every well-behaved linked list structure.
DIRECTORY
A"
P"
POINTER
POINTER
i A
POINTER
R
NIL
NIL
Fig. 9-23: Linked List Structure
306
DATA STRUCTURES
If no entry starting with a specific letter is found, or if there is no
entry alphabetically following an existing one, their pointers will
point to the beginning of the table (= "NIL"). At the bottom of the
table, by convention, a value is stored such that the absolute value
of the difference between it and "Z" is greater than the difference
between "A" and "Z." This represents an End Of Table (EOT)
marker. The EOT value is assumed here to occupy the same
amount of memory as a normal entry but could be just one byte if
desired.
The letters are assumed here to be alphabetic letters in ASCII
code. Changing this would require changing the constant at the
PRETAB routine.
The End Of Table marker is set to the value of the beginning of
the table ("NIL").
By convention, the "NIL pointers," found either at the end of a
string or within a directory location which does not point to a string,
are set to the value of the table base to provide a unique identifica
tion. Another convention could be used. In particular, a different
marker for EOT would result in some space savings, as no NIL
entries need be kept for nonexisting entries.
Insertion and deletion are performed in the usual way (see Part I
of this chapter) by merely modifying the required pointers. The
INDEXD flag is used to indicate if the pointer to the object is in
the reference table or another string element.
Searching
The SEARCH program resides at memory locations 0600 to
0650. In addition, it uses subroutine PRETAB at address 06F8.
The search principle is straightforward:
1_ Get the directory entry corresponding to the letter of the
alphabet in the first position of the OBJECT'S label.
2— Get the pointer out of the directory. Access the element. If NIL,
the entry does not exist.
3— If not NIL, match the element against the OBJECT. If a
match is found, the search has succeeded. If not, get the pointer to
the next entry down the list.
4— Go back to 2.
An example is shown in Fig. 9-24.
307
PROGRAMMING THE 6502
A-POINTER
BPOINTER
(?)
AAA _r AAZ
(4 STEPS REQUIRED)
©
_r ABC
NIL
(FOUND)
Fig. 9-24: Linked List: A Search
Element Insertion
The insertion is essentially a search followed by an insertion
once a "NIL" has been found. A block of storage for the new entry
is allocated past the EOT marker by looking for an occupancy
marker set at "available". The program is called "NEW" and
resides at addresses 0651 to 06BD. An example is shown in Fig.
9-25.
Ji CAB _r CZZ
Nil
CBS
Nit
A-POINTER Lfi
L
Fig. 9-25: Linked List: Example of Insertion
308
DATA STRUCTURES
Element Deletion
The element is deleted by setting its occupancy marker to "available"
and adjusting the pointer text from either the directory or the
previous element. The program is called "DELETE" and resides
at addresses 06BE to 06F7. An example of a deletion is shown in Fig.
9-26.
Lr
-
DOC POINTER
r ■
1
(AFTER)
DAF
"DOCNIL
NOTE DAF IS NOT ERASED. BUT "INVISIBLE"
Fig. 9-26: Example of Deletion (Linked List)
309
PROGRAMMING THE 6502
LINE • LOC COIE
0#02
0103
0104
O005
0004
0007
0008
0009
OOfO
0011
0012
0013
0014
O01S
0016
0017
0018
0019
O020
0021
O022
O023
O024
O025
0026
0027
0028
O029
O030
0031
0032
0033
0034
0035
0036
0037
0038
0039
0040
0041
0042
0043
O044
0045
0046
O047
0048
0049
O050
0051
0052
0053
O054
0055
0056
0057
0058
0059
0060
0061
0062
0063
0064
O065
O066
0067
O068
O069
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0600
0400
0602
0604
0607
0609
060B
060C
060E
0610
0612
0614
0616
0618
061A
061C
061E
0620
0621
0623
0625
0627
0629
062A
062C
062E
0630
0632
0634
0636
0638
063A
063C
063E
063F
0640
0642
0644
0645
A447
0649
064B
064E
0650
0651
0651
0651
0651
0654
0656
0658
0659
065B
0650
065F
0661
0663
A9 01
85 10
20 F8 06
• 1 11
85 13
C8
II 11
85 14
AO 00
II 13
C9 7C
FO 36
II 15
PI 13
90 30
BO 12
C8
61 15
01 13
90 27
00 09
C8
II 15
01 13
90 IE
FO IE
A5 14
85 1C
A5 13
85 IB
A4 IF
B1 13
AA
C8
B1 13
85 14
8A
85 13
A9 00
85 10
4C 10 06
A9 FF
60
20 00 06
FO 67
A5 ID
18
69 01
85 17
A9 00
65 IE
85 18
A4 IF
HIE
INDCXI
INILOC
POINTR
OIJECT
TEW
REFIAS
Oil
TAfASE
ENTLEN
110
• 11
• 13
• 15
• 17
• 19
• II
• II
• IF
* no©
SEARCH ID*
STA
JSR
LOA
STA
INY
LIA
STA
ENTRY LIT
LIA
CMP
BED
LDA
CUP
BCC
INE
INY
LBA
CUP
BCC
BNE
INY
LBA
CHP
BCC
BEG
N0600D LOA
STA
LOA
STA
LOT
LOA
TAX
INY
LOA
STA
TXA
STA
LOA
STA
JHP
NOTFNO LDA
FOUND RTS
II
INiEXI
PRETAB
(INDLOO.Y
POINTR
(INDLOC)fY
POINTR*1
10
(POINTR)VY
•I7C
NOTFNI
(OBJECT),Y
(POINTR),Y
NOTFND
N0600D
(OIJECT),Y
(POINTR)tY
NOTFND
N0600D
(OBJECT),Y
(POINTR),Y
NOTFND
FOUND
POINTft+l
OLD+1
POINTR
OLD
ENTLEN
(POINTR),Y
(POINTR),Y
P0INTR*1
POINTR
•0
INOEXD
ENTRY
••FF
.'INITIALIZE FU6S
;6ET REF. POINTER FOR START
,'PUT IT IN POINTR
,'SEE IF ENTRY IS EOT VALUE
;COMPARE FUST LETTERS
,'COMPARE SECOND LETTERS
;CO*PARE THIRI LETTERS
;save poiiti rot possible ref.
f'OET POINTER FROM ENTRY ANB
;..LOAO IT INTO POINTR
NEU JSR SEARCH
BEO OUTE
IDA TABASE
CLC
ADC II
STA TEMP
LDA 10
ADC TABASE*I
STA TEHP+1
LOT ENTLEN
,* RESET FLA6
;Z SET IF FOUND
JSEE IF OIJ. IS ALREADY THERE
JLOOK FOR UNOCCUPIED ENTRY
,'.. BLOCK
JJUMP PAST EOT VALUE
;SET Y TO POINT TO OCCUPAICY
Fig. 9-27: Linked List Program
310
DATA STRUCTURES
O070
0071
0072
0073
0074
0075
0076
O077
0078
0079
0080
0081
0082
0083
0084
O08S
O086
0087
O088
0089
0090
0091
0092
0093
0094
O095
0096
0097
O098
0099
0100
0101
0102
0103
0104
0105
0106
0107
0108
0109
0110
0111
0112
0113
0114
0115
0116
0117
0118
0119
0120
0121
0122
0123
0124
0129
0126
0127
0128
0129
0130
0131
0132
0133
0134
0139
0134
0137
0131
0665
0666
0667
0669
066B
066D
066F
0670
0672
0674
0676
0678
067A
067C
0*7E
0680
0683
0684
0685
0686
0688
068A
068C
066E
0690
0692
0694
0695
0697
0499
069A
069C
069E
06A0
06A2
06A3
06A5
06A7
06A8
06AA
06AC
06AF
06B2
06B4
06B6
06B7
06B9
06BB
06B0
060E
060E
060E
040E
04C1
04C3
04C5
04C7
04C9
04CA
04CC
04CE
04CF
0401
0403
0409
•407
04BA
04BB
040F
C8
C8
A9
01
DO
AS
18
65
90
E6
69
85
A9
65
85
4C
88
88
88
B1
91
CO
00
A4
AS
91
C8
AS
91
C8
A9
91
AS
DO
88
AS
91
88
AS
91
4C
20
AS
91
C8
AS
91
A9
60
20
00
A4
01
09
CO
01
•9
C8
01
17
16
17
IF
02
18
03
17
00
18
IB
67
15
17
00
f7
IF
13
17
14
17
01
17
10
00
18
10
17
10
OB
FB
17
11
18
11
FF
00
34
IF
13
17
13
18
A9 00
91
A9
FO
20
4C
AS
11
13
10
04
F8
EA
10
06
06
06
06
04
•4
LOOP
NORE
INSERT
LOPE
8ETINX
BONE
OUTE
i
;
OaETE
PREINX
INY
INY
LDA
CUP
BNE
LDA
CLC
ADC
BCC
INC
ADC
STA
LIA
ABC
STA
JAP
DEY
DEY
DEY
LDA
STA
CPY
BNE
LDY
LDA
STA
INY
LDA
STA
INY
LDA
STA
LDA
BNE
DEY
LDA
STA
BEY
LDA
STA
JHP
JSR
LOA
STA
INY
LDA
STA
LOA
RT8
JSR
ONE
LOT
LOA
STA
INY
LOA
STA
INY
LOA
STA
LOA
0E8
JSR
JNP
LDA
CLC
11
(TENP)fY
INSERT
TENP
ENTLEN
NORE
TEHPH
13
TEHP
NO
TEMP+t
TENP+1
LOOP
(OBJECT),Y
(TEHP),Y
•0
LOPE
ENTLEN
POINTR
(TEHP),Y
POINTRH
<TEHP),Y
11
(TEHP),Y
INDEXD
SETINX
TEHPM
(OLD),Y
TEHP
<OLD),Y
DONE
PRETAB
TEHP
(INDLOC),Y
TEHP+1
(INOLOC),Y
IIFF
SEARCH
OUTS
ENTLEH
(POINTR)fY
TEHP
(POINTR),f
TEHP+1
10
(POINTR),Y
INDEXO
PREINX
PRETAO
HOVEIT
OLD
{..HARKER OF AN EHTKT
;test for occupancy barker
JIF IS USED, ROVE TEHP TO NEXT
,*..ENTRY BLOCK
JSET Y BACK TO P0INTIN8 TO
{..TOP OF DATA
{HOVE OBJECT INTO SPACE
;PUT THE VALUE OF POINTR, THE
{ENTRY AFTER OOJECT, INTO
{POINTER AREA OF OOJECT
{SET OCCUPANCY MARKER
{TEST TO SEE IF REF. TABLE
{..NEEDS READJUSTING
{NO, CHAN6E PREVIOUS ENTRY'S
{..POINTER
{GET ADDRESS IF UNATS TO IE Cl
{LOAD ADDR. OF OOJ. THERE
;l CLEAR IF DONE
{GET ADDR OF OOJ.
{STORE POINTEI AT END
{..OF OOJECT
{CLEAR OCCUPAICY MARKER
{SEE IF REF. TABLE NEEDS
{..READJUSTINS
{SET FOR CHAMIIIG PREVIOUS
{..ENTRY
Fig. 9-27: Linked list Program (cont.)
311
PROGRAMMING THE 6502
0119
0141
0141
0142
0141
0144
0149
014A
0147
0141
0149
0191
0191
0192
0191
0194
0199
0156
0197
0191
0199
0160
01 At
0162
0163
0164
016S
0166
0167
0AE0
•AE2
0AE4
OAEA
OAEI
IAEA
06EC
•AEE
•AFO
OAFI
•AFI
0AF9
0AF7
tAFt
OAFI
•AFI
•AFI
•AFA
•AFC
•AFI
•AFF
•7M
0701
0703
0705
0707
0709
070B
070C
A9 IF
•9 11
A9 00
A9 1C
19 12
A9 17 1
AO 00
91 It
Cl
A9 11
91 11
Af 00
AO (
AlC ENTLEN
STA INILOC
LIA 10
AlC 0LI*1
STA INILOC*1
IOVEIT LIA TENP ;(HAN8E UIAT lEEDt CHANGI
LIT 10
8TA (INILOC),Y
INY
LIA TEHP*1
STA (INILOC)fY
LM ••
JUTS ITS ,-Z SET IF IOXE
AO 00 PRETAB LIT 10
11 19
II
E9 41
•A
11
A9 19
85 11
A9 00
63 1A
8S 12
60
LIA (OBJECT),?
8EC ,-RENOVE ASCII LEADER FRON
IK IM1 ;..FIRST LETTER IN OBJECT
AIL A MULTIPLY IY 2
CLC
AK REFIA8 ;INDEX INTO REF. TABLE
STA I-DLOC
LDA 10
ADC F'CFBASH
STA INDLOCH
*TS
.EMD
ERRORS = 0000 '0000
SYMBOL TABLE
SYMBOL VALUE
DELETE 06IE DONE
FOUNB 0650 INDEXO
LOOP 0667 LOPE
NEU 0651 N0600D
OLD 0011 OUTE
06IB ENTLEN 001F ENTRY 0*1»
0010 IHOLOC 0011 INSERT 0613
0685 MORE 0676 HOVEIT OAEA
0632 NOTFNO 064E OBJECT 001S
06BD OUTS 06F7 POINTR O01J
PREINX 06BD PRETAB 06F8 REFBAS 0019
SETINX 06AF TABA8E 0010 TEMP 0017
END OF A8SEHBLY
SEARCH 0600
Fig. 9-27: Linked List Program (cont.)
312
DATA STRUCTURES
BINARY TREE
We will now develop typical tree management routines. Our simple
structure is shown in Fig. 9-28. It is a binary tree, and the nodes are
names of persons. Names will be internally sorted by "tags" which will
be the first three letters of every name. The memory representation of
this tree structure is shown in Fig. 9-29. The contents of the nodes are
shown, as well as the two links. The first link, to the left of the name, is
the "left sibling" and thejnext link, to its right, is the "right sibling."
For example, the entry for Jones contains two links: "2" and "4". This
indicates that its left sibling is entry number 2 (Anderson), and its right
sibling is entry number 4 (Smith). A "0" in the link field indicates no
sibling. A left sibling's tag comes alphabetically before its parent. A
right sibling's tag comes after.
ANDERSON SMITH
ALBERT BROWN
« CO
MURRAY
CO
TIMOTHY
/CO
ZORK
(8)
Fig. 9-28: Binary Tree
The two main routines for tree management are the tree builder
and the tree traverser. The element to be inserted will be placed in
a buffer. The tree builder will insert the content of the buffer into
the tree at the appropriate node. The tree traverser is said to
traverse the tree recursively, and prints the contents of each of its
nodes in alphanumeric order. The flowchart for the tree builder is
shown in Fig. 9-30, and the flowchart for the tree traverser is shown in
Fig. 9-31.
313
PROGRAMMING THE 6502
■'
1
2
3
4
5
6
7
8
LEFT
JONES
ANDERSON
BROWN
SMITH
MURRAY
ZORK
ALBERT
TIMOTHY
2
7
0
5
0
8
0
0
RIGHT
4
3
0
6
0
0
0
0
ORDER
OF INSERTION
Fig. 9-29: Representation In Memory
314
DATA STRUCTURES
B
Fig- 9-3O: The Tree Builder Flowchart
315
PROGRAMMING THE 6502
LEFT
POINTER OF
CURRENT
NODE = 0
ADD BUFFER
CONTENTS TO
TOP OF TREE
[POINTED TO
BY FREEPTR]
WORKPTR =
RIGHTPTR OF
CURRENT NODE
LfFT POINTER
OF CURRENT NODE
= FREEPTR
SET POINTERS OF
NEW NODE = 0
FREEPTR = FREEPTR
+ ENTLEN + 4
[ RETURN 1
Fig. 9-30: The Tree Builder Flowchart (cont.)
316
DATA STRUCTURES
| WORKPTR - STARTPTR j
| PRINT TREE (WORKPTR) ]
mOMCPTR «= RIGHTPTR (WORKPTR)]
Fig. 9-31: Tree Traverser Flowchart
317
PROGRAAAAAING THE 6502
Since the routine for the traversal is recursive, it does not lend itself well
to flowchart representation. Another description of the routine in a highlevel
format is therefore shown in Fig. 9-32. An actual node of the tree
is shown in Fig. 9-33. It contains data of length ENTLEN, then two 16-
bit pointers (the right pointer and the left pointer). In order to avoid a
possible confusion, note that the representation of Fig. 9-29 has been
simplified and that the right pointer appears to the left of the left
pointer in the memory. The memory allocation used by this program is
shown in Fig. 9-34, and the actual program appears in Fig. 9-37.
The INSERT routine resides at addresses 0200 to 0282. The tag
of the object to be inserted is compared to that of the entry. If greater,
one moves to the right. If smaller, to the left, down by one position.
The process is then repeated until either an empty link is found or a
suitable "bracket" is found for the new node (i.e., one node is greater
and the next one smaller, or vice versa). The new node is then inserted
by merely setting the appropriate links.
PROGRAM TREETRAVERSER;
BEGIN
CALL SEARCH (STARTPOINTER);
END.
ROUTINE SEARCH (WORKPOINTER);
BEGIN
IF WORKPOINTER = OTHEN RETURN;
SEARCH [LEFTPTR (WORKPOINTER)];
PRINT TREE (WORKPOINTER);
SEARCH [RIGHTPTR (WORKPTR)];
RETURN;
END.
Fig. 9-32: Tree Traversal Algorithm
318
DATA STRUCTURES
DATA: 'ENTLEN' BYTES
RIGHT PTR
1 , H
LEFT
L
PTR
H
(n) (n + ENTLEN + 4)
Fig. 9-33: Data Units, or "Nodes" of Tree
PAGEO
\$10
\$17
\$37
FREPTR (LO)
FREPTR (HI)
WRKPTR (LO)
WRKPTR (HI)
ENTLEN
STRTPT (LO)
STRTPT (HI)
BUFFER
HIGH MEMORY
PROGRAM
TREE
\$200
\$600
TOP OF TREE
Fig. 9-34: Memory Maps
319
PROGRAMMING THE 6502
The TRAVERSE routine resides at addresses 0285 to 02D6. The
utility routines OUT, ADD and CLRPTR reside at addresses 0207
to 02FE (see Fig. 9-37).
An example of a tree insertion is shown in Fig. 9-35, and an ex
ample of a tree traversal in Fig. 9-36.
SEARCH
ALBERT
-
ANDERSON
\
BROWN
TOM
JONES
2 INSERT
Fig. 9-35: Inserting an Element in the Tree
320
DATA STRUCTURES
ALBERT ANDERSON BROWN JONES MURRAY
SMITH ZORK
TIMOTHY
Fig. 9-36: Listing the Tree
Note on Trees
Binary trees may be constructed and traversed in many ways.
For example, another representation for our tree could be:
ALBERT
ANDERSON MURRAY
BROWN
SMITH TIMOTHY
ZORK
Fig. 9-38 : Tree in Preorder
It would then have to be traversed in "preorder":
1— list the root
2— traverse left subtree
3— traverse right subtree
Many other techniques and conventions exist.
321
PROGRAMMING THE 6502
0002
0003
0004
0005
0006
O007
0008
0009
OOtO
0011
0012
0013
OOH
O01S
0016
0017
0018
0019
0020
0021
O022
0023
0024
O025
O026
O027
0028
0029
0030
0031
0032
0033
O034
0035
0036
0037
0038
0039
O040
0041
0042
O043
O044
O045
0046
0047
0048
0049
0050
O051
0052
0053
0054
0055
0056
O057
0058
0059
0060
O061
O062
O063
0064
0065
0066
0067
0068
0069
O070
0071
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
ooto
0012
0012
0014
0015
0017
0026
002B
0200
0200
0200
0200
0200
0200
0202
0204
0206
0208
020A
020C
020E
0210
0212
0214
0217
021A
021B
0210
0220
0222
0224
0224
0226
0228
0228
0229
022B
022D
022F
0231
0233
0234
0236
0238
023A
023C
0230
023F
0241
0244
0247
0248
024A
024C
024D
024E
0250
0252
0254
00 06
A5 15
85 12
A5 16
85 13
A5 10
C5 15
00 OP
AS 11
C5 16
00 07
20 07 02
20 E4 02
60
AO 00
69 17 00
01 12
90 33
FO 02
80 05
C8
C9 04
00 FO
A4 14
81 12
00 15
C8
81 12
00 10
AS 11
91 12
88
AS 10
91 12
20 07 02
20 E4 02
60
A4 14
81 12
AA
C8
61 12
85 13
86 12
4C II 02
;TREE NANA6EHENT PROGRAH.
t*2 ROUTINES! ONE, WHEN CALLED. PLACES
;THE CONTENTS OF. THE 8UFFER INTO THE
,'tree; and the second traverses
;the tree recursively, printing its
;node contents in alphanumeric order.
,'note: 'entlen' must be initialized
;and -freptr' nust be set eoual to
t"strtptr' before either routine is used.
FREPTR *=«*2 {FREE SPACE POINTER: POINTS TO
{NEXT FREE LOCATION IN MEMORY.
WRKPTR ****2 {W0RKIN6 POINTER, POINTS TO CURRENT NODE.
ENTLEN •«•♦! {TREE ENTRY LENGTH, IN BYTES.
STRTPT .WORD 1600
BUFFER «s«*20 {I/O BUFFER.
♦ = \$200
{ROUTINE TO BUILD TREE: ADOS ONE DATA UNIT,
{OR NODE, TO TREE. MUST BE CALLED
{WITH DATA UNIT TO BE ADDED IN 'BUFFER'.
INSERT LOA STRTPT
STA URKPTR
LOA STRTPT*!
STA URKPTR+1
LDA FREPTR
CMP STRTPT
BNE INLOOP
LOA FREPTR*1
CNP STRTPT+1
BNE INLOOP
JSR ADD
JSR CLRPTR
RTS
INLOOP LOY 10
CHPLP LDA BUFFER.Y
CMP (URKPTR),Y
BCC LESSTN ;IUFR TA6 LOWER: ADD BUFFER TO
{LEFT SIDE OF TREE.
NXT {TAGS EQUAL, TRY NEXT CHR. IN TAGS.
GRTNEO {BUFR TAG GREATER, ADD BUFR TO
{RIGHT SIDE OF TREE.
{WORKPOINTER <= FREEPOINTER.
.'IF FREEPOINTER <>
{STARTING LOCATION POINTER,
J60T0 INSERTION LOOP.
JLOAD BUFFER INTO CURRENT POSITION.
{SET POINTERS OF CURRENT NODE TO 0.
{DONE ADDING 1ST NODE.
{COMPARE BUFFER TA6 TO TAG OF CURRENT
{LOCATION...
BCS
NXT INY
CNP
BNE
GRTNEO LDY
LDA
BNE
INY
LDA
BNE
LDA
STA
DEY
LDA
STA
JSR
JSR
RTS
NXRNOD LDY
LDA
TAX
INY
LDA
STA
STX
JNP
M ;3 CHRS. COMPARED*
CNPLP JNO, CHECK NEXT CHR.
ENTLEN {DOES
(URKPTR),Y {RIGHT POINTER OF CURRENT NODf = 0
NXRNOD ;IF NOT, MOVE DOWN/RIGHT IN TREE.
(URKPTR),Y
NXRNOD
FREPTRH {SET RIGHT POINTES OF CURRENT
(URKPTR),Y {NODE = FREEPOINTER.
FREPTR
(URKPTR),Y
ADD ;ADD BUFFER TO TREE.
CLRPTR {CLEAR POINTERS OF NtU NODE.
{PONE, NEU RIGHT NODE ADDED.
ENTLEN {SET WORKING POINTER
<WRKPTRt,Y{ RI6HT POINTER OF CURRENT NODE.
(WRKPTR).Y
URKPTR+!
WRKPTR
INLOOP ;TRY NEU CURRENT NODE.
Fig. 9-37: Tree Search Programs
322
DATA STRUCTURES
0072
0*73
0*74
Of75
0076
0077
0071
0079
0082
0083
0084
O085
0186
0087
0088
0089
0090
0091
O092
0093
0094
O095
0096
0097
O098
0099
0100
0101
oto:
O103
0104
0105
0106
0107
0108
0109
0110
0111
0112
0113
0114
0115
0116
0117
0118
0119
0120
0121
0122
0123
0124
0125
0126
0127
0128
0129
0130
0131
0132
0133
0134
0135
0136
0t37
0138
0139
,0140
02S7
0259
025A
02SI
02SI
02SF
0260
0242
0264
0246
0248
0269
0261
0260
0270
0273
0274
0276
0277
0278
027A
0271
027C
027E
0280
0282
0285
0285
0285
0285
0285
0285
0285
0287
0289
028B
028D
028F
0291
0293
0295
0297
029A
029B
029C
0290
029F
02AO
02A1
02A3
02A4
02A5
02A?
02A9
02AB
02AE
02AF
02B1
02B2
02B4
02B7
02B9
02BB
02BC
02BD
02BF
02C1
02G3
02C6
A4 14
C8
C8
11 12
•0 19
Cl
•I 12
•0 10
AS II
91 12
88
AS 10
91 12
20 17 02
20 E4 02
60
A4 14
C8
C8
II 12
AA
C8
II 12
85 13
86 12
4C II 02
AS IS
85 12
A5 16
85 13
AS 13
A6 12
00 07
A4 13
DO 03
4C C6 02
48
8A
48
A4 14
C8
C8
II 12
AA
C8
B1 12
85 13
86 12
20 8D 02
66
85 12
68
85 13
20 C7 02
A4 14
B1 12
AA
C8
B1 12
85 13
86 12
20 80 02
60
LESSTN LIT
INT
INT
LIA
ME
INT
LIA
ME
LIA
8TA
IEY
LIA
STA
JSR
JSR
ITS
NXLRdl LIT
INT
INT
LIA
TAX
INT
LIA
STA
STX
JNP
ENTLEN ,*IOES LEFT POINTEI OF
;CURRENT NOIE * 0 ?
(URKPTR),Y
NXLNOI
<URKPTR>,T
NXLNOI
FREPTR*1
(VRKPTR),T
FIEFTR
<WRKPTR),Y
All
CLRPTR
ENTLEN
<URKPTR),T
(URKPTR),Y
URKPTR*1
URKPTR
IHIOOP
;if so, move ioin/left in tree.
JSET LEFT POINTER OF CURRENT IOIE TO
;POINT TO m NOIE.
;*oi new noie contents.
;clear pointers of new noie.
;ione, nem left noie addeb.
;set u0rkin6 pointer *
;left pointer of current node.
{TRY NEW CURRENT NODE.
;TREE TRAVERSER t LISTS NODES OF TREE
;IN ALPHAMMERICAL ORDER.
;OUTPUT ROUTINE TO XFER IUFFER TO OUTPUT
DEVICE 18 NEEIEI.
TRVRSE LIA
STA
LIA
STA
SEARCH LOA
LIX
INE
LIT
INE
JNP
OK PHA
TXA
PHA
LOT
INT
INT
LDA
TAX
INY
LIA
STA
STX
JSR
PLA
STA
PLA
STA
JSR
LDY
LOA
TAX
INY
LOA
STA
STX
JSR
RETN RTS
8TRTPT
URKPTR
STRTPU1
URKPTR*1
URKPTR*1
URKPTR
OX
URKPTR*1
OX
RETN
ENTLEN
{WORKING POINTER <= START POUTER.
;IF U0RKIN6 POINTER <> 0,
{CONTINUE;
{ELSE, RETURN.
;PUSH WORKING POUTER
;ONTO STACK.
f*SET U0RKIN6 POINTER =
;left pointer of current node.
(URKPTR)VY
(URKPTR)J
URKPTR*1
URKPTR
SEARCH
URKPTR
URKPTR*1
OUT
ENTLEN
(URKPTR),Y
(URKPTR)fY
URKPTR*t
URKPTR
SEARCN
;SEARCH NEW NODE, RECURSIVELY.
•POP OLD CURRENT NODE INTO U0IKIN6 POINTER.
{OUTPUT CURRENT NODE CONTENTS.
JSET U0RKIN6 POINTER =
{CURRENT NODE'S RI6HT POINTER.
{SEARCH NEW NODE.
{DONE, RETURN.
Fig. 9-37: Tree Search Programs (cont.)
323
PROGRAMMING THE 6502
0141
0142
0143
0144
0145
0146
0147
0148
014?
0150
0151
0152
0(53
0154
0155
0156
0157
0158
0159
0160
0161
0162
0163
0164
0165
0166
0167
0168
0169
0170
0171
0172
0173
0174
0175
0176
0177
0176
0179
0180
0181
0182
0183
0184
0185
02C7
02C7
02C7
02C7
02C9
02CI
02CE
02CF
02D1
02D3
0264
02D5
02D6
02D7
02D7
0207
02D7
02D7
02D9
02DC
02DE
020F
02E1
02E3
02E4
02E4
02E4
02E4
02E4
02E6
02E6
02Efi
02EA
02EC
02E0
02EE
02F0
02F2
02F3
02F5
02F7
02F9
02FB
02FD
02FE
AO
B1
99
C8
C4
DO
EA
EA
EA
60
AO
B9
91
CB
C4
DO
60
A4
A9
A2
91
C8
CA
DO
AS
18
69
65
90
E6
85
60
00
12
17 00
14
F6
00
\7 00
10
14.
F6
14
00
04
10
FA
14
04
10
02
11
10
j
;IUFFER OUTPUT ROUTINE.
{
OUT
XFR
•
LDY 10
LDA <URKPTR),Y
STA BUFFER,Y
INY
CPY ENTLEN
INE XFR
NOP
NOP
NOP
RTS
{ROUTINE UHICH PLACES I
{CONTENTS IN NEU NODE.
;
ADD
NOV
•
LDY 10
LDA BUFFER,Y
STA (FREPTR),Y
INY
CPY ENTLEN
8NE NOV
RTS
;get chr. from current node.
;PUT IN BUFFER.
{REPEAT UNTIL...
{ALL CHARACTERS XFERRED.
{INSERT CALL TO SUBROUTINE
{UHICH OUTPUTS BUFFER HERE.
{DONE.
IUFFER
{GET CHR. FROM BUFFER.
{STORE IN NEU NODE.
{REPEAT UNTIL...
{ALL CHR6 XFERREB.
{DONE.
{ROUTINE TO CLEAR P0INTEI8 OF NEU NOTE,
,-and i
{
UPDATE FREE SPACE
CLRPTR LDY ENTLEN
CLRLP
CC
;to
LDA 10
LDX 14
STA (FREPTR)fY
INY
DEX
m clrlp
LDA ENTLEN
CLC
ADC 14
ADC FREPTR
BCC CC
INC FREPTR*1
STA FREPTR
RTS
.END
POINTER.
{SET UP INDEX TO POINT
TOP OF POINTER LOCATIONS.
{LOOP 4X TO CLEAR POINTERS
{CLEAR POINTER LOCATION.
{POINT TO NEXT POINTER LOCATION
{LOOP IF NOT DONE.
{6ET ENTRY LENGTH,
{AND ADD 4 FOR POINTER SPACE.
{ADD TO FREE SPACE POINTER TO
{UPDATE IT.
{TAKE CARE OF OVERFLOWS.
{RESTORE UPDATED FREE SPACE PTR
{DONE.
ERRORS = 0000 <0000>
END OF ASSENBLY
Fig. 9-37: Tree Search Programs (cont.)
324
DATA STRUCTURES
A HASHING ALGORITHM
A common problem when creating data structures is how to place
identifiers within a limited amount of memory space in a sys
tematic way so that they can be retrieved easily. Unfortunately,
unless identifiers are distinct sequential numbers (without gaps),
they do not lend themselves to placement in the memory with
out gaps. In particular, if names were to be placed in the memoiv so
that they could be most easily retrieved (i.e., if they were placed
alphabetically), this would require a huge amount of memory;
a single memory block would have to be reserved for every possible
name. This is clearly not acceptable. To solve this problem, a hashing
algorithm can be used to allocate a unique (or almost unique) number
to every name which has to be entered into memory. The mathematical
function used to perform the hashing should be simple so that the algo
rithm can be fast, yet sophisticated enough to randomize the distri
bution of the possible names over the available memory space. The re
sulting number can then be used as an index to the actual location, and
fast retrieval will be possible. It is for this reason that hashing is com
monly used for directives of alphabetic names.
Since no algorithm can guarantee that two names will not hash
into the same memory location (a "collision") a technique must be
devised to resolve the problem of collisions. A good hashing algor
ithm will spread names evenly over the available memory space,
and will allow efficient retrieval of their values once they have been
stored in a table. The hashing algorithm used here is a very simple
one, where we perform the exclusive OR of all the bytes of the key.
A rotation is performed after every addition to improve the ran
domization.
The technique used to resolve collisions is a simple sequential
one. It is technically called a "sequential open addressing tech
nique; " the next sequentially available block in the table is
allocated to the entry. This can be compared to a pocket address
book. Let us assume that a new entry must be entered for SMITH.
However, the "S" page is full in our small address book. We will
use the next sequential page ("T" here). Note that there will not
necessarily be another collision with a new entry starting with a "T";
the entry for "S" may be removed ("whited out," in our comparison)
before a * *T" ever needs to be entered.
Also note that there could be a chain of collisions. If the chain is
long, and the table is not full, the hashing algorithm is a bad de
sign.
325
PROGRAMMING THE 6502
Since it is convenient to use a power of two for the data format,
the length of the data is eight characters; six are allocated to the
key, and two to the data. This is a typical situation when creating,
for example, the symbol table for an assembler. Up to six hexa
decimal symbols are allocated to the symbol, and two are allocated
to the address it represents (2 bytes).
When retrieving elements from the hashing table, the time re
quired by the search does not depend on the table size, but on the
degree to which the table has been filled. Typically, keeping the
table less than 80\%full will insure a high access time (one or two
tries). It is the responsibility of the calling routine to keep track of the
degree of fullness of the table and prevent overflow.
The increase of the access time versus table fullness is shown in
Fig. 9-39. The main routines used by the program are the initialize
subroutine (INIT), shown in Fig. 9-40; the store routine, shown in
Fig. 9-41; the retrieve routine, shown in Fig. 9-42; and the hash routine,
shown in Fig. 9-43. The memory allocation is shown in Fig. 9-44,
and the program is given in Fig. 9-45. The program is intended to demon
strate all the main algorithms used in an actual hashing
mechanism. If these programs are to be imbedded in an actual imple
mentation, it is strongly suggested that the usual housekeeping
ACCESS
TIME
TABLE FULLNESS
Fig. 9-39: Access Time vs. Relative Fullness
326
DATA STRUCTURES
Fig. 9-4O: Initialize Subroutine
Fig. 9-41: "Store" Routine
327
PROGRAMMING THE 6502
j START ]
HASH KEY IN BUFFER
PUT RESULT IN INDX
KEY AT TABLE (PTR) "S^ N
MATCHES KEY IN BUFFER?
1—*
INDEX = INDEX - ENTNUM
PLACE DATA UNIT AT
TABLE (PTR) IN BUFFER
[ DONE j
INDEX = INDEX + 1
Fig. 9-42: Retrieve Routine, "Find"
328
DATA STRUCTURES
CLEAR A
i
Y = 5
\
A = (A) EXCLUSIVE
OR TABLE [PTR + Y]
A =
N
Y =
< Y
I
A * 2
\
= Y- 1
= -1? ^>
INDEX = A
i
[ DONE ]
Fig. 9-43: Hash Routine
329
PROGRAMMING THE 6502
functions required to prevent unexpected situations be added. In
particular, one should guard against the possibility of a full table
or of an incorrect key since these might cause infinite loops to oc
cur in the program. The reader is strongly encouraged to study
this program. Not only will it demystify a hashing algorithm, but
it will also solve an important practical problem encountered when
designing an assembler, or any other structure where tables of
names with their equivalent values must be kept in an efficient
way.
PAGEO
HIGH MEMORY
\$200
Fig. 9-44: Hash Store/Retrieve: Memory Maps
330
DATA STRUCTURES
LINE I LOC COIE LINE
0002 OOOO ;PtMRAN Tl I TOW MSCMMLCI SVHMIS II *
0003 0000 .'TAILE, ACCESSES IT NASMN8. TNC STHMIS
0004 0000 ;AR£ A CMS, IATA 2. THE HAXINM HOMER OF
0005 0000 ;8-ITTE WITS TO K ITMEI IN THE TAILE
0006 0000 ;SNOULI IE IN 'ENTNUN', SE8INNIN0 ADWESB OF
0007 0000 ;"ILE SNOULI IE IN 'TAME'. NOTE THAT
0008 0000 ;TAILE HUBT IE INITIALIZEI WITH ROUTINE
OOOf 0000 JIN"' PRIOR TO USE.
0010 0000 ;IT IS THE RESPONSIBILITY OF THE CALLINS
0011 0000 JPR06RM NO TO EICEEI THE TAtU SHE.
0012 0000 •
/JO 11 AAAA • « 110
0 1 0010 00 04 TAHE .yORI «6W ;STARTM8 ADMESS OF TABLE.
O01S 0012 INM •••♦! jWW OF IATA UNIT TO BE ACCESSED.
oft a 0013 PTR •••♦2 ;fOINTER TO MTA UNIT IN TAHE.
2" 2iS MTifJ •—I INURIER OF ENTRIES IN TMU 129* MAX)
0018 0016 IUFFER •«•♦• ;INPUT/ OUTPUT IOFFER.
0019 001E •
0020 00IE • ■ •*••
2» 0200 IwUTINE 'INIT' i INITIALIZES TAtLE
0023 0200 ;T0 ZEROES.
0024 0200 ;
Zl °022°0°2 '2 !53 IM" s" RT IB1K • .F ENTRIES » POINTER
0027 0204 20 72 02 JSR SHAH ;«JLTIF1T PTRtl, All TAHE PIINHR.
0028 0207 A2 00 LDX 10 ;CLEAR X FOR INHRECT AHRESSWS.
0029 0209 A9 00 CLRLP LDA 10 JSET CLEARINO CONSTANT
Toll SS 2 n m « iir ptr o o, nkt decreient hi im.
2» 020F C6 14 DECPTR*! JIECRENENT NI ITTE OF POINTER.
0033 0211 C6 13 BECR DEC PTR ;KCRENENT LO ITTE.
0034 0213 81 13 STA (PTRVX> JCLEAR LOCATION.
0035 02 5 A5 3 LIA PTR JCHECK IF POWER - TAILE POWER,
0036 0217 C5 10 CHP TAILE |lF UNEOUAL, CLEAR NEXT LOCATION.
0037 0219 00 EE INE CLRLP
0038 0218 AS 14 LIA PTR*1
0039 021D C5 11 CHP TAILEM
0040 021F 80 E8 INE CLRLP
0041 0221 60 MS
0043 0222 -ROUTINE 'STORE'S PLACES BUFFER C0NTENT8 IN
0044 0222 ;TA8LE, U8IN8 1ST 6 CMS. OF tWFER AS A
0045 0222 ;'KEY' TO OETERNINE NA8HSI AIIRESI XI
0046 0222 {TAILE.
0048 0222 A2 00 STORE LDX 10 JCLEAR X FOR INKXED AD9REI8IN0.
0049 0224 20 90 02 JSR HASH JBET HA8NEI INIEX..
0050 0227 20 62 02 CHPR1 JSR LINIT ;NAKE SORE INIEX IS HITHII I0IM8.
0091 022A A1 13 LIA (PTRfX) JCHECK IATA UNIT...
0052 022C F0 05 IEO ENPTT JJUNP IF HPTT.
0053 022E E6 12 INC INIX ;TRT NEXT UNIT.
O094 0230 4C27 02 JHP CHPRI ;CHECX FOR NEXT WIT INDEX VALID.
0U3 0233 A0 07 ENPTY LIT 17 ;LOOP OX TO LOAI IATA UNIT.
0096 0239 19 16 00 FILL LIA BUFFER,Y ;8ET CHR FROM IUFFER,
0097 0238 9113 STA (PTR),Y ;PLACE ITU IUFFER.
0098 023A 18 IEY
0099 0231 10 F8 IPL FILL ;XFER NEXT CRR.
0060 0238 60 RTS ;AIIITION DINC.
0061 023E ;
0062 023E {ROUTINE 'FINI' I
0063 023E ;FINIS ENTRY VHOSE KEY IS IN BUFFER.
0064 023E ,'EKTRY, UHEN FOUNIV IS COPIEB INTO
0*69 023E ;IUFFER, AL0N8 WITH 2 IVTEI OF DATA.
0066 023E \
0067 023E A2 00 FINI LDX 80 ;CLEAR X FOR IWIIECT AIDIE88IH8.
0061 0240 20 90 02 JSR HASH ;OET HASH PROWCT.
0A69 0243 20 62 02 CHPR2 JSR LIMIT JHAKESURE RESULT IS UXTHIN LIMITS
Fig. 9-45: Hashing Program
331
PROGRAMMING THE 6502
0070
0071
0072
0073
0074
0075
0076
0077
0078
007?
0080
0061
0082
O083
0084
008S
0086
0087
0088
008?
0090
0091
0092
O093
0094
0095
0096
0097
0098
0099
otoo
otot
0102
0103
0104
0105
0106
0107
0108
0109
0110
0111
0112
0113
0114
0115
0116
0117
0118
0119
0120
0121
0122
0123
0124
0125
0126
0127
ERRORS
SYHBOL
SYMBOL
BAD
CHPR1
ENTNUN
HASH
NATCH
STORE
END OF
0246
0248
024A
024D
024F
0250
0252
0254
0256
0259
025A
025C
025D
025F
0262
0262
0262
0262
0262
0262
0262
0264
0266
0268
0269
026B
026E
0270
0272
0274
0276
0278
027A
027C
027E
0280
0282
0283
0285
0287
0289
028B
028D
026F
0290
0290
0290
0290
0290
0292
0293
0295
0298
0299
029A
029C
029E
029F
AC
B1
D9
DO
88
10
AO
B1
99
88
10
60
E6
4C
A5
C5
90
38
ES
4C
85
85
A9
85
06
26
06
26
06
26
18
AS
65
85
A5
65
85
60
A9
18
AO i
59
2A
88
10 1
85
60
' OS
13
16 00
OE
F6
07
13
\6 00
F8
12
43 02
12
15
06
15
64 02
13
12
00
14
13
14
13
14
13
14
10
13
13
11
14
14
00
D5
16 00
F9
12
« 0000 <0000>
TABLE
VALUE
025D
022?
0015
0290
025
022
•»
2
ASSEMBLY
BUFFER
CHPR2
EXOR
INDX
OK
TABLE
CHKLP
NATCH
XFER
BAD
LDY 15
LDA <PTR),Y
CMP BUFFER,Y
BNE BAD
DEY
BPL CHKLP
LDY 17
LDA (PTR)fY
STA BUFFER,Y
DEY
BPL XFER
RTS
INC INDX
JHP CNPR2
,'ROUTINE TO HAKE SURE
;BOUNDS SET BY ENTNUN
t'BY 8, AND ADD IT TO
t'RESULT IS PLACED IN
\$
LIMIT
TEST
OK
SHADD
•
LDA INDX
CNP ENTNUN
BCC OK
SEC
SBC ENTNUN
JHP TEST
STA PTR
STA INDX
LDA 10
STA PTRM
ASL PTR
ROL PTR*t
ASL PTR
ROL PTR+1
ASL PTR
ROL PTR+1
CLC
LDA TABLE
ADC PTR
STA PTR
LDA TABLE*1
ADC PTR+1
STA PTRM
RTS
;LO0P 6X TO CONPARE BUFFER TO DATA
;6ET CNR FRON TABLE.
;IS IT a BUFFER CHR?
,'IF NOT, TRY NEXT DATA UNIT.
;CHECK NEXT CHRS.
;loop sx to xrER chrs to buffer.
,*6ET CHR. FRON TABLE.
{STORE IN BUFFER.
;LOOP TO XFER CHRS.
.'DONE sDATA UNIT FOUND, IN BUFFER.
;not found, try next data unit.
.'VALIDATE H€U DATA UNIT INDEX.
DATA INDEX IS UITHIN
, THEN NULTIPLY INDEX
TABLE POINTER. THE
'PTR' AS DATA UNIT ADDRESS.
;get index.
;INDEX > NUMBER OF DATA ITEMS?
;JUNP IF NOT.
;yes -
;SUBTRACT 1 Or ITEMS UNTIL
;INDEX UITHIN BOUNDS.
f'STORE 600D INDEX IN POINTER.
;SAVE UPDATED INDEX.
,• CLEAR UPPER POINTER FOR SHIFT.
,'SHIFT PTR 3X LEFT - MULTIPLY BY 8.
;add pointer and table start
;address and place result in pointer
{ROUTINE TO 6ENERATE DATA UNIT INDEX IN TABLE
;BY HASHING 'KEY', OR
HASH
EXOR
0016
0243
0295
0012
026E
0010
LDA 10
CLC
LDY IS
EOR BUFFER,Y
ROL A
DEY
BPL EXOR
STA INDX SAVE H
RTS
.END
CHKLP 0240
DECR 0211
FILL 0235
INIT 0200
PTR 0013
TEST 0264
CHRS OF LABEL.
;CLEAR LOCATION FOR INDEX.
;PREPARE TO ADD.
JLOOP 6X FOR EXCLUSIVE ORS.
;exclusive-or accun. uith buffer chr
;MULTIPLY ACCUN. BY 2.
,'COUNT DOUN CHRS.
,'6ET NEXT CHR.
IASH PRODUCT AS INDEX.
;done.
CLRLP 020r
EMPTY 0233
FIND 023E
LIHIT 0262
SHADD 0272
XFER 0254
Fig. 9-45: Hashing Program (cont.)
332
DATA STRUCTURES
BUBBLE-SORT
Bubble-sort is a sorting technique used to arrange the elements
of a table in ascending or descending order. The bubble-sort tech
nique derives its name from the fact that the smallest element
"bubbles up" to the top of the table. Every time it "collides" with
a "heavier" element, it jumps over it.
A practical example of bubble-sort is shown in Fig. 9-46. The list
to be sorted contains: 10, 5, 0, 2, and 100, and must be sorted in
descending order ("0" on top). The algorithm is simple, and the
flowchart is shown in Fig. 9-47.
The top two (or bottom two) elements are compared. If the
lower one is less ("lighter") than the top one they are exchanged.
Otherwise, they remain the same. For practical purposes, the exchange,
if it occurs, will be noted for future use. Then, the next pair of elements
will be compared, etc., until all elements have been compared two by two.
This first pass is illustrated by steps 1, 2, 3, 4, 5, and 6 in Fig. 9-47,
going from the bottom up. (Equivalently, we would go from the top
down.)
If no elements have been exchanged in one pass, the sort is complete.
If an exchange has occurred, we start all over again.
Looking at Fig. 9-47, it can be seen that four passes are neces
sary in this example.
The process described above is simple, and is widely used.
One additional complication resides in the actual mechanism of
the exchange. When exchanging A and B, one may not write:
A = B
B = A
as this would result in the loss of the previous value of A. (try it on
an example.)
The correct solution is to use a temporary variable or location to
preserve the value of A:
TEMP = A
A =B
B = TEMP
It works. (Again, try it on an example.) This is called a circular permu
tation., and it is the way all programs implement the exchange. The
technique is illustrated in the flowchart of Fig. 9-47.
333
PROGRAMMING THE 6502
10
5
0
2
100
100>2:
NO CHANGE
*— 1-4
«*— 1 = 5
10
5
0
2
100
2>0
NO CHANGE
*+— 1 3
■* 1 4
10
5
0
2
100
0<5
EXCHANGE'
«*— 1 • 2
"^— 1 3
© ©
0
0
10
2
5
100
2<10:
EXCHANGED
"*— 1 = 2
«*— 1=3
10
0
5
2
100
EXCHANGED
©
0
10
5
2
100
100>2:
NO CHANGE
n
«* 1 = 4
■*— 1 = 5
10
0
5
2
100
0< 10:
EXCHANGEE
0
10
5
2
100
2<5:
EXCHANGED
©
10
100
"*-l
EXCHANGED
1 -1
1 = 2
E
E
= 3
= 4
0
10
5
2
100
n
EXCHANGED
ND OF PASS 1
©
ND OF PASS 1
0
10
2
5
100
n
EXCHANGED
©
0
2
10
5
100
•*— 1 = 1
<*— 1 = 2
2>0:
NO CHANGE
U2J
END OF PASS 2
Fig. 9-46: Bubble-Sort Example
334
DATA STRUCTURES
10
100
1=4
1 = 5
100>5:
NO CHANGE
10
100
1=3
1 = 4
5<10:
EXCHANGED
10
100
EXCHANGED
(\5)
10
100
1 = 2
1=3
5>2:
NO CHANGE
10
100
•1 = 1
1=2
2>0:
NO CHANGE
10
100
1=4
1 = 5
100 > 10:
NO CHANGE
END OF PASS 3
10
100
1 = 3
1 = 4
10>5:
NO CHANGE
10
100
1=2
1=3
5>2:
NO CHANGE
10
100
2>0:
NO CHANGE
END
Fig. 9-46: Bubble-Sort Example (cont.)
335
PROGRAMMING THE 6502
GET NUMBER OF
ELEMENTS N
I=N
EXCHANGE E AND E
TEMP = E(l)
Fig. 9-47: Bubble-Sort
336
DATA STRUCTURES
The memory map corresponding to the bubble-sort program is
shown in Fig. 9-48. In this program, every element will be an 8-bit
positive number. The program resides at addresses 200 and follow
ing. Register X is used to memorize the fact that an exchange has
or has not occurred, while register Y is used as the running pointer
within the table. TAB is assumed to be the beginning address of
the table. The actual program appears in Fig. 9-49. Indirect in
dexed addressing is used throughout for efficient accessing. Note
how short the program is, due to the efficiency of the indirect ad
dressing mode of the 6502.
0000
0001
— TABLE PTR —
PROGRAM
NUMBER n
ELEMENT 1
ELEMENT 2
ELEMENT n
|—
CURRENT ELEMENT
] C
Fig. 9-48: Bubble-Sort: Memory Map
337
PROGRAMMING THE 6502
SORT PAGE OOOI
LINE
O002
0003
O004
O005
O006
O007
0006
O009
0010
0011
O012
0013
O014
0015
0016
0017
O0I8
0019
0020
0021
O022
O023
O024
O025
O026
O027
0028
0029
0030
1 LOC
0000
0000
0000
0000
0000
0002
0002
0200
0200
0202
0204
0205
0207
0208
020A
020C
020E
020F
0211
0212
0214
0215
0216
0218
02IA
02IC
02ID
021F
0220
00
A2
At
A8
Bt
68
FO
D1
BO
AA
Bt
C8
91
8A
68
91
A2
DO
8A
DO
60
CODE
06
00
00
00
12
00
F7
00
00
00
01
E9
Ef
LIME
j
•
TAB
j
•
SORT
LOOP
EXCH
FINISH
BUBBLE SORT m
• * »0
.UORD 1600
• * 1200
LDX 10
LDA <TAB,X>
TAY
LDA (TAB),Y
DEY
BEQ FINISH
CMP <TAB),Y
BCS LOOP
TAX
LDA <TAB),Y
INY
STA <TAB),Y
TXA
DEY
STA <TAB),Y
LDX It
BNE LOOP
TXA
BNE SORT
RTS
.END
NifcrtN
,'SET EXCHANGE 0' TO 0
;nuhber of elements is in y
;read element e(d
JDECREMENT NUMBER OF ELEMENTS TO READ.
;END IF NO MORE ELEMENTS
ICOHPARE TO EMI)
;GET NEXT ELEMENT IF E(I»E'U>
{EXCHANGE ELEMENTS
;SET EXCHANGED TO 1
;get next element
.-SHIFT EXCHANGED TO A REG. FOR C0MP4
JIF SOME EXCHANGES MADEf DO ANOTHER H
ERRORS - 0000 <0000>
SYMBOL TABLE
SYMBOL VALUE
EXCN 020E FINISH 021C LOOP
TAB 0000
EMD OF ASSEMBLY
0205 SORT O2O0
Fig. 9-49: Bubble-Sort Program
338
DATA STRUCTURES
NO ^ PTR1> \ YES
TABLEl (0)?
Fig. 9-5O: Merge Flowchart
339
PROGRAMMING THE 6502
A MERGE ALGORITHM
Another common problem consists in merging two sets of data
into a third one. We will assume here that two tables of data have
been previously sorted, and we want to merge them into a third table. The
length of each of the two original tables will be limited to 256 bytes (one
page). The first entry of every table contains the length of the table
of the table.
The algorithm for merging two tables is shown in Fig. 9-50. The
corresponding memory organization is shown in Fig. 9-51, and the
program appears in Fig. 9-52. Remember to set ' TABLE 1"
"TABLE2," and "DESTBL" before using it.
The algorithm itself is straightforward. Two running pointers
PTR1 and PTR2, point to the two source tables. PTR3 points to
the resulting table.
Fig. 9-51: Merge Memory Map
340
DATA STRUCTURES
LINE 1
0992
0003
0004
0909
000*
0907
0998
0909
0910
0911
0912
0913
0014
0019
001*
0017
0018
0919
0920
0921
0922
0923
0924
0929
092*
0927
0928
0929
0930
0931
0932
0933
0934
0939
093*
0037
0939
0939
0040
0941
0942
0943
0044
0949
094*
0947
0048
0949
0990
0991
0992
0993
0994
0999
009*
0997
0999
0999
09*0
09*1
09*2
09*3
09*4
09*9
09**
09*7
09*8
09*9
1 L8C
9000
9000
9000
9000
0000
0090
9000
0000
0000
0090
0000
9010
0012
0014
001*
0017
0018
001A
901A
0200
0200
0202
0204
020*
0208
020A
020C
020E
0210
0212
0214
021*
0218
021A
921C
021E
0220
0222
0224
0224
922*
9228
022A
022C
022F
0231
0233
9239
0237
0239
923B
023B
023F
0241
9243
0249
9247
0249
924B
024B
924E
0290
0292
0294
029*
0298
929A
0251
A9
89
A9
89
A9
89
89
A2
A1
C9
90
A1
C9
90
A4
B1
A4
B1
90
A4
B1
E*
4C
A4
B1
E6
81
E*
BO
E*
A1
C9
BO
A1
C9
BO
A9
89
18
A1
61
89
90
A9
89
60
COBE
11
19
10
18
91
1*
17
00
14
17
19
12
1*
OA
1*
12
17
14
99
17
14
17
39 92
1*
12
1*
18
18
92
19
12
1*
CB
14
17
C7
00
19
12
14
18
04
01
19
LINE
;2-p*GJ
;tares
• RERBE.
2 BATA TABLES PREVIONSLY 8SRTEB,
{ANB HEROES THEN INTO
;EACN SOORCE TABLE CAI
{PA8E i
A TNIRB TABLE.
1 BE OP TO BNE
[29* BYTES) IN LENOTN.
;tne first elenent of
;TABLE!
{'PTR3'
THE IOBRCE
1 MIST CONTAIN THE TABLE LEHBTN.
' CONTAINS TNE LENGTH BF TRE
{BESTINATION TABLE AT
•
BESTBL
TABLE1
TABLE2
PTR1
PTR2
PTR3
•
•
CONPR
TRTB2
TRTB1
STORE
CC
ccc
• « 110
•■•♦2
•■•♦| j
•«•♦! ;
♦■•♦2 j
• ■ 9200
LBA IE8TILH
STA PTR3*1
LBA BESTBL
STA PTR3
LBA 11
STA PTR1
STA PTR2
LBX 19
LBA (TABLE2,X)
CNP PTR2
BCC TRTB1
LBA (TABLE1,X)
CRP PTR1
BCC TKTB2
LIT PTR1
LBA (TABLED,Y
LBY PTR2
CRP (TABLE2),T
RETNRN.
{POINTER TO BE8INNIN6 OF DESTINATION TABLE
{POINTER TO SOURCE TABLE 1.
{POINTER TO SOURCE TAILE 2.
! TABLE 1 INBEX.
! TABLE 2 INDEX.
IBESTINATIBN TAILE INIEX.
{PTR3 - TABLE3
{SET SOURCE TABLE POINTERS TO BEGIRNIRG,
{SRIPPIN8 TABLE LENOTNS.
{CLEAR X FOR INBIRECT ABDIES8ING.
{IS TABLE 2 LENGTH <
{TABLE 2 POINTER?
{IF YES, SET BYTE FROM TABLE 1.
{II TABLE 1 LEN8TN <
{TABLE 1 POINTER?
{IF YES, 6ET IYTE FROM TABLE 2
{SET POINTER FOR TAILE 1.
{USE IT TO FETCH IYTE.
{OET POINTER FOR TABLE 2,
{USE IT TO FINB BYTE TO CORPARE
;T0 TABLE 1 BYTE.
BCC TKTB1
LIT PTR2
LIA (TAILE2),T
IRC PTR2
JRP STORE
LBY PTR1
LIA (TABLED,T
IRC PTR1
STA (PTR3,X)
IRC PTR3
BHE CC
IRC PTR3*1
LIA (TABLE1,X)
CHP PTR1
IC8 CONPR
LIA (TABLE2,X>
CHP PTR2
ICS CONPR
LM 19
STA PTR3+1
CLC
LIA (TABLE1,X)
ABC (TABLE2,X)
STA PTR3
ICC CCC
LBA 11
STA PTR3*1
RTS
.END
UF TABLE 1 BYTE LES8. TARE IT.
{GET POINTER FOR TABLE 2.
{8ET NEXT BYTE FRON TABLE 2.
{IRCREHENT POINTER FOR TABLE 2.
{00 STORE BYTE IN BE8TIHATI0N TABLE.
{SET POINTER 1...
{ARB U8E IT TO GET BYTE FROM TABLE.
{IRCREHEHT POINTER FOR TABLE 1.
{STORE BYTE AT REXT LOCATION IN TABLE 3.
{IRCRENENT LO ORBER TABLE 3 POINTER.
{IF RO OVERFLOW, SKIP
{IRCRENENT NI ORDER TABLE 3 PIIRTER.
{IS TABLE 1 LEHOTN 8REATER
{THAR OR EQUAL TO POIHTER 1?
{IF YES, SET IEXT BYTE.
{IS TABLE 2 LEN8TH GREATER
{THAR OR EQUAL TO POINTER 2?
{IF YES, SET IEXT BYTE.
{CLEAR PTR3 NI BRDER.
{HER6E BORE, ROU..
{AID TABLE 1 ANI 2 LERGTHI.
{STORE 8UH IN TABLE 3 TEMPORARY POINTER.
.{AND..
{OVERFLOU IN...
{HI ITTE.
ERRORS > 0000 <0000>
ERB OF ASSEMBLY
Fig. 9-52: Merge Program
341
PROGRAMMING THE 6502
The current entries in TABLE 1 and TABLE2 are compared two
at a time. The smaller one is copied into TABLE3 and the corresponding
running pointer is incremented. The process is repeated and terminates
when both PTRl and PTR2 have reached the bottom of their respective
tables.
SUMMARY
The basic concepts relative to common data structures, as well
as actual implementation examples have been presented.
Because of its powerful addressing modes, the 6502 lends itself
well to the management of complex data structures. Its efficiency
is demonstrated by the terseness of the programs shown.
In addition, special techniques have been presented for hashing,
sorting and merging, which are typical of those required to solve
complex problems involving actual data structures.
The beginning programmer need not concern himself yet with
the details of data structures implementation and management.
However, for efficient programming of non-trivial algorithms, a good
understanding of data structures is required. The actual examples
presented in this chapter should help the reader achieve such an under
standing and solve all the common problems encountered with reason
able data structures.
342
10
PROGRAM DEVELOPMENT
INTRODUCTION
All the programs we have studied and developed so far have
been developed by hand without the aid of any software or
hardware resources. The only improvement we have used over
straight binary coding has been the use of mnemonic symbols,
those of the assembly language. For effective software develop
ment, it is necessary to understand the range of hardware and
software development aids. It is the purpose of this chapter to
present and evaluate these aids.
BASIC PROGRAMMING CHOICES
Three basic alternatives exist: writing a program in binary or
hexadecimal, writing it in assembly-level language, or writing it
in a high-level language. Let us review these alternatives.
1. Hexadecimal Coding
The program will normally be written using assembly lan
guage mnemonics. However, most low-cost, one-board computer
systems do not provide an assembler. The assembler is the pro
gram which will automatically translate the mnemonics used for
the program into the required binary codes. When no assembler is
available, this translation from mnemonics into binary must be
performed by hand. Binary is unpleasant to use and error-prone,
so that hexadecimal is normally used. It has been shown in Chap-
343
PROGRAMMING THE 6502
ter 1 that one hexadecimal digit will represent 4 binary bits. TWo
hexadecimal digits will, therefore, be used to represent the con
tents of every byte. As an example, the table showing the
hexadecimal equivalent of the 6502 instructions appears in the
Appendix.
In short, whenever the resources of the user are limited and no
assembler is available, he will have to translate the program by
hand into hexadecimal. This can reasonably be done for a small
number of instructions, such as, perhaps, 10 to 100. For larger
programs, this process is tedious and error-prone, so that it tends
not to be used. However, nearly all single-board microcomputers
require the entry of programs in hexadecimal mode. They are not
equipped with an assembler and are not equipped with a full
alphanumeric keyboard, in order to limit their cost.
In summary, hexadecimal coding is not a desirable way to enter
a program in a computer. It is simply an economical one. The cost
of an assembler and the required alphanumeric keyboard is
traded-off against increased labor to enter the program in the
memory. However, this does not change the way the program it
self is written. The program is still written in assembly-level language
so that it can be not only meaningful, but also capable of inspection
and examination by the human programmer.
2. Assembly Language Programming
Assembly-level programming covers programs that may be entered
in hexadecmial, as well as those that may be entered in symbolic
assembly-level form, in the system. Let us now directly examine the
entry of a program, in its assembly language representation. An
assembler program must be available. The assembler will read each of
the mnemonic instructions of the program and translate it into the re
quired bit pattern using 1, 2 or 3 bytes, as specified by the encoding of
the instructions. In addition, a good assembler will offer a number of
additional facilities for writing the program. These will be reviewed in
the section on the assembler below. In particular, directives are available
which will modify the value of symbols. Symbolic addressing may be used,
and a branch to a symbolic location may be specified. During the
344
PROGRAM DEVELOPMENT
debugging phase where a user may remove instructions or add
instructions, it will not be necessary to re-write the entire pro
gram if an extra instruction is inserted between a branch and the
POWER OF
THE
LANGUAGE
SYMBOLIC
APL
COBOL
FORTRAN
PL/M
PASCAL
BASIC
MINI-BASIC
MACRO
CONDITIONAL
ASSEMBLY
HEXADECIMAL/
OCTAL
BINARY
HIGH-LEVEL
ASSEMBLY-LEVEL
MACHINE-LEVEL
Fig. 1O-1: Programming Levels
point to which it branches, as long as symbolic labels are used.
The assembler will automatically adjust all of the labels during the
translation process. In addition, an assembler allows the user to debug
his/her program in symbolic form. A disassembler may be used to
examine the contents of a memory location and reconstruct the
assembly-level instruction that it represents. The various software re
sources normally available on a system will be reviewed below. Let us
now examine the third alternative.
3. High-Level Language
A program may be written in a high-level language such as
BASIC, APL, PASCAL, or others. Techniques for programming in
these various languages are covered by specific books and will not
345
PROGRAMMING THE 6502
be reviewed here. We will, therefore, only briefly review this mode
of programming. A high-level language offers powerful instruc
tions which make programming much easier and faster. These
instructions must then be translated by a complex program into
the final binary representation that a microcomputer can execute.
Typically, each high-level instruction will be translated into a
large number of individual binary instructions. The program
which performs this automatic translation is called a compiler or
an interpreter. A compiler will translate all the instructions of a
program in sequence into object code. In a separate phase, the
resulting code will then be executed. By contrast, an interpreter
will interpret a single instruction and execute it, then
"translate" the next one and execute it. An interpreter offers the
advantage of interactive response, but results in low efficiency
compared to a compiler. These topics will not be studied further
here. Let us revert to the programming of an actual microproces
sor at the assembly-level language.
SOFTWARE SUPPORT
We will review here the main software facilities which are (or
should be) available in the complete system for convenient
software development. Some of the programs have already been intro
duced, and definitions of these will be summarized below. Definitions
of other important programs will also be provided before we proceed.
The assembler is the program which translates the mnemonic
representation of instructions into their binary equivalent. It
normally translates one symbolic instruction into one binary in
struction (which may occupy 1,2, or 3 bytes). The resulting binary
code is called object code. It is directly executable by the mi
crocomputer. As a side effect, the assembler will also produce a
complete symbolic listing of the program, as well as the equiva
lence tables to be used by the programmer and the symbol oc
currence list in the program. Examples will be presented later in
this chapter.
A compiler is the program which translates high-level lan
guage instructions into their binary form.
An interpreter is a program similar to a compiler. It also trans
lates high-level instructions into their binary form, but instead
346
PROGRAM DEVELOPMENT
of keeping the intermediate representations, it executes the instruc
tions immediately. In fact, if often does not even generate any inter
mediate code, but rather executes the high-level instructions directly.
A monitor is an indispensable program for using the hardware
resources of this system. It continuously monitors the input devices
for input and also manages the rest of the devices. As an example,
a minimal monitor for a single-board microcomputer, equipped with
a keyboard and with LEDs, must continuously scan the keyboard for
user input and display the specified contents on the light-emittingdiodes.
In addition, it must be capable of understanding a number of
limited commands from the keyboard, such as START, STOP, CON
TINUE, LOAD MEMORY, and EXAMINE MEMORY. On a large
system, the monitor is often qualified as the executive program. When
complex file management or task scheduling is also provided, the
overall set of facilities is called an operating system. In the case in
which files may be resident on a disk, the operating system is quali
fied as the disk operating system, or DOS.
An editor is the program designed to facilitate the entry and
the modification of text or programs. It allows the user to conve
niently enter characters, append them, insert them, add lines, re
move lines, and search for characters or strings. It is an important
resource for convenient and effective text entry.
A debugger is a facility necessary for debugging programs.
Typically, when a program does not work correctly, there may
be no indication whatsoever of the cause. The programmer, there
fore, wishes to insert break-points in his program in order to sus
pend the execution of the program at specified addresses and to
be able to examine the contents of registers or memory at these
points. This is the primary function of a debugger. The debugger
allows for the possibility of suspending a program, resuming
execution, examining, displaying and modifying the contents of
registers or memory. A good debugger will be equipped with a
number of additional facilities, such as the possibility of examin
ing data in symbolic form, hex, binary, or other usual representa
tions, as well as entering data in this format.
A loader, or linking loader, will place various blocks of object
347
PROGRAMMING THE 6502
code at specified positions in the memory and adjust their respect
ive symbolic pointers so that they can reference each other. It is
used to relocate programs or blocks in various memory areas.
A simulator, or an emulator program is used to simulate the opera
tion of a device, usually the microprocessor, in its absence, when
developing a program on a simulated processor prior to placing it
on the actual board. Using this approach, it becomes possible to suspend
the program, modify it, and keep it in RAM memory. The disadvantages
of a simulator are that:
1. It usually simulates only the processor itself, not input/
output devices.
2. The execution speed is slow, and one must operate in simulated
time. It is therefore impossible to test real-time devices, which may
result in synchronization problems even though the logic of the
program may be found to be correct.
An emulator is actually a simulator in real time. It uses one
processor to simulate another one, and simulates it in complete
detail.
Utility routines are essentially all of the routines that the user
wishes the manufacturer had provided! They may include multi
plication, division and other arithmetic operations, block move
routines, character tests, input/output device handlers (or "driv
ers"), and more.
THE PROGRAM DEVELOPMENT SEQUENCE
We will now examine a typical sequence for developing an
assembly-level program. In order to demonstrate their value, we will
assume that all the usual software facilities are available. If all of
them should not be available in a particular system, it would still be
possible to develop programs, but the convenience would be de
creased, and therefore, the amount of time necessary to debug the
program would most likely be increased.
348
PROGRAM DEVELOPMENT
The normal approach is to first design an algorithm and define
the data structures for the problem to be solved. Next, a com
prehensive set of flow-charts is developed which represents the
program flow. Finally, the flow-charts are translated into the as
sembly-level language for the microprocessor; this is the coding
phase.
Next, the program has to be entered on the computer. We will
examine in the following section the hardware options to be used in
this phase.
The program is entered in RAM memory of the system under
the control of the editor. Once a section of the program, such as a
subroutine, has been entered, it will be tested.
First, the assembler will be used. If the assembler does not al
ready reside in the system, it will be loaded from an external
memory, such as a disk. Then, the program will be assembled, i.e.,
translated into a binary code. This results in the object program,
ready to be executed.
One does not normally expect a program to work correctly the
first time. To verify its correct operation, a number of breakpoints
will normally be set at crucial locations where it is easy to test
whether the intermediate results are correct. The debugger will
be used for this purpose. Breakpoints will be specified at selected
locations. A "Go" command will then be issued so that program
execution is started. The program will automatically stop at each
of the specified breakpoints. The programmer can then verify, by
examining the contents of the registers, or memory, that the data
so far is correct. If it is correct, we proceed until the next break
point. Whenever we find incorrect data, an error in the program
has been found. At this point the programmer normally refers to
his program listing and verifies whether his coding has been cor
rect. If no error can be found in the programming, the error might
be a logical one that refers back to the flowchart. We will
assume here that the flow-charts have been checked by hand and
are assumed to be reasonably correct. The error is likely to come
from the coding. It will, therefore, be necessary to modify a sec
tion of the program. If the symbolic representation of the program
is still in the memory, we will simply re-enter the editor and
modify the required lines, then go through the preceding se
quence again. In some systems, the memory available may not be
349
PROGRAMMING THE 6502
large enough, so that it is necessary to flush out the symbolic
representation of the program onto a disk or cassette prior to
executing the object code. Naturally, in such a case, one would
have to reload the symbolic representation of the program from
its support medium prior to entering the editor again.
The above procedure will be repeated as long as necessary until
the results of the program are correct. Let us stress that preven
tion is much more effective than cure. A correct design will typi
cally result very quickly in a program which runs correctly once
the usual typing mistakes or obvious coding errors have been
removed. However, sloppy design may result in programs which
will take an extremely long time to be debugged. The debugging
time is generally considered to be much longer than the actual
design time. In short, it is always worth investing more time in
the design in order to shorten the debugging phase.
Although using this approach makes it possible to test the overall or
ganization of the program, it does not lend itself to testing the pro
gram in terms of real time and input/output devices. If input/output
devices are to be tested, the direct solution consists of transferring the
program onto EPROMs and installing it on the board where it can
be watched to see whether it works or not.
There is an even better solution, and that is the use of an in-circuit
emulator. An in-circuit emulator uses the 6502 microprocessor (or
any other microprocessor) to emulate a 6502 in (almost) real time. It
emulates the 6502 physically. The emulator is equipped with a cable
terminated by a 40-pin connector, exactly identical to the pin-out of a
6502. This connector can be inserted on the real application board that one
is developing. The signals generated by the emulator will be
exactly those of the 6502, only perhaps a little slower. The essen
tial advantage is that the program under test will still reside in
the RAM memory of the development system. It will generate the
real signals which will communicate with the real input/output
devices that one wishes to use. As a result, it becomes possible to
keep developing the program using all the resources of the devel
opment system (editor, debugger, symbolic facilities, file system)
while testing input/output in real time.
In addition, a good emulator will provide special facilities, such
as a trace. A trace is a recording of the last instructions or status
350
PROGRAM DEVELOPMENT
of various data busses in the system prior to a breakpoint. In
short, a trace provides the film of the events that occurred prior to
the breakpoint or the malfunction. It may even trigger a scope at
a specified address or upon the occurrence of a specified combina
tion of bits. Such a facility is of great value, since when an error is
found it is usually too late. The instruction, or the data, which
caused the error has occured prior to the detection. The availability
of a trace allows the user to find which segment of the program
caused the error to occur. If the trace is not long enough, we can
simply set an earlier breakpoint.
BOOTSTRAP
KEYBOARD
DRIVER
DISPLAY
DRIVER
TTY
DRIVER
CASSETTE
DRIVER
COMMAND
INTERPRETER
UTILITY
ROUTINES
ELEMENTARY
DEBUGGER
ELEMENTARY
EDITOR
ASSEMBLER
OR
COMPILER
OR
INTERPRETER
DOS
EDITOR
OR
DEBUGGER
OR
SIMULATOR
SYSTEM
WORKSPACE
(AND STACK)
USER
PROGRAM
USER
WORKSPACE
Flg.lO-2:ATyp
This completes our description of the usual sequence of
events involved in developing a program. Let us now review the
hardware alternatives available for developing programs.
351
PROGRAMMING THE 6502
THE HARDWARE ALTERNATIVES
1. Single-Board Microcomputer
The single-board microcomputer offers the lowest cost approach
to program development. It is normally equipped with a hexadec
imal keyboard, some function keys, and 6 LEDs which can display
address and data. Since it is equipped with a small amount of
memory, no assembler is usually available. At best, it has a small
monitor and no editing or debugging facilities, except for a very
few commands. All programs must, therefore, be entered in hex
adecimal form. They will also be displayed in hexadecimal form on
the LEDs. A single-board microcomputer has, in theory, the
same hardware power as any other computer. However, because
of its restricted memory size and keyboard, it does not support all
the usual facilities of a larger system, and this makes program
development much longer. The tediousness of developing programs
in hexadecimal format makes a single-board microcomputer
best suited for educational and training purposes where programs
of limited length are desirable. Single-boards are probably the
cheapest way to learn programming by doing. However, they
cannot be used for complex program development, unless additional
memory boards are attached and the usual software aids are made
available.
2. The Development System
A development system is a microcomputer system equipped
with a significant amount of RAM memory (32K- 48K)as well as
the required input/output devices, such as a CRT display, a
printer, disks, and usually a PROM programmer, as well as,
perhaps, an in-circuit emulator. A development system is
specifically designed to facilitate program development in an in
dustrial environment. It normally offers all, or most, of the
software facilities that we have mentioned in the preceding sec
tion. In principle, it is the ideal software development tool.
The limitation of a microcomputer development system is that
it may not be capable of supporting a compiler or an interpreter.
352
PROGRAM DEVELOPMENT
Fig. 1O-3: SYM 1 is a Typical Microcomputer Board
Fig. 1O-4-. Rockwell System 65 is a Development System
353
PROGRAMMING THE 6502
This is because a compiler typically requires a very large amount
of memory, often more than is available in the system. However,
for developing programs in assembly-level language, the development
system offers all the required facilities. Unfortunately, because
development systems sell in relatively small numbers compared to.
hobby computers, their cost is significantly higher.
3. Hobby-Type Microcomputers
The hobby-type microcomputer hardware is analogous to that of a
development system. The main difference lies in the fact that the
hobby-type microcomputer is normally not equipped with the
sophisticated software development aids which are available on
an industrial development system. As an example, many hobbytype
microcomputers offer only elementary assemblers, minimal
editors, minimal file systems, no facilities to attach a PROM pro
grammer, no in-circuit emulator, no powerful debugger. They rep
resent, therefore, an intermediate step between the single-board
microcomputer and the full microprocessor development system.
For a user who wishes to develop programs of modest complexity,
they are probably the best compromise since they offer the advan
tage of low cost and a reasonable array of software development
tools, even though they are quite limited as to their convenience.
4. Time - Sharing Systems
Several companies rent terminals that can be connected to time
sharing computer networks. These terminals share the time of the
larger computer and benefit from all the advantages of large installa
tions. Cross assemblers are available for all microcomputers in
virtually all commercial time-sharing systems. A cross assembler is
simply an assembler for, say, a 6502, which resides, for example, in
an IBM370. Formally, a cross assembler is an assembler for micro
processor X, which resides on processor Y. The nature of the com
puter being used is irrelevant. The user still writes a program in 6502
assembly-level language, and the cross assembler translates it into the
appropriate binary pattern. The only difficulty lies in the fact that this
program cannot be executed immediately. It can be executed by a
354
PROGRAM DEVELOPMENT
simulated processor, if one is available, but only if the program does
not use any input/output resources. Because of this drawback, there
fore, time-sharing is practical only in industrial environments.
5. In-House Computer
Whenever a large in-house computer is available, cross as
semblers may also be available to facilitate program devel
opment. If such a computer offers time-sharing service, this option
is essentially analogous to the one above. If it offers only batch
service, this is probably one of the most inconvenient methods of
program development, since submitting programs in batch mode
at the assembly level for a microprocessor results in a very long
development time.
Front Panel or No Front Panel?
The front panel is a hardware accessory often used to facilitate
program debugging. It has been the traditional tool for displaying the
binary contents of a register, or of memory, conveniently. However,
most of the functions of the control panel may now be accomplished
from a terminal through a CRT display. The CRT, with its ability to
display the binary value of bits, thus offers a service almost equiva
lent to the control panel. The additional advantage of using the CRT
display is that one can switch at will from binary representation to
hexadecimal, to symbolic, to decimal (if the appropriate conversion
routines are available, naturally). The main disadvantage of the CRT
is that instead of turning a knob, one must hit several keys to obtain
the appropriate display. However, since the cost of providing a
control panel is quite substantial, most recent microcomputers have
abandonned this debugging tool in favor of the CRT. The value of
the control panel, then, is often evaluated more in function of
emotional arguments based on one's own past experience rather than
by a rational choice. It is not indispensable.
SUMMARY OF HARDWARE RESOURCES
Three broad cases may be distinguished. If you have only a
minimal budget, and if you wish to learn how to program, buy a
355
PROGRAMMING THE 6502
one-board microcomputer. Using it, you will be able to develop all
the simple programs of this book and many more. Eventually,
however, when you want to develop programs of more than a few
hundred instructions, you will feel the limitations of this ap
proach.
If you are an industrial user, you will need a full development
system. Any solution short of the full development system will
cause a significantly longer development time. The trade-off is
clear: hardware resources vs. programming time. Naturally, if the
programs to be developed are quite simple, a less expensive ap
proach may be used. However, if complex programs are to be
developed, it is difficult to justify any hardware savings when
buying a development system; the resultant programming costs will
far exceed any such savings.
For a personal computerist, a hobby-type microcomputer will
typically offer sufficient, although minimal, facilities. Good de
velopment software is still to come for most of the hobby com
puters. The user will have to evaluate his system in view of the
comments presented in this chapter.
Let us now analyze in more detail the most indispensable re
source: the assembler.
THE ASSEMBLER
We have used assembly-level language throughout this book
without presenting the formal syntax or definitions of assemblylevel
language. The time has come to present these definitions.
An assembler is designed to provide a convenient symbolic repre
sentation of the user program, while at the same time providing a
simple means of converting these mnemonics into their binary
representation.
Assembler Fields
When typing in a program for the assembler, we have seen that
fields are used. They are:
The label field, optional, which may contain a symbolic address
for the instruction that follows.
The instruction field, which includes the opcode and any oper
ands. (A separate operand field may be distinguished.)
The comment field, to the far right, which is optional and is
intended to clarify the program.
356
to
8
PROGRAM DEVELOPMENT
<
GD
1
O
Fig. 1O-5: Microprocessor Programming Form
357
PROGRAAAAAING THE 6502
Once the program has been fed to the assembler, the assembler will
produce a listing of it. When generating a listing, the assembler will
provide three additional fields, usually on the left of the page. An
example appears in Fig. 10-6. On the far left is the line number. Each
line which has been typed by the programmer is assigned a symbolic
line number.
The next field to the right is the actual address field, which shows
in hexadecimal the value of the program counter which will point to
that instruction.
The next field to the right is the hexadecimal representation of the
instruction.
This shows one of the possible uses of an assembler. Even if we are
designing programs for a single-board microcomputer which accepts
only hexadecimal, we can still write the programs in assembly-level
language, providing we have access to a system equipped with an as
sembler. We can then run the programs on the system, using the as
sembler. The assembler will automatically generate the correct hexa
decimal codes, which we can simply type in on our system. This
shows, in a simple example, the value of additional software resources.
Tables
When the assembler translates the symbolic program into its binary
representation, it performs two essential tasks:
1. It translates the mnemonic instructions into their binary encoding.
2. It translates the symbols used for constants and addresses into
their binary representation.
In order to facilitate program debugging, the assembler shows at
the end of the listing each symbol used and its equivalent hexadecimal
value. This is called the symbol table.
Some symbol tables will not only list the symbol and its value, but
also the line numbers where the symbol occurs, an additional facility.
Error Messages
During the assembly process, the assembler will detect syntax er
rors and list them as part of the final listing. Typical diagnostics in
clude: undefined symbols, label already defined, illegal op-
358
PROGRAM DEVELOPMENT
code, illegal address, illegal addressing mode. Many more de
tailed diagnostics are naturally desirable and usually provided.
They vary with each assembler.
The Assembly Language
Opcodes have already been defined. We will define here the
symbols, constants and operators which may be used as part of
the assembler syntax.
LINE
0057
00S8
0059
0060
0061
0062
0063
0064
0065
0066
0067
0068
006?
0070
0071
0072
0073
0074
007S
0076
0077
0078
0078
0078
0076
0079
0079
0079
0079
0080
0080
0080
0080
0081.
0081
0081
0081
0082
0082
0082
0082
0083
ooaa
0083
0083
0084
0084
0084
0084
0085
0085
0085
0085
0086
0086
LINE
608tf.
0086
0087
£087
0087
0087
ooaa
• LOC
0342
0344
0347
034A
034C
034F
0350
0352
0353
03SS
0355
0355
0357
0358
035A
035C
03SD
035D
035D
035D
035D
035D
035E
035F
0360
0361
0362
0363
0364
0365
0366.
0367
0368
0369.
O36A
036B
036C
036D
036E
036EL
0370
0371
0372
0373
0374
0373
0376
0377
0378
0379
037A
037B
037C
037D
037E
• LOC
A37E
0380
0381
0382
0383
0384
43BS
A9
8D
8D
A2
20
CA
DO
4C
CODE
00
OB fkO
OB AC
20
55 03
FA
0? 03
A9 FF
38
E9 01
DO FB
60
13
02
76
01
CD
02
01
CD
02
76
01
CD.
02
53
01
89
02
?E
01
89
02
76
01
£2
02
53
Al
4B
02
SE
01
4B
0?
26
01
4B
02
S3
01
SYMBOL I6BLE
SYMBOL VALUE
ACR1
DIGIT
AOOB
0302
QEFDEL 0020
riCH
T2LH
A005
AC07
CODE
ACR2
NOEND
.on.
T1LH
T2LL
LINE
OFF
(THIS
DELAY
UAIT
1
»THIS
LDA MOO
STA ACR1 fTURN B01H TIMERS OFF
STA ACR2
LDX «OFFOEL *CET TONES-OFF DELAY CONSTANT
JSR DELAY »DELAY UHILE TONE IS OFF
DEX
BNE OFF
My DIGIT IGO BACK FOR NEXT DIGIT OF PHONE NU
IS A SIMPLE DELAY ROUTINE FOR THE TONE ON AND OFK PE
LDA «DELCON IGET DELAY CONSTANT
SEC 1DELAY FOR THAT LONG
SBC ♦»01
BNE UAIT
RTS
IS A TABLE OF THE CONSTANTS FOR THE TONE FREQUENCIES
IFOR EACH TELEPHONE DIGIT. THE CONSTANTS ARE TWO BYTES
ILONGf
1
TABLE
LINE
ACOB
030A
C3SC
A007
AC04
LOU BYTE FIRST.
«BYIE 413**02.*76»*01 1 TWO TONES FOR '0'
.BYTE «CDt*02f*9E»*01 »TUO TONES FOR '1'
.BYTE »CD»»02>»76»«01 » '2'
.BYTE l£JDttQ2jA53«t01 I '3'
.BYTE *89»»02ft9E»«01 » '4'
.BYTE «89t*02»*76f*01 I '5'
»£YTE-tfl9i»Q2»»53»A01 1 'A'
.BYTE *4Br*02>«9Ef«01 t '7'
.BYTE *4Bf«02r\$76>«01 f '8'
.BYTE »4B>»02»«53f*01 1 '9'
•END
DELAY 03f7 DELCON OOFF
NUMPTR OOlO OFF 034C
£NDEL 0040 BHQHl 020Q
TILL A004 T2CH *C05
TABLE 035D UAIT 0357
END OF ASSEMBLY
Fig. 1O-6: Assembler Output: An Example
359
PROGRAMMING THE 6502
Symbols
Symbols are used to represent numerical values, either data or
addresses. Traditionally, symbols may include 6 characters, the
first one being alphabetical. One more restriction exists: the 56
opcodes utilized by the 6502 and the names of the registers
i.e., A, X, Y, S, P may not be used as symbols.
Assigning a Value to a Symbol
Labels are special symbols whose values need not be defined
by the programmer. They will automatically correspond to the
line number where they appear. However, other symbols used
for constants or memory addresses must be defined by the
programmer prior to their use. The equal sign is used for that
purpose, or else a special "directive." It is an instruction to the
assembler which will not be translated into an executable state
ment; it is called an assembler directive.
As an example, the constant ALPHA will be defined as:
ALPHA = \$A000
This assigns the value "A000" hexadecimal to variable
ALPHA. The assembler directives will be examined in a later
section.
Constants or Literals
Constants are traditionally expressed in either decimal, hexadecimal,
octal or binary. Except in the case of a decimal number, a prefix
is used to differentiate between a constant and the base used to re
present a number. To load 18 into the accumulator we will simply write:
LDA #18 (where # denotes a literal)
A hexadecimal number will be preceded by the symbol \$.
An octal symbol will be preceded by the symbol @
A binary symbol will be preceded by \%.
For example, to load the value "11111111" into the ac
cumulator, we will write:
Literal ASCII characters may also be used in a literal field. In
older assemblers, it was traditional to enclose the ASCII symbol
360
PROGRAM DEVELOPMENT
in quotes. In more recent assemblers, in order to have fewer charac
ters to type in, the alphanumeric type is indicated by a single
quote that precedes the symbol.
For example, to load the symbol "S" in the accumulator (in
ASCII) we will write:
LDA #'S
In order to be able to load the quote symbol itself, the conven
tion is:
LDA #"'
Exercise 10.1: Will the following two instructions load the same
value in the accumulator: LDA #'5 and LDA #\$5?
Operators
In order to further facilitate the writing of symbolic programs,
assemblers allow the use of operators. At a minimum they should
allow plus and minus so that one can specify, for example:
LDA ADR1, and
LDXADR1 + 1
It is important to understand that the expression ADR1 +1 will be
computed by the assembler in order to determine what is the
actual memory address which must be inserted as the binary
equivalent. It will be computed at assembly-time, not at program
execution time.
In addition, more operators may be available, such as multiply
and divide, a convenience when accessing tables in memory. More
specialized operators may also be available, such as, greater
than and less than, which truncate a 2-byte value respectively
into its high and low byte.
Naturally, an expression must evaluate to a positive value.
Negative numbers are not usually used and should be expressed in a
hexadecimal format.
Finally, a special symbol is traditionally used to represent the
current value of the address of the line:*. This symbol should be
interpreted as "current location" (value of PC).
Exercise 10.2: What is the difference between the following in
structions?
LDA\%10101010
LDA #\% 10101010
361
PROGRAMMING THE 6502
Exercise 10.3: What is the effect of the following instruction?
BMI * -2?
Assembler Directives
Directives are special orders given by the programmer to the
assembler. Some of these orders result in the storage of values in
symbols or in the memory. Others are used to control the execution
or printing modes of the assembler.
To provide a specific example, let us review here the nine as
sembler directives available on the Rockwell Development Sys
tem ("System 65"). They are: =, .BYT, .WOR, .GBY, .PAGE,
.SKIP, .OPT, .FILE and .END.
Equate Directive
An equal sign is used to assign a numeric value to a symbol. For
example:
BASE = \$1111
* = \$1234
The effect of the first directive is to assign the value 1111
hexadecimal to BASE.
The effect of the second instruction is to force the line address to
the hexadecimal value "1234." In other words, the next execut
able instruction encountered will be stored at memory location
1234.
Exercise 10.4: Write a directive which will cause the program to
reside at memory location 0 and up.
Directives to Initialize Memory
Three directives are available for this purpose: .BYT, .WOR, .GBY.
.BYT will assign the characters or values that follow in con
secutive memory bytes.
Example: RESERV .BYT 'SYBEX/
This will result in storing the letters "SYBEX" in consecutive
memory locations.
.WOR is used to store 2-byte addresses in the memory, low byte
first.
Example: .WOR \$1234, \$2345
.GBY is identical to .WOR, except that it will store a 16-bit
362
PROGRAM DEVELOPMENT
value, high byte first. It is normally used for 16-bit data rather
than 16-bit addresses.
The next three directives are used to control the input/output:
Input/Output Directives
The input/output directives are: .PAGE, .SKIP, .OPT.
PAGE causes the assembler to finish the page, i.e., move to the
top of the next page. In addition a title may be specified for the
page. For example: .PAGE "page title."
SKIP is used to insert blank lines in the listing. The number of
lines to be skipped may be specified. For example: .SKIP 3.
OPT specifies four options: list, generate, errors, symbol. List
will generate a list. Generate is used to print object code for
strings with the .BYT directive. Error specifies whether error
diagnostics should be printed. Symbol specifies whether the sym
bol table should be listed.
The last two directives control the assembler listing format:
.FILE and .END Directives
In the development of a large program, several portions of the
program will typically be written and debugged separately. At
some point it will be necessary to assemble these files together.
The last statement of the first file will then include the directive
.FILE NAME/1, where 1 is the number of the disk unit, and
NAME is the name of the next file. The next file may be linked, in
turn, to more files. At the end of the last file, there will be the
directive: .END NAME/1, which is a pointer back to the first one.
Finally, a facility exists for inserting additional comments with
the listing: ";"
";" may be used to enter comments at will within a line rather
than enter an instruction. This is an important facility if pro
grams are to be correctly documented.
MACROS
A macro facility is currently not available on most existing
6502 assemblers. However, we will define a macro here and
explain its benefits. It is hoped that a macro facility will
363
Fig. 1O-7: AIM65 is a Board with Mini-Printer and Full Keyboard
Fig. 1O-8: Ohio Scientific is a Personal Microcomputer
364
PROGRAM DEVELOPMENT
soon be available on most 6502 assemblers.
A macro is simply a name assigned to a group of instructions.
It is essentially a convenience to the programmer. For exam
ple, if a group of five instructions is used several times in a pro
gram, we could define a macro instead of always haying to write
these'five instructions. As an example, we could write:
SAVREG MACRO PHA
TXA
PHA
TYA
PHA
ENDM
Thereafter, we could write the name SAVREG instead of the above
instructions.
Any time that we write SAVREG, the five corresponding lines
will get substituted instead of the name. An assembler equipped
with a macro facility is called a macro assembler. When the
macro assembler encounters SAVREG, it will perform a mere
physical substitution of the equivalent lines.
Macro or Subroutine?
At this point, a macro may seem to operate in a way analogous
to a subroutine. This is not the case. When the assembler is used
to produce the object code, any time that a macro name is encoun
tered, it will be replaced by the actual instructions that it stands
for. At execution time, the group of instructions will appear as
many times as the name of the macro did.
By contrast, a subroutine is defined only once, and then it can
be used repeatedly: the program will jump to the subroutine ad
dress. A macro is called an assembly-time facility. A subroutine is
an execution-time facility. Their operation is quite different.
Macro Parameters
Each macro may be equipped with a number of parameters. As
an example, let us consider the following macro:
SWAP MACRO M, N, T
LDA M
STA T
LDA N
STA M
365
PROGRAMMING THE 6502
LDA T
STA N
ENDM
This macro will result in swapping (exchanging) the contents of
memory locations M and N. A swap between two registers, or two
memory locations, is an operation which is not provided by the
6502. A macro may be used to implement it. "TV in this instance,
is simply the name for a temporary storage location required by
the program. As an example, let us swap the contents of memory
locations ALPHA and BETA. The instruction which does this ap
pears below:
SWAP ALPHA, BETA, TEMP
In this instruction, TEMP is the name of some temporary storage
location which we know to be available and which can be used by
the macro. The resulting expansion of the macro appears below:
LDA ALPHA
STA TEMP
LDA BETA
STA ALPHA
LDA TEMP
STA BETA
The value of a macro should now be apparent: it is a tremendous
convenience for the programmer to be able to use pseudo-instructions
which have been defined with macros. In this way, the apparent
instruction set of the 6502 can be expanded at will. Unfortunately,
one must bear in mind that each macro directive will expand into what
ever number of instructions were used. A macro will, therefore, run
more slowly than any single instruction. Because of its conven
ience for the development of any long program, a macro facility
is highly desirable for such an application.
Additional Macro Facilities
Many other directives and syntactic facilities may be added to a
simple macro facility. For instance, macros may be nested, i.e., a
macro-call may appear within a macro definition. Using this facility,
a macro may modify itself with a nested definition! A first call will
produce one expansion, whereas subsequent calls will produce a
modified expansion of the same macro.
366
PROGRAM DEVELOPMENT
CONDITIONAL ASSEMBLY
Conditional assembly is another assembler facility which is
so far lacking on most 6502 assemblers. A conditional assem
bler facility allows the programmer to use the special instructions
"IF," followed by an expression, then (optionally) "ELSE," and
terminated by "ENDIF." Whenever the expression following the IF
is true, then the instructions between the IF and the ELSE, or the IF
and the ENDIF (if there is no ELSE), will be assembled. In the case
in which IF followed by ELSE is used, either one of the twc blocks of
instructions will be assembled, depending on the value of the ex
pression being tested.
With a conditional assembler facility, the programmer can de
vise programs for a variety of cases, and then conditionally assem
ble the segments of codes required by a specific application. As
an example, an industrial user might design programs to take
care of any number of traffic lights at an intersection for a vari
ety of control algorithms. He/she will then receive the specifications
from the local traffic engineer, who specifies how many traffic
lights there should be, and which algorithms should be used. The
programmer will then simply set parameters in his/her program, and
assemble conditionally. The conditional assembly will result in a
"customized" program which will retain only those routines
which are necessary for the solution to the problem.
Conditional assembly is, therefore, of specific value to indus
trial program generation in an environment where many options
exist and where the programmer wishes to assemble portions of
programs quickly and automatically in response to external para
meters.
SUMMARY
This chapter has presented an explanation of the techniques and the
hardware and software tools required to develop a program, along with
the various trade-offs and alternatives.
These range at the hardware level from the single-board micro
computer to the full development system. At the software level
they range from binary coding to high-level programming. You
will have to select from these tools and techniques in accordance
with your goals and budget.
367
CHAPTER 11
CONCLUSION
We have now covered all important aspects of programming,
including the definitions and basic concepts, the internal manipula
tions of the 6502 registers, the management of input/output devices,
and the characteristics of software development aids. What is the
next step? Two views can be offered, the first one relating to the de
velopment of technology, the second one relating to the development
of your own knowledge and skill. Let us address these two points.
TECHNOLOGICAL DEVELOPMENT
The progress of integration in MOS technology makes it pos
sible to implement more and more complex chips. The cost of im
plementing the processor function itself is constantly decreasing.
The result is that many of the input/output chips, as well as the
peripheral-controller chips, used in a system, now incorporate a
simple processor. This means that most LSI chips now used in the
system are becoming programmable. An interesting conceptual
dilemma is thus developing. In order to simplify the software de
sign task as well as to reduce the component count, the new I/O
chips now incorporate sophisticated programmable capabilities:
many programmed algorithms are now integrated within the
chip. However, as a result, the development of programs is com
plicated by the fact that all these input/output chips are very
different and need to be studied in detail by the programmer!
Programming the system is no longer programming the micro-
368
Fig. 11-1: PET is an Integrated Unit
Fig. 11-2: APPLE II uses a conventional TV
PROGRAMMING THE 6502
processor alone, but also programming all the various other chips
attached to it The learning time for every chip can be significant.
Naturally, this is only an apparent dilemma. If these chips were
not available, the complexity of the interface to be realized, as
well as the corresponding programs, would be still greater. The
new complexity that is introduced is that one has to program
more than just a processor, and learn the various features of the
different chips in a system to make effective use of them. How
ever, it is hoped that the techniques and concepts presented in
this book should make this a reasonably easy task.
THE NEXT STEP
You have now learned the basic techniques required in order to
program simple applications on paper. This was the goal of this
book. The next step is to actually practice. There is no substitute
for it. It is impossible to learn programming completely on paper,
and experience is required. You should now be in a position to
start writing your own programs. It is hoped that this journey
will be a pleasant one.
For those who feel they would benefit from the guidance of addi
tional books, the companion volume to this one in the series is the
"6502 Applications Book" (ref D302), which presents a range of
actual applications which can be executed on a real microcompu
ter. Next is the "6502 Games Book" (ref G402), which presents program
ming techniques for complex algorithms. A 6502 assembler, writ
ten in standard Microsoft BASIC is also available.
370
APPENDIX
APPENDIX A
HEXADECIMAL CONVERSION TABLE
HEX
0
1
2
3
4
5
6
7
8
9
A
B
C
D
E
F
0
0
16
32
48
64
80
96
112
128
144
160
176
192
208
224
240
1
1
17
33
49
65
81
97
113
129
145
161
177
193
209
225
241
2
2
18
34
50
66
82
98
114
130
146
162
178
194
210
226
3
3
19
35
51
67
83
99
115
131
147
163
179
195
211
227
242 243
4
4
20
36
52
68
84
100
116
132
148
164
180
196
212
228
244
5.
5
21
37
53
69
85
101
117
133
149
165
181
197
213
229
245
6.
6
22
38
54
70
86
102
118
134
150
166
182
198
214
230
246
7
7
23
39
55
71
87
103
119
135
151
167
183
9
8
24
40
56
72
88
104
120
136
152
168
184
199 200
215
231
247
216
9
9
25
41
57
73
89
105
•T21
137
153
169
185
201
217
232 233
248 249
A.
10
26
42
58
74
90
106
122
138
154
170
186
202
218
234
250
B
11
27
43
59
75
91
107
123
139
155
171
187
203
219
g
12
28
44
60
76
92
108
124
140
156
172
188
204
220
235 236
251 252
p
13
29
45
61
77
93
109
125
141
157
173
189
205
221
237
253
E,
14
30
46
62
78
94
110
126
142
158
174
190
206
222
238
254
F
15
31
47
63
79
95
111
127
143
159
175
191
207
223
239
255
00
0
256
512
768
1024
1280
1536
1792
2048
2304
2560
2816
3072
•3328
3584
3840
000
0
4096
8192
12288
16384
20480
24576
28672
32768
36864
40960
45056
49152
53248
57344
61440
HEX
0
1
2
3
4
5
6
7
8
9
A
B
C
D
E
F
5
| DEC
0
1,048,576
2,097,152
3,145,728
4,194,304
5,242,880
6,291,456
7,340,032
8,388,608
9,437,184
10,485,760
11,534,336
12,582,912
13,631,488
14,680,064
15,728,640
HEX
0
1
4
5
6
7
8
9
A
B
C
D
E
F
4
| DEC
0
65,536
131,072
196,608
262,144
327,680
393.216
458,752
524,288
589,824
655,360
720,896
786,432
851,968
917,504
983,040
HEx|
0
1
4
5
6
7
8
9
A
B
C
D
E
F
3
DEC
0
4,096
8,192
12,288
16,384
20,480
24,576
28,672
32,768
36,864
40,960
45,056
49,152
53,248
57,344
61,440
HEX
0
1
4
5
6
7
8
9
A
B
C
D
E
F
2
| DEC
0
256
512
768
1,024
1,280
1,536
1,792
2,048
2,304
2,560
2,816
3,072
3,328
3,584
3,840
HExl
0
1
4
5
6
7
8
9
A
B
C
D
E
F
1
DEC
0
16
32
48
64
80
96
112
128
144
160
176
192
208
224
240
HEX
0
1
4
5
6
7
8
9
A
B
C
D
E
F
0
DEC
0
1
4
5
6
7
8
9
10
11
14
15
371
PROGRAMMING THE 6502
APPENDIX B
6502 INSTRUCTIONS-ALPHABETIC
ADC
AND
ASL
BCC
BCS
BEQ
BIT
BMI
BNE
BPL
BRK
BVC
BVS
CLC
CLD
CLI
CLV
CMP
CPX
CPY
DEC
DEX
DEY
EOR
INC
INX
INY
JMP
Add with carry
Logical AND
Arithmetic shift left
Branch if carry clear
Branch if carry set
Branch if result = 0
Test bit
Branch if minus
Branch if not equal to 0
Branch if plus
Break
Branch if overflow clear
Branch if overflow set
Clear carry
Clear decimal flag
Clear interrupt disable
Clear overflow
Compare to accumulator
Compare to X
Compare to Y
Decrement memory
Decrement X
Decrement Y
Exclusive OR
Increment memory
Increment X
Increment Y
Jump
JSR
LDA
LDX
LDY
LSR
NOP
ORA
PHA
PHP
PLA
PLP
ROL
ROR
RTI
RTS
SBC
SEC
SED
SEI
STA
STX
STY
TAX
TAY
TSX
TXA
TXS
TYA
Jump to subroutine
Load accumulator
LoadX
Load Y
Logical shift right
No operation
Logical OR
Push A
Push P status
Pull A
Pull P status
Rotate left
Rotate right
Return from interrupt
Return from subroutine
Subtract with carry
Set carry
Set decimal
Set interrupt disable
Store accumulator
Store X
Store Y
TVansfer A to X
TVansfer A to Y
Transfer SP to X
Transfer X to A
Transfer X to SP
TVansfer Y to A
372
APPENDIX
APPENDIX C
BINARY LISTING OF 6502 INSTRUCTIONS
ADC
AND
ASL
BCC
BCS
BEQ
BIT
BMI
BNE
BPL
BRK
BVC
BVS
CLC
CLD
CLI
CLV
CMP
CPX
CPY
DEC
DEX
DEY
EOR
INC
INX
INY
JMP
OllbbbOl
OOlbbbOl
OOObbblO
10010000
10110000
11110000
OOlOblOO
00110000
11010000
00010000
00000000
01010000
01110000
00011000
11011000
01011000
10111000
HObbbOl
HlObbOO
HOObbOO
HObbllO
11001010
10001000
HObbbOl
lllbbllO
11101000
11001000
OlbOHOO
JSR
LDA
LDX
LDY
LSR
NOP
ORA
PHA
PHP
PLA
PLP
ROL
ROR
RTI
RTS
SBC
SEC
SED
SEI
STA,
STX
STY
TAX
TAY
TSX
TXA
TXS
TYA
00100000
lOlbbbOl
lOlbbblO
lOlbbbOO
OlObbblO
OlbbbllO
OOObbbOl
01001000
00001000
01101000
00101000
OOlbbblO
OllbbblO
01000000
01100000
lllbbbOl
00111000
11111000
01111000
lOObbbOl
lOObbllO
lOObblOO
10101010
10101000
10111010
10001010
10011010
10011000
373
PROGRAMMING THE 6502
APPENDIX D
6502-INSTRUCTION SET: HEX AND TIMING
n = number of cycles # = number of bytes
MNEMONIC
ADC
AND
A S L
B C C
B C S
B E Q
B 1 T
B M 1
B N E
B P I
BRK
B V C
B V S
C L C
C L D
C L 1
C L V
C MP
C P X
C P Y
D E C
D E X
D £ Y
E O R
I.NC
(1)
(!)
(2)
(2)
U)
(2)
a)
w
(2)
(2)
(1)
IMPLIED
OP
00
18
D8
58
B8
CA
88
7
2
2
2
2
2
2
U
1
1
1
1
1
1
ACCUM.
OP
OA 2 1
ABSOLUTE
OP
6D
2D
OE
2C
CD
EC
CC
CE
4D
EE
4
4
6
4
4
4
6
4
6
n
3
3
3
3
3
3
3
3
3
ZERO PAGE
OP
65
25
06
24
C5
E4
C6
45
E6
3
3
5
3
3
3
5
3
5
•
2
2
2
2
2
2
2
2
2
2
IMMEDIATE
OP
69
29
C9
EO
CO
49
2
2
2
2
2
2
2
2
2
2
2
2
ABS. X
OP
7D
3D
IE
OD
DE
5D
FE
4
4
7
4
7
4
7
#
3
3
3
3
3
3
3
ABS. Y
OP
79
39
09
59
n
4
4
4
4
tt
3
3
3
3
1 N Y
J M P
J S R
L D A
L D X
L D Y
L S R
NO P
O R A
P H A
PHP
P L A
P L P
R O L
R OR
R T 1
R T S
SBC
S E C
S E D
. S E 1
S T A
S T X
STY
TAX
T A Y
T S X
T X A
T X S
T Y A
(1)
(1)
(1)
(1)
IT
C8
EA
48
08
68
28
40
60
38
F8
78
AA
A8
BA
8A
9A
98
—
2
2
3
3
4
4
6
6
2
2
2
2
2
2
2
2
2
4A
2A
6A
2
2
1
1
1
4C
20
AD
AE
AC
4E
0D
2E
6E
ED
8D
8E
8C
3
6
4
4
4
6
4
6
6
4
4
4
4
3
3
3
3
3
3
3
3
3
3
45
A6
A4
46
05
26
66
E5
85
86
B4
3
3
3
5
3
5
5
3
2
2
2
2
2
2
2
2
2
2
2
A9
A2
A0
09
E9
2
2
2
2
2
2
2
2
2
2
BD
BC
5E
ID
3E
FD
90
4
4
7
4
7
7
4
5
1
3
3
3
3
3
3
3
R9
BE
19
F9
99
4
4
4
A
5
3
3
3
3
3
(i) Add ? fo n if crossing page boundary
374
APPENDIX
(IND. X)
OP
61
21
Cl
41
n
6
6
6
0
2
2
2
(IND)Y
OP
71
D1
51
n
5
5
5
0
2
2
Z. PAGE. X
OP
75
35
16
D5
D6
55
F6
n
4
4
6
4
«6
4
6
#
2
2
2
2
RELATIVE
OP
90
BO
FO
30
DO
10
50
70
n
2
2
2
2
2
2
*
2
2
2
2
2
2
2
2
INDIRECT
OP n #
Z. PAGE. Y
OP 0
PROCESSOR
STATUS CODES
N V B D 1 Z C
:
Mr* .
0
0
0
0
MNEMONIC
ADC
AND
A S L
B C C
BC S
B E Q
B 1 T
B M 1
B N E
B P L
B R K
B VC
B VS
C LC
C L D
C I 1
C L V
C MP
CPX
CPY
DEC
DEX
DE Y
EOR
" NC
01
El
6
6
?
2
11
F1
S
5
?
2
2
B5
B4
56
15
3r»
ft
F5
95
94
4
4
6
4
6
6
4
4
4
2
2
2
2
7
7
2
2
2
6C 5 3
B6
96
4
4
2
2
• •
• •
• •
• •
• •
0 ••
• •
• •
••••••••
• ••
• • •
• • • •
1
1
1
• •
• •
• •
• •
• •
i N X
1 N Y
J M P
J S R
L DA
1 D X
1 D Y
L S R
NO P
OR A
P H A
PHP
PL A
PL P
ROl
R OR
R T 1
RT S
SBC
S E C
SED
S E 1
S T A
ST X
ST Y
TAX
T A Y
TSX
T X A
T X S
T Y A
*2> Add 1 to n if branch within page
Add 2 to n if branch to another page
375
PROGRAMMING THE 6502
APPENDIX E
ASCII CONVERSION TABLE
CODE
00
01
02
03
04
05
06
07
08
09
0A
0B
OC
0D
Ofif
OF
10
11
12
13
14
15
16
17
18
19
1A
IB
1C
ID
IE
IF
CHAR
NUL
SOH
STX
ETX
EOT
ENQ
ACK
BEL
BS
TAB
LF
VT
FF
CR
SO
SI
DLE
DC1
DC2
DC3
DC4
NAK
SYN
ETB
CAN
EM
SUB
ESC
FS
GS
RS
US
CODE
201
21
22
23
24
25
26
27a
28
29
2A
2B
2C3
2D
2E
2F
30
31
32
33
34
35
36
37
38
39
3A
3B
3C
3D
3E
3F
CHAR
!
"
H
\$
\%
&
'
(
)
*
+
-
/
0
1
2
3
4
5
6
7
8
9
;
<
=
>
CODE
40
41
42
43
44
45
46
47
48
49
4A
4B
4C
4D
4E
4F
50
51
52
53
54
55
56
57
58
59
5A
5B
5C
5D
5E
5F4
CHAR
@
A
B
C
D
E
F
G
H
1
J
K
L
M
N
O
P
Q
R
S
T
U
V
W
X
Y
Z
t
\
]
<-
CODE
605
61
62
63
64
65
66
67
68
69
6A
6B
6C
6D
6E
6F
70
71
72
73
74
75
76
77
78
79
7A
7B
7C
7D6
7E
7F
CHAR
a
b
c
d
e
f
g
h
i
i
k
1
m
n
o
P
q
r
s
t
u
V
w
X
y
z
{
1
}
RUBOUT
'space
'single quote
'comma
4or underline
'accent mark
6or ALT MODE
7or DEL
376
APPENDIX
APPENDIX F
RELATIVE BRANCH TABLES
FORWARD RELATIVE BRANCH
NASD
0
1
2
3
4
5
6
7
0
0
16
32
48
64
80
96
112
1
1
17
33
49
65
81
97
113
2
34
50
66
82
98
114
3
3
19
35
51
67
83
99
115
4
4
20
36
52
68
84
100
116
5
5
21
37
53
69
85
101
117
6
6
22
38
54
70
86
102
118
7
7
23
39
55
71
87
103
119
8
8
24
40
56
72
88
104
120
9
9
25
41
57
73
89
105
121
A
10
26
42
58
74
90
106
122
B
11
27
43
59
75
91
107
123
C
12
28
44
60
76
92
108
124
D
13
29
45
61
77
93
109
125
E
14
30
46
62
78
94
110
126
F
15
31
47
63
79
95
111
127
BACKWARD RELATIVE BRANCH TABLE
N^LSD
nvsdN,
8
9
A
B
C
D
E
F
0
128
112
96
80
64
48
32
16
1
127
111
95
79
63
47
31
15
2
126
110
94
78
62
46
30
14
3
125
109
93
77
61
45
29
13
4
124
108
92
76
60
44
28
12
5
123
107
91
75
59
43
27
11
6
122
106
90
74
58
42
26
10
7
121
105
89
73
57
41
25
9
8
120
104
88
72
56
40
24
8
9
119
103
87
71
55
39
23
7
A
118
102
86
70
54
38
22
6
B
117
101
85
69
53
37
21
5
C
116
100
84
68
52
36
20
4
D
115
99
83
67
51
35
19
3
E
114
98
82
66
50
34
F
113
97
81
65
49
33
17
1
377
PROGRAAAMING THE 6502
APPENDIX G:
HEX OPCODE LISTING
Sasd
MSD\,
0
1
)
0
BRK
BPl
JSR
BMI
RTI
BVC
RTS
BVS
BCC
IDY-IMM
BCS
CPYIMM
BNE
CPX-IMM
BEO
1
ORA-I.
ORAI.
AND-I.
ANDI.
EORI.
EORI,
ADCI.
ADCI.
STA-I.
STA.I.
IDAI.
IDA-I.
CMP-I,
CMP-I.
SBC-I.
SBC-I. Y
2
LDXIMM
3 4
BIT.0P
STY-0P
STY-0P. X
IOY0-P
IDY0-P. X
CPY0P
CPX-0-P
5
ORA0-P
ORA-0P. X
AND-0P
AND0P. X
EOR-0P
EOR-0P. X
ADC-0-P
AOC-0P. X
STA-0-P
STA-0P. X
IDA-0.P
IDA-0P. X
CMP-0-P
CMP-0-P. X
SBC-0P
SBC-0P. X
6
ASI-0-P
ASI-0-P. X
ROI-0-P
ROL-0P. X
LSR-0-P
LSR-0-P, X
ROR-0P
STX.0P
STX.0P. Y
IOX-0P
IDX-0P. Y
DEC-0P
DEC-0-P, X
INC-0-P
INC-0-P. X
7
8
PHP
CLC
PIP
SEC
PHA
CLI
PIA
SEI
MY
TYA
TAY
CLV
INY
CLD
INX
SED
9
ORA-IMM
ORA.Y
AND-IAAAA
AND. Y
EOR-IMAA
EOR. Y
ADC-IMM
AOC.Y
STA.Y
LDA-IAAM
IDA.Y
CMP-IMM
CAAP, Y
SBC-IMM
SBC, Y
A
ASLA
ROL-A
LSRA
ROR-A
TXA
TXS
TAX
TSX
DEX
NOP
B C
BIT
JMP
JMP-I
STY
IDY
LDY, X
CPY
CPX
D
ORA
ORA, X
AND
AND. X
EOR
EOR. X
ADC
ADC.X
STA
STA.X
IDA
IDA.X
CMP
CMP, X
SBC
SBC. X
E
ASl
ASl.X
ROL
ROL.X
LSR
LSR.X
ROR
STX
LDX
LDX, Y
DEC
DEC.X
INC
INC. X
F
0
1
2
3
4
5
6
7
8
9
A
B
c
D
E
F
I = indirect
fP = zeropage
378
APPENDIX
APPENDIX H:
DECIMAL TO BCD CONVERSION
DECIMAL
0
1
2
3
4
5
6
7
8
9
BCD
0000
0001
0010
0011
0100
0101
0110
0111
1000
1001
DEC
10
11
12
13
14
15
16
17
18
19
BCD
00010000
00010001
00010010
00010011
00010100
00010101
00010110
00010111
00011000
00011001
DEC
90
91
92
93
94
95
96
97
98
99
BCD
10010000
10010001
10010010
10010011
10010100
10010101
10010110
10010111
10011000
10011001
379
PROGRAMMING THE 6502
APPENDIX I
EXERCISE ANSWERS
CHAPTER 1
1.1: 252
1.2: 100000001
1.3: 19 + 2 = 9 remainder 1 -► 1
9 + 2 = 4 remainder 1 -♦ 1
4 + 2 = 2 remainder 0 -♦ 0
2 + 2 = 1 remainder 0 -* 0
1+2 = 0 remainder 1 -*■ 1
Answer: 10011
1x1=1
1x2=2
0x4=0
Ox 8=0
+ 1 x 16 = 16
Answer:
1.4: 0101 =
+ 1010 =
1111 =
1 x 1
1 x2
1 x4
+ 1x8
19
= 5
= 10
= 15
= 1
= 2
= 4
= 8
Answer: 15
380
APPENDIX
1.5: 1111
+ 0001
(1)0000
Answer: No, the result does not hold in 4 bits.
1.6: +5 = 00000101
-5 = 10000101
1.7: +6 = 00000110
-6= 11111001
1.8: +127 = 01111111
1.9: + 128 = 10000000
01111111 (one's complement)
+ 1
-128 = 10000000 (two's complement)
1.10: Smallest: -128
Largest: +127
1.11: +20 = 00010100
11101011 (one's complement)
+ 1
-20= 11101100 (two's complement)
00010011 (one's complement)
+ 1
20 = 00010100
Answer: Yes
1.12: 10111111
+ 11000001
10000000
V:0 C:l
IE CORRECT
381
PROGRAMMING THE 6502
11111010
+ 11111001
11110011
V:0 C:l
SI CORRECT
00010000
+ 01000000
01010000
V:0 C:0
SI CORRECT
01111110
+ 00101010
10101000
V:l C:0
SI ERROR
1.13: No, you cannot generate an overflow when adding a positive and a
negative number, because they will tend to cancel each other; thus,
the result will always be within range of 1 byte.
1.14: Largest: 32767
Smallest: -32768
1.15: -8388608
1.16: 29 = 00101001
91 = 10010001
1.17: 10100000 is not a valid BCD representation, because the high order
nibble is 1010, which is unused.
5 - 2 3 1 2 3
1.18: -23123 =
= 00000101 00010010 00110001 00100011
382
APPENDIX
1.19: 222 =
111 =
222 X 111 = 24642
24642 =
3
3
+
+
2
1
2
1
2
1
5 + 2 4 6 4 2
1.20: 9999 in BCD: 24 bits (3 bytes):
4 + 9 9 9 9
9999 in two's complement: 14 bits (~ 2 bytes)
1.21: 223 - 1 = 8388607. This is 6 digits of absolute accuracy, or 6+
digits.
1.22: 0 = 00110000
1 = 10110001
2 = 10110010
3 = 00110011
4= 10110100
5 = 00110101
6 = 00110110
7 = 10110111
8 = 10111000
9 = 00111001
1.23: A = 01000001
B = 01000010
C = 11000011
D = 01000100
E = 11000101
F = 11000110
1.24: "A" =01000001
"T" = 01010100
"S" =01010011
"X" =01011000
1.25: 10101010 = AA (hexadecimal)
383
PROGRAMMING THE 6502
1.26: FA = 11111010
1.27: 01000001 = 101 (octal)
1.28: Negative numbers represented in two's complement produce
results that do not need to be corrected when added.
1.29: 1024= 10000000000 (direct binary)
= 01000000000 (signed binary)
= 01000000000 (two's complement)
1.30: The overflow (V) flag is set when the carry out of bit 6 does not
equal the carry out of bit 7 (exclusive OR). It should be tested after
any addition or subtraction involving numbers represented in two's
complement notation.
1
1
.31:
.32:
+
+
+
—
—
—
M
E
S
S
A
G
E
16
17
18
16
17
18
=
=
=
=
CHAPTERS
3.1:
= 010000
= 010001
= 010010
= 110000
= 101111
= 101110
4D
45
53
53
41
47
45
Left to reader.
384
APPENDIX
3.2: CLC
CLD
LDA
ADC
STA
LDA
ADC
STA
3.3: CLC
CLD
LDA
ADC
STA
LDA
ADC
STA
3.4: CLD
SEC
LDA
SBC
STA
3.5: See text.
ADR1
ADR2
ADR3
ADR1 + 1
ADR2+1
ADR3 + 1
ADR1-1
ADR2-1
ADR3-1
ADR1
ADR2
ADR3
ADR1
ADR2
ADR3
3.6: Yes, the CLC instruction only has to be executed before the
addition.
3.7: The only difference is that here the D flag is set, not clear, which
will affect the way the final answer is computed.
3.8: SEC
SED
LDA
SBC
STA
LDA
SBC
STA
ADR1
ADR2
ADR3
ADR1 -1
ADR2-1
ADR3-1
385
PROGRAMMING THE 6502
3.9: 0100 MPD
xOlllMPR
0100
0100
0100
0000
1
2
4
8
16
32
X
X
X
X
X
X
0= 0
0= 0
1 = 4
1 = 8
1 =16
0=_0
28 V
3.10: Carry will equal 1.
3.11: When X decrements to zero, the next instruction to be executed is
'BNE MULT', but the branch will not occur.
3.12: Fill table (see text).
3.13: LDA
STA
STA
LDX
MULT LSR
BCC
LDA
CLC
ADC
STA
NOADD ROR
ROR
DEX
BNE
#0
RESAD
RESAD +
#8
MPRAD
NOADD
RESAD +
MPDAD
RESAD +
RESAD +
RESAD
MULT
1
1
1
1
CLEAR ADDRESSES
SET COUNTER
GET A MULTIPLIER BIT
TEST FOR A 1
ADD MULTIPLICAND
TO RESULT
SHIFT RESULT RIGHT
(RECOVERS CARRY)
DECREMENT COUNTER
TEST FOR ZERO
This approach is faster, because the add of the partial product to
the result is eight bits instead of sixteen.
3.14: 157 )L(sec., assuming all addresses zero page, no page crossings, and
alMHzclock.
386
APPENDIX
3.15: Left for reader.
3.16: TEST LDA
CMP
BEQ
\$24
#\$2A
STAR
3.17: A subroutine requires a fixed overhead time in which to manipu
late the stack.
3.18: In the case of both the call and the return, the same number of
values must be transferred to/from the stack in memory.
3.19: Yes. MULT modifies the X and A registers plus several flags.
3.20: A subroutine may call itself if it was designed to do so. It must
store data in the stack, though, to preserve it, as the registers will be
reused on each call. Also, there must be a conditional statement
that will limit the number of calls made; otherwise, the stack area
in memory will overflow.
3.21: Stack parameters are best for recursion. Fixed registers and mem
ory locations will be changed by each iteration of the subroutine.
The stack can accommodate a string of parameters.
CHAPTER 4
4.1: LDA WORD
AND #\%01000010
STA WORD
4.2: No effect.
4.3: The final value of the accumulator would be 10101 111.
4.4: The result would always be \$FF.
4.5: No effect.
387
PROGRAAAMING THE 6502
CHAPTERS
5.1:
NEXT
DONE
LDX
DEX
BNE
LDA
STA
JMP
#NUMBER
DONE
BASE.X
DEST.X
NEXT
OR
NEXT
LDX
DEX
LDA
STA
TXA
BNE
5.2: BLKADD LDY
NEXT
Bytes
2
1
3
3
3
1
2
CLC
LDA
ADC
STA
DEY
BPL
Cycles
2
-1
#NUMBER
BASE.X
DEST.X
NEXT
#NBR-1
PTR1.Y
PTR2.Y
PTR3.Y
NEXT
2
4
4
5
2
3,
> Repeated NBR
times
15 20XNBR+1 20 Ooop total)
388
APPENDIX
5.3:
BLKADD
NEXT
Bytes
2
1
2
2
2
1
2
> LDY
CLC
LDA
ADC
STA
DEY
BPL
Cycles
2
-1
12 23XNBR+1
ADDLP
LDA
STA
STA
LDY
CLC
LDA
ADC
STA
BCC
INC
CLC
NOCARRY DEY
BPL
RTS
#NBR-1
(LOCl).Y
(LOC2),Y
(LOC3),Y
NEXT
2
5
5
6
2
_3
23
m INITIALIZE SUM
SUMLO
SUMHI
H9 Y IS COUNTER
BASE.Y ADD
SUMLO
SUMLO
NOCARRY TRANSFER CARRY
TO NEXT BYTE
SUMHI
ADDLP
5.4: Yes. However, this method would be cumbersome, requiring 10
additions.
389
PROGRAMMING THE 6502
5.5:
5.6:
5.7:
LOOP
Left to reader.
Left to reader.
CHAPTER6
LDX
LDY
LDA
STA
INX
DEY
BPL
RTS
#0
#9
BASE.X
REVER.Y
LOOP
INITIALIZE INDEX REGISTERS
6.1: 2 4- 5 x 255 - 1 = 1,276 jisec or 1.276 msec.
The minimum possible delay is 6 ptsec; therefore, 1 jisec delay is
not possible.
6.2: 2 + 5 x
NEXT
6.3:
NEXT
LOOP
20- 1 =
LDY
DEY
BNE
LDX
LDY
DEY
BNE
DEX
BNE
Execution time =
6.4:
WATCH
LDY
LDA
BPL
STA
INC
DEC
BNE
= 101
#20
NEXT
#\$9C
#\$7F
LOOP
NEXT
99997 /n sec or 99.997
#0
STATUS
WATCH
(POINTER),Y
POINTER
COUNT
WATCH
msec.
Cycles
2
2
2
6
5
5
3/2
(FAIL)
390
APPENDIX
The total number of cycles for the input loop, assuming that the
status is always true, is 2 + 2 + 6 + 5 + 5 + 3 = 23, or 23 \xsec with a 1
MHz clock. This implies an input rate of
1 = 43.35K bytes/sec
23 ji sec
The actual difference in rates is
\ - —\— = 12.08K bytes/sec
18jisec 23/isec
or less than 22\%.
6.5: 146/nsec/byte
-6.8K bytes/sec
6.6: Bit 7 is used for status because it can be easily tested through the sign
flag. Bit 0 is used for data because it can be easily shifted into the
carry.
6.7: Assuming status is represented in bit 7 of a memory location, the
BIT instruction would transfer it into the sign flag without affecting
the accumulator.
6.8: LDA
LOOP BIT
BPL
LSR
ROL
BCC
PHA
LDA
DEC
BNE
#\$00
INPUT
LOOP
INPUT
A
LOOP
#\$01
COUNT
LOOP
Original: 146 \jl sec/byte; 25 bytes
New version: 149 \i sec/byte; 18 bytes
6.9: START LDA #\$01
LOOP BIT INPUT
BPL LOOP
LSR INPUT
391
PROGRAMMING THE 6502
6.10:
START
LOOP
6.11:
START
LOOP
DONE
6.12: SERIAL
LOOP
ROL
BCC
PHA
DEC
BNE
LDX
LDA
BIT
BPL
LSR
ROL
BCC
STA
INX
DEC
BNE
LDX
LDA
BIT
BPL
LSR
ROL
BCC
CMP
BEQ
STA
INX
DEC
BNE
.
LDA
STA
LDA
LSR
BCC
LDA
A
LOOP
COUNT
START
#0
#\$01
INPUT
LOOP
INPUT
A
LOOP
BASE.X
COUNT
START
#0
#\$01
INPUT
LOOP
INPUT
A
LOOP
#\$53
DONE
BASE.X
COUNT
START
#\$00
WORD
INPUT+1
A
LOOP
INPUT
392
APPENDIX
6.13: CHARPR
LOOP
WAIT
6.14: CHARPR
LOOP
WAIT
DONE
LSR
ROL
BCC
LDA
PHA
LDA
STA
DEC
BNE
LDX
LDA
BIT
BPL
STA
DEX
BNE
LDX
LDA
BIT
BPL
STA
CMP
BEQ
DEX
BNE
•
6.15: Hex LED Code
0
1
2
3
4
5
6
7
8
3F
06
5B
4F
66
6D
7D
07
FF
A
WORD
LOOP
WORD
#\$01
WORD
COUNT
LOOP
#N
CHAR.X
STATUS
WAIT
PRINTD
LOOP
#N
CHAR.X
STATUS
WAIT
PRINTD
#\$0D
DONE
LOOP
Hex LED Code
9
A
B
C
D
E
F
67
77
7C
39
5E
79
71
393
PROGRAMMING THE 6502
6.16: LEDS
OUT
6.17: LEDS
STX
STY
LDX
LDY
RTS
TXA
PHA
TYA
PHA
Tl
T2
Tl
T2
OUT
6.18:
NEXT
LOOP
PLA
TAY
PLA
TAX
RTS
LDX
LDY
DEY
BNE
DEX
BNE
#\$5A
#\$13
LOOP
NEXT
Execution time: 9.09 msec
6.19: PRINTC
NEXT
LDA
STA
JSR
LDX
ROR
ROL
STA
JSR
DEX
BNE
#\$00
TTYBIT
DELAY
#\$08
CHAR
A
TTYBIT
DELAY
NEXT
OUTPUT START BIT
9.09 MSEC DELAY
BIT COUNTER
GET A BIT
INTO ACCUMULATOR
OUTPUT IT
WORD TRANSMITTED
394
6.20: TTYIN
LDA
STA
JSR
STA
JSR
RTS
LDA
LSR
BCS
ROL
STA
JSR
#\$01
TTYBIT
DELAY
TTYBIT
DELAY
TTYBIT
A
TTYIN
A
TTYBIT
DELAY
APPENDIX
YES, OUTPUT STOP BITS
TEST FOR START BIT
RECOVER BIT
OUTPUT IT
6.21: 26 \x sec lost.
6.22: 256 locations
4 locations/interrupt
= 64 interrupts
6.23: 256 locations = 42 interrupts
6 locations/interrupt
6.24: Left for reader.
6.25: a) Hardware senses the interrupt request, compares with the
mask, sets mask, and preserves regiser (P,PC). Software
unsets the mask, preserves registers (A,X,Y), identifies the
device, executes the routine, restores registers, and returns.
b) The mask inhibits unwanted interrupts.
c) All registers that are changed by the interrupt routine should
be preserved.
d) The interrupt device is usually identifed by polling if there is
more than one possiblity.
395
PROGRAMMING THE 6502
e) The RTI instruction restores processor status while the RTS
does not.
f) Inhibiting interrupts would allow those executing to finish
and withdraw their addresses from the stack.
g) The overhead is the stack manipulations and the running of
the routine itself, both of which detract from the speed of the
mainline program.
CHAPTER8
8.1:
CHECK
LOOP
NEXT
DONE
LDA
JSR
LDA
JSR
LDA
JSR
LDA
JSR
JMP
LDX
STA
DEX
BNE
CMP
BNE
DEX
BNE
RTS
m
CHECK
#\$FF
CHECK
#\$55
CHECK
#\$AA
CHECK
DONE
#0
BASE.X
LOOP
BASE.X
ERROR
NEXT
ERROR
8.2: STRING
NEXT
LDX
JSR
CMP
BEQ
#0
GETCHAR
#SPC
OUT
396
APPENDIX
OUT
JSR
STA
INX
BNE
RTS
SENDCHAR ECHO CHARACTER
BUFFER.X
NEXT IF X IS BACK TO ZERO,
RETURN
8.3:
OUT
BCC
CMP
BCS
CLC
TOOLOW
#\$BA
TOOHIGH
8.4: Left to reader.
8.5: JSR
AND
CMP
RTS
8.6: LDA
AND
STA
8.7: LDA
TAX
AND
STA
TXA
LSR
LSR
LSR
LSR
STA
ASL
PARITY
#\$80 MASK ALL BUT 7 BIT
EXPECT IS PARITY THE ONE EXPECTED?
Z FLAG HOLDS ANSWER
BCDCHAR
#\$30 SET LEFT NIBBLE TO 3
CHAR
BCDCHAR
#\$OF MASK OFF HIGH NIBBLE
BINCHAR
A
A
A
A
TEMP
A
SHIFT HIGH NIBBLE TO LOW ORDER
STOREX
X TIMES 2
397
PROGRAMMING THE 6502
ASL
ADC
ASL
ADC
STA
8.8: MAX
LOOP
SAME
A
TEMP
A
BINCHAR
BINCHAR
LDY
STY
LDA
TAY
LDA
STA
EOR
BPL
LDA
BPL
JMP
LDA
CMP
BCS
SWITCH LDA
STA
STY
NOSWITCH DEY
BNE
RTS
X TIMES 4
X TIMES 5
X TIMES 10
ADD LOW NIBBLE
STORE BINARY RESULT
#0
INDEX
(BASE),Y
#\$80 MOST NEGATIVE NUMBER
BIG
(BASE),Y COMPARE SIGN BITS
SAME
BIG IF + / - INVOLVED,
NOSWITCH CHECK IF MAX IS POSITIVE
SWITCH
BIG
(BASE),Y
NOSWITCH
(BASE),Y
BIG
INDEX
LOOP
8.9: Yes, the program will work on ASCII characters with a consistent
parity bit (always 0 or 1).
8.10: See Figure 9.49.
8.11: Left for reader.
8.12: (c)
BCC
LDA
NO CARRY
#0
398
APPENDIX
ADC
BCS
NOCARRY DEY
BNE
CLV
RTS
OVER LDA
ADC
RTS
SUMHI
OVER
ADLOOP
#\$40
#\$40
INCREMENT SUMHI
SUCH THAT CARRY
IS AFFECTED
FORCE OVERFLOW
ERROR: RETURN
8.13: (b)
ZLOOP
NOTZ
LDA
AND
CMP
BCC
CMP
BCS
INX
DEY
(ADDR),Y
#\$7F MASK OUT PARITY BIT
#\$41 'A' CHARACTER
NOTZ
#\$5B '[' CHARACTER
NOTZ
CHAPTER 9
9.1: Address Contents
15 00
16 05
9.2: FIRST
BLOCK 1
i BLOCK2 *• BLOCK 3
BLOCK
399
PROGRAMMING THE 6502
CHAPTER 10
10.1: No. LDA #'5 will load hexadecimal value 35 as a representative of
the ASCII character "5*. LDA #\$5 will load the numerical value of 5
into the accumulator.
10.2: LDA \% 10101010 loads the accumulator with the contents of the
memory location AA16. LDA #\% 10101010 loads the accumulator
with the actual value AA16.
10.3: Assuming the N flag is set, the program counter will be jumped to
the memory location where the branch instruction starts. This will
result in an infinite loop.
10.4: * = 0
400

PROGRAMMING THE 6502
INDEX
A 187
abbreviations 112
absolute 197
absolute addressing 66,190,191,195
accumulator 41,48,55,110,122,133,143,
152,165,178,182,183,185,190,263
ADC 62,113
addition 54,59,67
address 39,149,188,189,191,192,306
address bus 39,44,45,49
address field 358
addressing 188,189
addressing modes 188,200
addressing techniques 188
algorithm 7,8,69,275,318,320,340
alphabetic list 290,301,302,303,304,305
alphabetical order 269,372
alphanumeric 31
ALU ' 39,41
AND 87,104,110,115
APL 345
arithmetic 41,67,100,103,117
arithmetic logical unit 39,41
arithmetic operation 41,100
arithmetic programs 54
ASCII 31, 32,267,268, 360, 376
ASL 106,117
assembler 55,343, 345,346, 356,358,359
assembler directives 362
assembly level language 344,356,358,359
assembly time 361,365
asynchronous 216,221,228
B
BASIC
basic concepts
baud
BCC
BCD
16, 345
7
235
74,109,119
26,27,64, 65,103,268, 379
BCD addition
BCD flags
BCD mode
BCD subtraction
BCS
benchmark
BEQ
63,66
67
67,108
66
109,120
220
109,121
binary 12,13,14,33,34,35,36,37,64,
343,346,358,361,373
binary digit 10,12
binary division 86
binary mode 108
binary representation 12,33,358
binary searching 283,290,294,295,
296,299
binary tree structure 313,320
BIT 110,122
bit 10,12,33, 54,59,100,122,167,169
bit serial transfer 221,223
block 203,204,205,208,276,277,279,280
block transfer routine 203,204,205
BMI 109,123,208
BNE 77,109, 124, 207,208,264
bootstrap 40
BPL 109,125
bracket testing 265
branch 101,119,120,121,123,124,125,
127,128,191,196,264
branches
branching
branching point
break
break point
BRK
bubble sort
buffer
buffered
busses
BVC
BVS
byte
196
191
69
102,108,126,251
108,251,349
108,111,126,251
333, 334,335, 336, 337, 338
255
41
39
109.127
109.128
10,11,27,62
402
INDEX
C 43
call 101
carry 19, 21, 22,43, 57, 75,109,113,119,
120, 129,173,175,191
central processing unit
characters
checksum
chronological structure
circular list
classes of instruction
CLC
CLD
clear
CLI
clock
CLV
CMP
code conversion
coding
collision
combination chips
combinations
commands
comment field
comparisons
compiler
complement
conditional assembly
constants
control bus
control instructions
control lines
control register
control signals
control unit
counter
counting
CPU
CPX
CPY
cross assemblers
crystal
current location
D
D
39
31,265,266
270
47
280, 281
99
57,63,67,129
58,130
57,58,111,119,127,129,130,
131,132,191
131
40,45,73
132
110,133
268
8,349
321
41
194
8
55,356
106
346
14, 30, 54
367
66, 360
39
102,111
255
255, 257
51
39,45
71,214
213
39
111,135
111,137
354
40
361
58,108
data
data bus
data direction register
data processing
data structures
data transfer
data transfer rate
data units
debugger
debugging
DEC
decimal 12,13,14
decimal adjust
decimal mode
decoding logic
39,255
39,45
255,256,259
100,103
275, 284, 300
67,99,102
221
319
347
10, 347
139
., 35, 36, 58,108,
130,176, 379
64
176
41,45
decrement 100,103,139,141,142,207,214
delay
deleting
design examples
destination
development system
device handler
DEX
DEY
direct addressing
direct binary
directive
directories
disassembler
disk operating system
displacement
DMA
documenting
DOS
doubly linked lists
drivers
duration
213,214
287,301,309
284
39
352
248, 348
77,141,207
142, 207
82, 190,191
11,37
95, 360, 362
277, 306
345
347
110,189,191
239
55
347
281,282
41
217
EBCDIC
echo
editor
element deletion
element insertion
emulator
31
234,237
347
299
298
348, 350
403
PROGRAMMING THE 6502
EOR
error messages
executive
execution speed
exponent
extended addressing
external device
22, 87, 104,
42,45
105, 143
358, 363
347, 360
, 82, 348
28,29
191
39
fetch
fields
FIFO
file system
flags 22,102,
flip-flop
floating point
flow charting 8,9,
44,45,46,47
356
279
277
,106,130,132,297
42
28,29,31,100
10,69, 86, 89,214,
219,223,240,273, 288,289,291,
294,301,
front panel
G
generate a signal
H
half carry
handshaking
hardware concepts
hardware delays
hardware stack
hashing algorithm ■
hexadecimal 33.34.
315,316,317,339
33,355
212, 363
65
228,229,255,261
38, 227,239,355
216
48
J20, 321, 322,329,
330, 331, 332
,35.343.358.361.
371,374,375
hexadecimal coding 36,343,344
high level language 345
hobby type microcomputers 354
I
immediate addressing
implicit addressing
implied addressing
improved multiplication
INC
244
66,190,195
190
194
82
145,207
incircuit emulator 350, 352
inclusive OR 161
increment 100, 103, 145,147,148
indexed addressing 191, 197, 238
indexed indirect addressing 198,199,209
index registers 47,191,200,289
indirect addressing 193,194,198,276
indirect indexed addressing 192,199
indirection pointer 276
initialization 70
input/output 102,211,228,239, 363
input/output devices 39,102,211,228,
238,239,254, 263
input/output instructions 111
input ports
inserting
instruction
instruction field
instruction register
instruction set
instruction types
interface chips
internal control register
internal organization
interpreter
interrupt 48,102,108,131,171,177,216,
242,243,255
interrupt handling routine 249
interrupt levels
41
287, 298, 308, 320
11,55,112,372,373
356
45
99,374, 375
67
40
190,257
10,41,42
346
interrupt-mask
interrupt request
interrupt vector
INX
INY
IR
IRQ
iteration
JMP
JSR
jump
K
K
keyboard
KIM
251
108, 244
51
245, 248
147
148
45
51,111,244,245
201
110,149
95,110,151
95,101,149,151,200
16,49
264
261
404
INDEX
L
label field
largest element
LDA
LDX
LDY
LED
level activated
levels
LIFO
light emitting diode
line number
linked list
308,
linking loader
listing
lists 276,285,286,
literal 65
load 55,152,
loader
location
logarithmic searching
logical
logical operations
long branch
longer delays
loops
LSR
M
macros
macro parameters
main program
mantissa
masking
master directory
55
278,
309,
95,
287,
,66,
154,
41,
memory 39,44,45, 55,57,
178,180,181,218,
memory mapped I/O
memory test
merge
mnemonics
monitor
MOS Technology
MPU
multiple interrupts
multiple precision
272,
, 67, 152,
33, 230,
47, 276,
280,299,
310,311,
356
268
268
154
156
231
244
95
280
230
358
306
312
347
322, 359, 378
292, 293,
189,190,
156, 257,
283,
104,115,
41,87,
53,191,
106,
363,365,
363
360
259
347
73
290
158
100
200
215
240
158
366
365
91
28,29,31
197,122,
276,285,
102,337,
263,
339, 340,
343,
40,
38, 3<
248,
131
277
145,
314
351
319
341
358
347
261
>,40
249
59
multiplicand
multiplication
N
N
negative
nested
nested calls
next instruction
nibble
NMI
nodes
75,77,81,83
68,69, 80, 82
43,107,110
16,17,18,23,43
366
93
43,46
10, 27,100
51,111,244,245
319
non-maskable interrupt 51,244
NOP
normalize
normalized mantissa
r\
object code
octal
oneK
one's complement
one-shot
opcode
operand
operand field
operating system
operators
ORA
oscillator
overflow 20,
overhead
p
P
packed BCD
pageO
paging
111, 160
28
28
346
33,34, 35,36,360
49
17,19
216
41, 189
41,54,59,61,356
356
147
361
87,104,161
40
21,22,23 51,107,
127,128,132
247, 253
60,244
27,63
49
49,50
parallel input/output chips 40
parallel word transfer
parameters
parity
parity generation
partial product
PASCAL
218,219
365
31,32,267
267
71,72
345
405
PROGRAMMING THE 6502
PC
PCH
PCL
PHA
PHP
physical address
PIA
PIC
PIO
PIT
PLA
PLP
pointers
polling
pop
port
positional notation
positive
post indexing
power failures
precision
pre-indexing
printer
printing a string
43, 244, 361
43
43
163
164
75
256, 257, 259, 260
249
40, 254, 255,256, 258
213
165
166
97, 194, 275, 276, 278, 297
216,219,240,247,248,263
48
40, 254, 255
12
16,17, 23, 269
192
40
27
192
35,229,241,279
238
245, 246
249
40
8,40
7,8,81
priority
priority interrupt controller
process control
program
programming
program counter 43,45,47,244, 358
program development 343,348
program loop 70
programmable interval timer 213
programming alternative
programming form
programming hints
programming language
programming techniques
PROM programmer
pseudo instructions
pull
pulse counting
pulses
push
quartz
queue
81
357
67
8,345
53
354
58
48,100,165,166
216
212,213,217
48,100,163,164
40
279,280
RAM 40,41,44,
Random Access Memory
RDY
read only memory
read write memory
recursion
register 33,39,73,75,83,96,
135, 154, 156,190,
register management
regular interrupt line
relative addressing
relay
representation of information
RES
reset
restoring method
retrieval
return
Rockwell
ROL
ROM
ROR
rotate
rotation
routines
round robin
RTI
RTS
RW
90,
72,77,101,
110,171,
95,
349, 352
40
51
40, 256
40,256
96
97, 106,
247,256
53
244
191,196
212
33,35
51
256
86
280, 328
171,172
261,353
167
40,44
169
167, 169
77,100
262
280,281
245, 246
110,172
51
S 47,184,186
SBC 62,173
scheduling 239
scope 351
searching and sorting 282
search techniques 283,286,290,307
SEC 63,175
SED 67,176
SEI 177
sending a character 229
sensing pulses 216
sequencing 38,46
sequential block access 200
sequential lists 276
sequential searching 282
406
INDEX
serial search 286
set 120,128,175,176,177
shift 71,72,76,77, 100, 101, 117, 158
shift operations
short address
sign
signed binary
sign extension
simulator
simultaneous interrupts
simple list
single board microcomputer
6502
6502 peculiarities
6522
6530
6532
skew
skip
SO
software stack
software support
sort
source
STA
106
189,195, 200
107
16,17,18
100
348
249
286,290
344,352
38,194, 350, 372
57
258
257,258
261
100
102
51
48
346
269
39
67,103,178,207
stack 47,97,166,244,250,275,280
stack operations
stack overflow
standard PIO
start bit
status flags
status manipulation
status register
stop bit
store
string
STX
STY
subroutines
subroutine call
subroutine level
subroutine library
subtract
subtraction
sum of n elements
SYM
symbol
symbolic label
symbolic representation
49,103
253
254
235,236,255
42
67
244
235
103,178,180,181,327
230,271,272
180
181
48,90,92,95,96,151,
172,327, 365
91,95
95,96
98
62,173
14,67
269
261
360, 363
75, 345
symbol table
SYNC
synchronization
synchronous
Synertek Systems
syntax
system architecture
system 65
358
51
39,102,348
221
261
281
38
362
table 191,197,202,276,277,285,288,
289,290,291,326,358,377
TAX 182
TAY 183
teletype input-output 233,235,236,237
ten's complement 66
test and branch 102,106,109
testing 8
timer 216,258
time sharing system 354
trace 350,351
transfer 182,183,184,185,186,187
translation 55
tree builder 313,315,316
tree search 323,324,325
trees 281,282, 313, 319,320,321,322
tree traverser
truncations
TSX
two's complement
TXA
TXS
TYA
U
UART
unconditional jump
underflow
utility programs
utility routines
313,317,318,320
25
184
17,18,19,29,63,
100, 107
185
186
187
227
95
24
262
262,348
35,356
versatile interface adapter
VIA
volatile
258
258
40
407
PROGRAMMING THE 6502
W
working registers 73,195
X
X 47, 135, 141,147, 154,180, 182,184
185,186
Y
Y 47,137,142,148,156,181,183,187,207
Z 43,107,108,110
zero 43,108,121,124,271
zero page addressing 195
408

The SYBEX Library
YOUR FIRST COMPUTER
by Rodnay Zaks 264 pp., 150 illustr., Ref. 0-045
DON'T (or How to Care for Your Computer)
by Rodnay Zaks 222 pp., 100 illustr., Ref. 0-065
INTERNATIONAL MICROCOMPUTER DICTIONARY
140 pp., Ref. 0-067
FROM CHIPS TO SYSTEMS:
AN INTRODUCTION TO MICROPROCESSORS
by Rodnay Zaks 558 pp., 400 illustr., Ref. 0-063
YOUR TIMEX SINCLAIR 1000™ AND ZX81™
by Douglas Hergert 176 pp., illustr., Ref. 0-099
YOUR COLOR COMPUTER
by Doug Mosher 350 pp., illustr., Ref. 0-097
INTRODUCTION TO WORD PROCESSING
by Hal Glatzer 216 pp., 140 illustr., Ref. 0-076
THE FOOLPROOF GUIDE TO SCRIPSIT™
by Jeff Berner 225 pp., illustr., Ref. 0-098
INTRODUCTION TO WORDSTAR™
by Arthur Naiman 208 pp., 30 illustr., Ref. 0-077
MASTERING VISICALC®
by Douglas Hergert 224 pp., illustr., Ref. 0-090
DOING BUSINESS WITH VISICALC®
by Stanley R. Trost 200 pp., Ref. 0-086
DOING BUSINESS WITH SUPERCALC™
by Stanley R. Trost 300 pp., illustr., Ref. 0-095
VISICALC® FOR SCIENCE AND ENGINEERING
by Stanley R. Trost & Charles Pomernacki 225 pp., illustr., Ref. 0-096
EXECUTIVE PLANNING WITH BASIC
by X. T. Bui 192 pp., 19 illustr., Ref. 0-083
BASIC FOR BUSINESS
by Douglas Hergert 250 pp., 15 illustr., Ref. 0-080
YOUR FIRST BASIC PROGRAM
by Rodnay Zaks 200 pp., illustr., Ref. 0-092
FIFTY BASIC EXERCISES
by J. P. Lamoitier 236 pp., 90 illustr., Ref. 0-056
BASIC EXERCISES FOR THE APPLE
by J. P. Lamoitier 230 pp., 90 illustr., Ref. 0-084
BASIC EXERCISES FOR THE IBM PERSONAL COMPUTER
by J. P. Lamoitier 232 pp., 90 illustr., Ref. 0-088
INSIDE BASIC GAMES
by Richard Mateosian 352 pp., 120 illustr., Ref. 0-055
THE PASCAL HANDBOOK
by Jacques Tiberghien 492 pp., 270 illustr., Ref. 0-053
INTRODUCTION TO PASCAL (Including UCSD Pascal™)
by Rodnay Zaks 422 pp., 130 illustr., Ref. 0-066
DOING BUSINESS WITH PASCAL
by Richard Hergert & Douglas Hergert 380 pp., illustr., Ref. 0-091
APPLE® PASCAL GAMES
by Douglas Hergert and Joseph T. Kalash 376 pp., 40 illustr., Ref. 0-074
CELESTIAL BASIC: Astronomy on Your Computer
by Eric Burgess 320 pp., 65 illustr., Ref. 0-087
PASCAL PROGRAMS FOR SCIENTISTS AND ENGINEERS
by Alan R. Miller 378 pp., 120 illustr., Ref. 0-058
BASIC PROGRAMS FOR SCIENTISTS AND ENGINEERS
by Alan R. Miller 326 pp., 120 illustr., Ref. 0-073
FORTRAN PROGRAMS FOR SCIENTISTS AND ENGINEERS
by Alan R. Miller 320 pp., 120 illustr., Ref. 0-082
PROGRAMMING THE 6809
by Rodnay Zaks and William Labiak 520 pp., 150 illustr., Ref. 0-078
PROGRAMMING THE 6502
by Rodnay Zaks 388 pp., 160 illustr., Ref. 0-046
6502 APPLICATIONS
by Rodnay Zaks 286 pp., 200 illustr., Ref. 0-015
ADVANCED 6502 PROGRAMMING
by Rodnay Zaks 292 pp., 140 illustr., Ref. 0-089
PROGRAMMING THE Z80
by Rodnay Zaks 626 pp., 200 illustr., Ref. 0-069
Z80 APPLICATIONS
by James W. Coffron 300 pp., illustr., Ref. 0-094
PROGRAMMING THE Z8000
by Richard Mateosian 300 pp., 124 illustr., Ref. 0-032
THE CP/M® HANDBOOK (with MP/M™)
by Rodnay Zaks 324 pp., 100 illustr., Ref. 0-048
MASTERING CP/M®
by Alan R. Miller 320 pp., Ref. 0-068
INTRODUCTION TO THE UCSD p-SYSTEM™
by Charles W. Grant and Jon Butah 250 pp., 10 illustr., Ref. 0-061
A MICROPROGRAMMED APL IMPLEMENTATION
by Rodnay Zaks 350 pp., Ref. 0-005
THE APPLE® CONNECTION
by James W. Coffron 228 pp., 120 illustr., Ref. 0-085
MICROPROCESSOR INTERFACING TECHNIQUES
by Rodnay Zaks and Austin Lesea 458 pp., 400 illustr., Ref. 0-029
FOR A COMPLETE CATALOG
OF OUR PUBLICATIONS
U.S.A. FRANCE GERMANY
SYBEX, Inc. SYBEX SYBEX-VERLAG
2344 Sixth Street 4PlaceF6lix-Ebou6 Heyestr.22
Berkeley, 75583 Paris Cedex 12 4000Diisseldorf 12
California 94710 France West Germany
Tel: (800)227-2346 Tel: 1/347-30-20 Tel: (0211)287066
Telex: 336311 Telex: 211801 Telex: 08588163
COMPUTERBOOKS ARE DIFFERENT.
Here is why...
At SYBEX, each book is designed with you in mind. Every manuscript is
carefully selected and supervised by our editors, who are themselves com
puter experts. Programs are thoroughly tested for accuracy by our techni
cal staff. Our computerized production department goes to great lengths
to make sure that each book is designed as well as it is written. We publish
the finest authors, whose technical expertise is matched by an ability to
write clearly and to communicate effectively.
In the pursuit of timeliness, SYBEX has achieved many publishing firsts.
SYBEX was among the first to integrate personal computers used by
authors and staff into the publishing process. SYBEX was the first to
publish books on the CP/M operating system, microprocessor interfacing
techniques, word processing, and many more topics.
Expertise in computers and dedication to the highest quality in book pub
lishing have made SYBEX a world leader in microcomputer education.
Translated into fourteen languages, SYBEX books have helped millions of
people around the world to get the most from their computers. We hope
we have helped you, too.

\end{document}